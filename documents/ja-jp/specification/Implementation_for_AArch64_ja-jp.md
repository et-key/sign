# Sign言語 AArch64実装仕様

## 1. Sign言語の本質

### 1.1 「読めるVM」という哲学

Sign言語は**演算子がアセンブリ命令に直接対応する**言語です。

```
演算子 → アセンブリ命令
```

これだけ。

複雑なコンパイラ最適化、パターン認識、自動並列化などは**不要**です。

### 1.2 ハイブリッドマシン

Sign言語の実行モデル：

```
スタックマシン（値空間）
    ↕ 境界演算子（$, @, #）
レジスタマシン（位置空間）
```

- **値空間**: 計算される値
- **位置空間**: メモリアドレス、I/O
- **境界演算子**: 両者を接続

## 2. 標準ABI準拠

### 2.1 なぜ独自レジスタ割り当てを避けるか

- C言語との相互運用で変換コストが発生
- 既存ツール（GDB等）が使えない
- 標準ABIの最適化を捨てている

### 2.2 標準ABIでのシンプルな実装

Sign言語の演算子は、標準AArch64 ABIのレジスタを使って、そのまま対応する命令に変換されます。

```
X0-X7   : 引数・戻り値（ABI標準）
X19-X28 : Callee-saved（長命な値）
SP      : スタックポインタ
```

**これ以上の特別な仕組みは不要**

## 3. 演算子とアセンブリ命令の対応

### 3.1 算術演算子

| Sign演算子 | AArch64命令 | 備考 |
|-----------|------------|------|
| `x + y` | `add x0, x0, x1` | 整数加算 |
| `x - y` | `sub x0, x0, x1` | 整数減算 |
| `x * y` | `mul x0, x0, x1` | 整数乗算 |
| `x / y` | `sdiv x0, x0, x1` | 整数除算 |
| `x % y` | `udiv x2, x0, x1`<br>`msub x0, x2, x1, x0` | 剰余 |
| `x ^ y` | （ループまたはライブラリ） | 冪乗 |

浮動小数点の場合：
| Sign演算子 | AArch64命令 |
|-----------|------------|
| `x + y` | `fadd d0, d0, d1` |
| `x - y` | `fsub d0, d0, d1` |
| `x * y` | `fmul d0, d0, d1` |
| `x / y` | `fdiv d0, d0, d1` |

### 3.2 比較演算子

| Sign演算子 | AArch64命令 | 備考 |
|-----------|------------|------|
| `x < y` | `cmp x0, x1`<br>`csel x0, x0, xzr, lt` | 真なら左辺、偽なら_ |
| `x <= y` | `cmp x0, x1`<br>`csel x0, x0, xzr, le` | 同上 |
| `x = y` | `cmp x0, x1`<br>`csel x0, x0, xzr, eq` | 同上 |
| `x >= y` | `cmp x0, x1`<br>`csel x0, x0, xzr, ge` | 同上 |
| `x > y` | `cmp x0, x1`<br>`csel x0, x0, xzr, gt` | 同上 |
| `x != y` | `cmp x0, x1`<br>`csel x0, x0, xzr, ne` | 同上 |

**重要**: 比較演算子は値を返す。真なら変数項の値、偽なら`_`（ゼロレジスタ）

### 3.3 論理演算子

| Sign演算子 | AArch64命令 | 備考 |
|-----------|------------|------|
| `x & y` | `cbz x0, .false`<br>（yを評価）<br>`.false: mov x0, xzr` | 短絡評価 |
| `x \| y` | `cbnz x0, .done`<br>（yを評価）<br>`.done:` | 短絡評価 |
| `!x` | `cmp x0, #0`<br>`cset x0, eq` | 否定 |

### 3.4 境界演算子

| Sign演算子 | AArch64命令 | 意味 |
|-----------|------------|------|
| `$x` | `adrp x0, x`<br>`add x0, x0, :lo12:x` | アドレス取得 |
| `@addr` | `ldr x0, [x0]` | メモリ読み込み |
| `addr # val` | `str x1, [x0]` | メモリ書き込み |

### 3.5 リスト演算子

`具体例として + 演算子を使用`

| Sign演算子 | 意味 | 実装 |
|-----------|------|------|
| `x, y` | リスト構築 | メモリ連続配置 |
| `[+ 2,]` | MAP | リストの各要素にfを適用 |
| `[+]` | FOLD | リストを左から畳み込み |

**重要**: これらは「演算子」であって「関数」ではない。
コンパイラがパターン認識するのではなく、演算子定義に従って展開される。

## 4. リスト処理の実装

### 4.1 小規模リスト（1-8要素）

```sign
1, 2, 3, 4
```

↓ 単純にレジスタに配置

```assembly
mov x0, #1
mov x1, #2
mov x2, #3
mov x3, #4
# リスト先頭アドレスをどこかに保持
```

### 4.2 MAP演算子 `[f,]`

```sign
[* 2,] 1, 2, 3, 4
```

**これは演算子の組み合わせ**:
- `[` ブロック開始
- `* 2` 部分適用された関数
- `,` リスト演算子
- `]` ブロック終了

↓ 演算子定義に従って機械的に展開

```assembly
# 各要素に `* 2` を適用
lsl x0, x0, #1    # 1 * 2
lsl x1, x1, #1    # 2 * 2
lsl x2, x2, #1    # 3 * 2
lsl x3, x3, #1    # 4 * 2
```

**コンパイラは「これはmapだ！」と認識しない**。
単に演算子定義に従って展開するだけ。

### 4.3 大規模リストの場合

要素数が多い場合、演算子定義でループ展開を指定：

```assembly
# [f,] の演算子定義（疑似コード）
.macro APPLY_TO_LIST func, list
    mov x10, list          # リスト先頭
    ldr x11, [x10, #-8]    # 要素数
.loop:
    ldr x0, [x10], #8      # 要素ロード
    bl \func               # 関数適用
    str x0, [x12], #8      # 結果保存
    subs x11, x11, #1
    b.ne .loop
.endm
```

これも「パターン認識」ではなく、演算子定義の展開。

## 5. NEON/SVE対応

### 5.1 基本方針

**Sign言語自体はSIMDを意識しない**。

演算子定義の中で、適切な命令を使うだけ：

```assembly
# * 演算子のNEON版定義（演算子定義ファイル内）
.macro MUL_NEON src1, src2
    ld1 {v0.4s}, [\src1]
    ld1 {v1.4s}, [\src2]
    mul v0.4s, v0.4s, v1.4s
    st1 {v0.4s}, [result]
.endm
```

**コンパイラは演算子定義を展開するだけ**。

### 5.2 SVE対応

SVEが使える環境では、演算子定義がSVE版になる：

```assembly
# * 演算子のSVE版定義
.macro MUL_SVE src1, src2
    ptrue p0.s
    ld1w z0.s, p0/z, [\src1]
    ld1w z1.s, p0/z, [\src2]
    mul z0.s, z0.s, z1.s
    st1w z0.s, p0, [result]
.endm
```

**ユーザーコードは変わらない**。演算子定義が切り替わるだけ。

## 6. メモリ管理

### 6.1 スコープベース領域管理

Sign言語の3つのスコープ：

```
無名スコープ                     → スタック（即座に解放）
ローカルスコープ                 → ファイル領域（ファイル終了で解放）
プロジェクティブ・エクスポート   → プロジェクト領域（ファイル終了で解放）
グローバル・エクスポート         → グローバル領域（ARCを想定しているが、もっと良い方法があれば）
Pin領域・エクスポート            → グローバル領域（Pin領域）
```

### 6.2 シンプルなバンプアロケータ（Signでも実装可能なはず）

```assembly
# ファイルスコープ領域
.data
file_region: .space 1048576    # 1MBの領域
file_ptr: .quad file_region    # 次の空き位置

.text
alloc_file:
    # x0 = サイズ
    adrp x1, file_ptr
    add x1, x1, :lo12:file_ptr
    ldr x2, [x1]               # 現在位置
    add x3, x2, x0             # 新しい位置
    str x3, [x1]               # 更新
    mov x0, x2                 # アドレス返却
    ret

# ファイル終了時
cleanup_file:
    adrp x1, file_ptr
    add x1, x1, :lo12:file_ptr
    adrp x2, file_region
    add x2, x2, :lo12:file_region
    str x2, [x1]               # ポインタをリセット
    ret
```

**それ以上の複雑な仕組みは不要**。

## 7. 関数呼び出し

### 7.1 標準ABI準拠

```sign
add : x y ? x + y
```

↓

```assembly
add:
    # x=X0, y=X1（標準ABI）
    add x0, x0, x1
    ret
```

### 7.2 カリー化（クロージャ）

```sign
f : x y ? x + y
partial : add 5
result : partial 3
```

↓

```assembly
# add関数（第1引数のみ）
f_partial:
    # x=X0を保存したクロージャを返す
    # クロージャ = [関数ポインタ, キャプチャ値]
    adrp x1, closure_pool
    add x1, x1, :lo12:closure_pool
    bl alloc_closure          # クロージャ確保
    
    adrp x2, add_stage2
    add x2, x2, :lo12:add_stage2
    str x2, [x0, #0]          # 関数ポインタ
    str x0, [x0, #8]          # キャプチャしたx（引数X0）
    ret

# 第2引数受け取り
add_stage2:
    # X0=クロージャ, X1=y
    ldr x2, [x0, #8]          # キャプチャしたx
    add x0, x2, x1            # x + y
    ret
```

**これも標準ABI準拠**。複雑なレジスタ操作は不要。

## 8. Pull-based Evaluation（遅延評価）

### 8.1 サンク構造

```
[code_ptr: 64bit]
[env_ptr: 64bit]
```

16バイト。これだけ。

### 8.2 Force実装

```assembly
force:
    ldr x10, [x0, #0]         # 関数ポインタ
    ldr x11, [x0, #8]         # 環境
    mov x0, x11               # 環境を引数に
    blr x10                   # 実行
    ret
```

**キャッシングなどの複雑な仕組みは後から追加可能**。
まずはシンプルに。

## 9. 実装の流れ

### 9.1 コード生成

```
[+ x y]
```

↓ 演算子定義を参照

```assembly
add x0, x0, x1
```

**それだけ**。

## 10. 実装ロードマップ

### Phase 1: 基本演算子（1ヶ月）

- [ ] 算術演算子（+, -, *, /, %）
- [ ] 比較演算子（<, <=, =, >=, >, !=）
- [ ] 論理演算子（&, |, !）
- [ ] 標準ABI準拠の関数呼び出し

### Phase 2: リスト処理（1ヶ月）

- [ ] リスト構築（,）
- [ ] MAP演算子（[f,]）
- [ ] FOLD演算子（[+]等）
- [ ] 範囲リスト（[1 ~ 10]）

### Phase 3: メモリ管理（1ヶ月）

- [ ] バンプアロケータ
- [ ] スコープベース解放
- [ ] 境界演算子（$, @, #）

### Phase 4: 遅延評価（1ヶ月）

- [ ] サンク構造
- [ ] Force実装
- [ ] 無限リスト

### Phase 5: 検証（1ヶ月）

- [ ] テストスイート
- [ ] C言語相互運用
- [ ] 実アプリケーション

## 11. 実装の原則

### 11.1 シンプルさを保つ

❌ **やらないこと**:
- パターン認識
- 高度なコンパイラ最適化
- 自動並列化
- プロファイリング誘導最適化
- 型推論（構文で決まる）

✅ **やること**:
- 演算子→命令の機械的変換
- 標準ABI準拠
- 明確なメモリ管理
- テキストベースの段階的変換

### 11.2 「読めるVM」であること

生成されたアセンブリコードを見れば、Sign言語のコードが**そのまま読める**こと。

```sign
x + y * 2
```

↓

```assembly
lsl x1, x1, #1    # y * 2
add x0, x0, x1    # x + (y*2)
```

**対応が明確**。

### 11.3 拡張性

複雑な最適化は**演算子定義の拡張**として実装可能。

```
標準定義:   + → add
NEON定義:   + → fadd (ベクトル)
SVE定義:    + → fadd (可変長ベクトル)
GPU定義:    + → cuda_add
```

**コンパイラ本体は変えない**。

## 12. 結論

Sign言語のAArch64実装は**シンプル**であるべきです：

1. **演算子→命令の直接対応**
2. **標準ABI準拠**
3. **機械的なテキスト変換**
4. **明確なメモリ管理**

複雑なコンパイラ最適化、パターン認識、自動並列化は**不要**です。

Sign言語の美しさは、**シンプルさ**にあります。

この仕様は、その哲学を忠実に実装するための指針です。
