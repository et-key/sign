# Sign言語パーサー設計の核心ポイント

## 基本設計原則

**段階的変換戦略**: Sign記法 → S式 → ターゲット最適化
- Sign記法をS式に正規化（理論的統一性）
- S式からハイブリッドマシン向け最適化（実装効率性）
- スタック操作とレジスタ操作の自然な対応付け

**Zero Cost Domain Abstraction**: 理論的美しさと実装効率の両立
- Sign → Sign への段階的テキスト置換
- 最終的に統一されたSign記法（S式相当）を生成
- ASTは不要（構文と型が対応しているため）

## トークナイズの実際

**実装上の発見**: 文字列・文字保護後は、空白・改行区切りでトークナイズ完了
1. **文字列保護**: `で囲まれた部分をそのまま保持
2. **文字保護**: `\`+任意の1文字を保持  
3. **残りは単純分割**: 空白区切り・改行区切りのみ

**他言語との違い**:
- 複雑な予約語判定が不要
- 文脈依存の字句解析が最小限
- 数値リテラル等の判定は分割後で十分

この極度にシンプルな字句解析こそ、Sign言語設計の核心的美しさ。

1. **ブロック化**: インデント構造をカッコ構造に変換  
2. **優先順位**: 高い順から段階的にカッコ付け
3. **正規化**: 全演算子をS式に統一
4. **最適化準備**: ハイブリッドマシン向けの変換情報を付与

## 重要な設計判断

## 重要な設計判断

### 記号の文脈判定
**空白との区切り方が唯一の決定要因**
- **前置演算子**: 対象値との間に空白なし（`!x`, `@data`）
- **中置演算子**: 前後に空白必須（`x + y`, `a | b`）  
- **後置演算子**: 対象値との間に空白なし（`5!`, `list~`）

**なぜ空白が決定的か**: Sign言語では空白自体が「余積演算子」として機能するため、空白の有無は構文的に意味を持つ。

## 優先順位処理の簡略化

**実装上の重要な原則**: 単項演算の優先順位は2項演算より常に高い
- **2項演算のみ**：優先順位テーブルで管理（`+`, `-`, `*`, `/`, `=`, `<`, etc.）
- **単項演算（前置・後置）**：常に最高優先として一律処理

**実装上の利点**:
- 優先順位テーブルが大幅簡略化
- パーサーロジックの単純化
- エラー発生率の低減

**処理順序**:
1. 単項演算子を全て先に処理（前置・後置の区別のみ）
2. 残った2項演算を優先順位順に処理

### 最適化を考慮した中間表現設計
**パーサーが付与すべき情報**:
- **スタック適性**: リスト操作、余積演算（データスタック向け）
- **レジスタ適性**: 算術演算、比較演算（レジスタ直接操作向け）  
- **SIMD候補**: MAP/FOLD演算（ベクトル命令変換候補）
- **メモリ配置**: エクスポート、ローカル、無名スコープの区別

この情報により、後段でスタック/レジスタ/SIMD命令への効率的変換が可能。
- **多項式比較**: `3 < x = y < 20` の連鎖変換
- **余積演算**: 空白の4つの意味（適用・合成・追加・結合）
- **混在回避**: 条件式と一般処理の同一階層混在を防ぐ

### ブロック構文解析の根本原理
**リテラル制約による曖昧性排除**
- **文字列リテラル**: 改行と`を含まない制約
- **文字リテラル**: `\` + 改行は一つの文字トークンとして保護

**なぜこの制約が決定的か**: 
- 改行は確実に「文の境界」として機能
- タブ文字は確実に「ブロック構造」として機能  
- `記号は確実に「文字列境界かコメント開始」として機能

**ブロック開始の実質的条件**: 改行＋インデント
- **`:`（定義）の後**: 定義値のブロック
- **`?`（ラムダ）の後**: 関数本体のブロック  
- **行頭カッコ**: 明示的ブロック式

この根本設計により、インデント処理が一意に決まり、文字列内容とブロック構造が混同されることがない。

## 実装時の注意点

1. **段階的脱糖**: Sign記法をS式へ変換
2. **最適化情報保持**: スタック操作・レジスタ操作への変換情報を維持
3. **ハイブリッド対応**: データスタック（レジスタ）とコールスタック（メモリ）の区別

これにより理論的統一性と実装効率性を両立した処理系基盤が実現される。