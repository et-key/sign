# Sign言語パーサー設計仕様

## 基本原理

多様な記法を統一された記法に正規化するのみなので、ASTに頼らずともS式木と同等の木構造で十分な表現が可能である。

理由：構文と型が対応しているため

### 記法変換
* 委細の処理を考えると段階的なテキスト置換である
* 飽くまで、Sign ⇒ Sign への変換である
* S式に基づいた記法変換である

## トークン保護ルール
* 文字列内の空白は構文解析によって区切られない、カッコ付けを行うことで演算やラムダ記法との区分は可能
```
`	Hello World`
↓
[`	Hello World`]
```

* 文字の空白は、構文解析によって区切られない
```
\x \  \y
↓
[\x [\ ] \y]
```
```
\	 \x \y
↓
[\	 \x \y]
```
* 文字の↵は、構文解析によって区切られない
```
`Hello` \
`	World`
[`Hello` \
 `	World`]
```

## 構文と型の対応関係について

* 「ブロック構文開始前」「ブロック階層の深化前」の行の末尾は必ず以下の記号で終わる
  * `?`
  * `:`
  * 行頭 + `[`、
  * 行頭 + `{`、
  * 行頭 + `(`、
  
  で終わる

* インデント→カッコ変換
  ```
  x :
    v : 3
    f : y ?
      y = 0 : x ' v
      y = 1 : y

  ↓

  x : {(v : 3) (f : y ? {(y = 0 : x ' v) (y = 1 : y)})}
  ```
* 多項式では、結合順序又は演算子の優先順位で二項式に置換え可能
  ```
  test : 1 + 3! * 2
  ↓
  [test : [1 + [3! * 2]]]
  ```
  ```
  test : (1 + 3!) * 2
  ↓
  [test : [[1 + 3!] * 2]]
  ```
  ```
  test : a & b | ![c & !d | e] & aa
  [test : [[a & b] | [![[c & !d] | e] & aa]]]
  ```
  ```
  test : a & b & ![c | !d & e] | aa
  [test : [[[a & b] & ![c | [!d & e]]] | aa]]
  ```

* 左結合、右結合の区分とリスト化による処理の明確化

  ```
  [+ 2] [* 4] [+ 3] [^ 2]
  ↓
  [[[[+ 2] [* 4]] [+ 3]] [^ 2]]
  ```
  ```
  [+ 2] [* 4] [+ 3] [^ 2]
  ↓
  [[+ 2] , [[* 4] , [[+ 3] , [^ 2]]]]
  ```
  ```
  [+] 1 2 3
  ↓
  [[+] [[1 2] 3]]
  ```
  ```
  [+ 2,] [* 4,] [+] 1 2 3
  ↓
  [[[[+ 2,] [* 4,]] [+]] [[1 2] 3]]
  ```

### 位置判定ルール（対象はリテラル又はインラインブロック）
- **対象**の間が**空白に区切られる中間記号** → 中置演算子
- **先頭記号**の後に**空白無く続く対象** → 前置演算子
- **対象**の後に**空白無く続く末尾記号** → 後置演算子  
- 記号で囲み → 特殊囲み記法（絶対値等）

## 変換規則
- **中置演算子**: `1 + 2` → `[[+] 1 2]`
- **前置演算子**: `!x` → `[[!_] x]`
- **後置演算子**: `10!` → `[[_!] 10]`
- **定義**: `f : expr` → `[[:] f expr]`
- **ラムダ**: `x ? body` → `[[?] x body]`
- **絶対値囲み**: `|x + y|` → `[[|_|] [[+] x y]]`

## 処理手順
1. トークンを保護する
2. ブロック構文を判定し、カッコ付けを行う
3. 絶対値囲みの前後にカッコ付けを行う
3. 優先順位に従ってカッコ付けを行い、多項式を二項演算の組に直す
4. 二項演算をラムダ記法へ記法変換
5. 前置演算、後置演算がついた部分を丸ごとカッコ付けを行う
5. 単項演算をラムダ記法へ記法変換

## まとめ
- **段階的再帰処理**で複雑な構造を自然
- **インデントブロック**をネストリストに変換し、カッコと同等に扱う
- **多項式表現**と**遅延評価**で結合性を解決
- **ポイントフリー記法**で全演算子を統一 
- **優先順位処理**は高から低へ段階的に展開
- **トークン保護**で複雑な要素を安全に処理
- **最終的に統一されたSign言語記法**を生成