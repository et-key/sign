# Sign言語パーサー設計の核心ポイント

## Sign言語の核心原理

Sign言語のパーサー設計を理解する上で、最も重要な4つの原則があります。

### 事前に…

```javascript

comment = /^`[^\r\n]$/gm

string = /`[^`\r\n]`/g

charactor = /\\[\s\S]/g

```

### ４つの原則

1. **文字列かそれ以外か**
   - `` ` `` で囲まれた部分は**文字列リテラル**として保護
   - この時点で、文字列内の全ての文字は「内容」として扱われる
   - 文字列内の演算子や空白は、操作的な意味を持たない

2. **文字かそれ以外か**
   - `\` の直後の1文字は**文字リテラル**として保護
   - 改行(`\↵`)も含め、あらゆる文字を表現可能
   - 文字列と同様、文字指定された改行、空白、演算子は、操作的な意味を持たない

3. **ブロックの中か外か**
   - インデントの深さ　＝　ブロックの深さ
   - 同じ深さのブロックは、一つのカッコの中と同義であり、改行は空白区切りと同じ
   - 各ブロックの終わりは、dedentで識別する

4. **リテラルか記号か**
   - Sign言語には予約語が存在しないため、この判定は極めて単純
   - 保護されなかった残りのトークンは、**値(リテラル)** または **演算子(記号)** のどちらか
   - 数値・識別子 → リテラル
   - その他の記号 → 演算子

### なぜこの原則が革命的か

この原則により、Sign言語は以下を実現します。

1. **字句解析の極限的単純化**
   - 複雑な状態機械が不要
   - 文字列の括り・文字の空白以外、すべてのトークンは空白か改行で区切られる

2. **構文と意味の一致**
   - トークンの形が直接その役割を示す
   - 文脈依存の曖昧性がほぼ存在しない

3. **パーサーとレクサーの統合可能性**
   - 全てが二項演算の組として表現される
   - ASTが不要になる基盤

この原則は、後述する「Zero Cost Domain Abstraction」や「段階的変換戦略」の根幹を成します。

## 基本設計原則

**段階的変換戦略**: Sign記法 → S式 → ターゲット最適化

**Zero Cost Domain Abstraction**: 理論的美しさと実装効率の両立
- Sign → Sign への段階的テキスト置換
- ASTは不要（構文と型が対応）

## パース処理の流れ

1. **ブロック化**: インデント構造またはカッコで囲まれた部分の記述をカッコ構造に変換
2. **優先順位**: 高い順から段階的にカッコ付け
3. **正規化**: 全演算子をS式に統一

## 重要な設計判断

### 記号の文脈判定

**前提**: 第三段階(リテラルか記号か)の判定後、記号の位置を決定

**空白との区切り方が唯一の決定要因**
- **前置演算子**: 対象値との間に空白なし（`!x`, `@data`）
- **中置演算子**: 前後に空白必須（`x + y`, `a | b`）  
- **後置演算子**: 対象値との間に空白なし（`5!`, `list~`）

**なぜ空白が決定的か**: Sign言語では空白自体が「余積演算子」として機能するため、空白の有無は構文的に意味を持つ。

## 優先順位処理の簡略化

**実装上の重要な原則**: 単項演算の優先順位は2項演算より高い（※例外あり）
- **2項演算のみ**：優先順位テーブルで管理（`+`, `-`, `*`, `/`, `=`, `<`, etc.）
- **単項演算（前置・後置）**：
   - 単項演算の「~」は前置、後置ともに積という性質上、他の演算子との優先順位を守らなければならない。
   - その他の単項演算の優先順位は簡略化可能：
      - 前置：右単位元、右結合
      - 後置：左単位元、左結合

**実装上の利点**:
- 優先順位テーブルが大幅簡略化
- パーサーロジックの単純化
- エラー発生率の低減（演算子表の前置及び後置演算子の優先順位は型を意識したものであるため、型チェックに使う手もある）

**処理順序**:
1. 単項演算子を全て先に処理（前置・後置の区別のみ）
2. 残った2項演算を優先順位順に処理

### ブロック構文解析の根本原理

**リテラル制約による曖昧性排除**
- **文字列リテラル**: 改行と`` ` ``を含まない制約
- **文字リテラル**: `\` + 改行は一つの文字トークンとして保護

**なぜこの制約が決定的か**:
- 改行は確実に境界として機能
- タブ文字は確実に「ブロック構造」として機能  
- `` ` ``記号は確実に「文字列境界かコメント開始」として機能

**ブロック開始の実質的条件**: 改行＋インデント
- **`:`（定義）の後**: 定義値のブロック
- **`?`（ラムダ）の後**: 関数本体のブロック  
- **カッコ**: 明示的ブロック式
- **インデント**: 明示的ブロック式

この根本設計により、インデント処理が一意に決まり、文字列内容とブロック構造が混同されることがない。