# Sign言語パーサー設計の核心ポイント

## 基本設計原則

**段階的変換戦略**: Sign記法 → S式 → ターゲット最適化
- Sign記法をS式に正規化（理論的統一性）

**Zero Cost Domain Abstraction**: 理論的美しさと実装効率の両立
- Sign → Sign への段階的テキスト置換
- 最終的に統一されたSign記法（S式相当）を生成
- ASTは不要（構文と型が対応しているため）

## トークナイズの実際

**実装上の発見**: 文字列・文字保護後は、空白・改行区切りでトークナイズ完了
1. **文字列保護**: `で囲まれた部分をそのまま保持
2. **文字保護**: `\`+任意の1文字を保持  
3. **残りは単純分割**: 空白区切り・改行区切りのみ

**他言語との違い**:
- 複雑な予約語判定が不要
- 文脈依存の字句解析が最小限
- 数値リテラル等の判定は分割後で十分

この極度にシンプルな字句解析こそ、Sign言語設計の核心的美しさ。

1. **ブロック化**: インデント構造をカッコ構造に変換  
2. **優先順位**: 高い順から段階的にカッコ付け
3. **正規化**: 全演算子をS式に統一

## 重要な設計判断

### 記号の文脈判定
**空白との区切り方が唯一の決定要因**
- **前置演算子**: 対象値との間に空白なし（`!x`, `@data`）
- **中置演算子**: 前後に空白必須（`x + y`, `a | b`）  
- **後置演算子**: 対象値との間に空白なし（`5!`, `list~`）

**なぜ空白が決定的か**: Sign言語では空白自体が「余積演算子」として機能するため、空白の有無は構文的に意味を持つ。

## 優先順位処理の簡略化

**実装上の重要な原則**: 単項演算の優先順位は2項演算より常に高い
- **2項演算のみ**：優先順位テーブルで管理（`+`, `-`, `*`, `/`, `=`, `<`, etc.）
- **単項演算（前置・後置）**：常に最高優先として一律処理

**実装上の利点**:
- 優先順位テーブルが大幅簡略化
- パーサーロジックの単純化
- エラー発生率の低減

**処理順序**:
1. 単項演算子を全て先に処理（前置・後置の区別のみ）
2. 残った2項演算を優先順位順に処理

### ブロック構文解析の根本原理
**リテラル制約による曖昧性排除**
- **文字列リテラル**: 改行と`を含まない制約
- **文字リテラル**: `\` + 改行は一つの文字トークンとして保護

**なぜこの制約が決定的か**: 
- 改行は確実に「文の境界」として機能
- タブ文字は確実に「ブロック構造」として機能  
- `記号は確実に「文字列境界かコメント開始」として機能

**ブロック開始の実質的条件**: 改行＋インデント
- **`:`（定義）の後**: 定義値のブロック
- **`?`（ラムダ）の後**: 関数本体のブロック  
- **行頭カッコ**: 明示的ブロック式

この根本設計により、インデント処理が一意に決まり、文字列内容とブロック構造が混同されることがない。