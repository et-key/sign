# Sign言語パーサー設計仕様

## 基本原理

**Sign言語記法変換器**：多様なSign記法を統一されたSign記法に正規化する。

## 段階的再帰処理アルゴリズム

### 処理フロー
```
1. トークナイズ（保護）
2. 記法変換  
3. 1段階内側を展開
4. 繰り返し（変化がなくなるまで）
```

### トークン保護ルール（待避リストにpushする）
- **カッコ内**: `[+ 1]` → `"__inline[N]__"`
- **ブロック内**: インデント部分 → `"__block[N]__"`
- **文字列**: `"hello"` → `"__string[N]__"`
- **文字**: `\ ` → `"__chr[N]__"`

### 変換例
```
入力: f : x ? [+ 1] (x * 2)

段階1: f : x ? "__inline[0]__" "__inline[1]__"
      → ([:] f ([?] x "__inline[0]__" "__inline[1]__"))
      
段階2: ([:] f ([?] x ([+] 1)  "__inline[1]__"))
      → ([:] f ([?] x ([+] 1) "__inline[1]__"))
      
段階3: ([:] f ([?] x ([+] 1) ([*] x 2)))
      → 完了（評価順序に変化なし）
```

## ブロック構造の統一処理

**インデントブロック = ネストしたリスト構造**

### インデント→カッコ変換
```
x :
    v : 3
    f : y ?
        y = 0 : x ' v
        y = 1 : y

↓

x : {(v : 3) (f : y ? {(y = 0 : x ' v) (y = 1 : y)})}

↓

([:] x {([:] v 3) ([:] f ([?] [x y] {([:] ([=] y 0) (['] x v)) ([:] ([=] y 1) y)}))})
```

### 特性
- 同じインデントレベル = 同じリスト内の要素
- 深いインデント = ネストしたリスト構造
- インラインカッコと完全に等価な処理
- 段階的処理で自然に展開

**段階的処理によりカッコが優先順位境界を自動形成**

### 例：優先順位の自然な処理
```
入力: (2 + 3) * 4

段階1: "__inline[0]__" * 4 → ([*] __inline[0]__ 4)
段階2: ([*] ([+] 2 3) 4)
```

### 特性
- カッコ内は後の段階で独立処理
- カッコ外の演算子が先に処理される
- 優先順位判定ロジック不要
- 自然な数学記法との一致

## 結合性の革命的解決

**中置記法の制約から多項演算への転換**

### 統一的な多項式表現
```
5 + 4 + 3 + 2  →  ([+] 5 4 3 2)  // 左結合演算子
5 ^ 4 ^ 3 ^ 2  →  ([^] 5 4 3 2)  // 右結合演算子
```

### 遅延評価による結合順序解決
- **構文解析時**: すべて同一の多項式形式
- **評価時**: 遅延評価が適切な結合順序を自動選択
- **結果**: 構文解析器に結合性判定ロジック不要

### 特性
- 全演算子が完全に統一的な処理
- 左結合・右結合の区別が構文レベルで消滅
- 遅延評価システムに評価順序を委譲

**高優先順位から低優先順位の順で処理**

### 処理順序
```
優先順位16: * / % (最高)
優先順位15: + -
...
優先順位1: # (最低)
```

### 例：自然な優先順位処理
```
a + b * c - d

段階1(優先順位16): a + ([*] b c) - d  
段階2(優先順位15): ([+] a ([*] b c)) - d → ([-] ([+] a ([*] b c)) d)
```

### 特性
- 数学的優先順位と完全一致
- 高優先順位が先に「保護」される
- 段階的に低優先順位が包み込む構造

**ポイントフリー記法によるラムダ化で統一処理**

### 変換規則
- **中置演算子**: `1 + 2` → `([+] 1 2)`
- **前置演算子**: `!x` → `([!_] x)`
- **後置演算子**: `10!` → `([_!] 10)`
- **定義**: `f : expr` → `([:] f expr)`
- **ラムダ**: `x ? body` → `([?] x body)`
- **絶対値囲み**: `|x + y|` → `([|_|] ([+] x y))`

### 位置判定ルール（対象はリテラル又はインラインブロック）
- **先頭記号**の後に**空白無く続く対象** → 前置演算子
- **対象**の後に**空白無く続く末尾記号** → 後置演算子  
- **対象**の間が**空白に区切られる中間記号** → 中置演算子
- 記号で囲み → 特殊囲み記法（絶対値等）

### 特性
- `_`（Unit）の位置で演算子の位置情報を表現
- 全演算子が統一的な関数適用形式
- カッコの種類は無関係（()、[]、{}は同一）

## まとめ
- **段階的再帰処理**で複雑な構造を自然
- **インデントブロック**をネストリストに変換し、カッコと同等に扱う
- **多項式表現**と**遅延評価**で結合性を解決
- **ポイントフリー記法**で全演算子を統一 
- **優先順位処理**は高から低へ段階的に展開
- **トークン保護**で複雑な要素を安全に処理
- **最終的に統一されたSign言語記法**を生成
- **拡張性**: 新しい記法や演算子も容易に追加可能
- **保守性**: 明確な段階的処理で理解しやすい設計
- **効率性**: 再帰的処理と遅延評価で高速な解析と評価を実現
- **一貫性**: 全ての記法が統一されたルールで処理され、予測可能な動作を保証
- **柔軟性**: 多様な記法をサポートし、ユーザーのニーズに対応可能
- **将来性**: 新しい技術や記法の導入に柔軟に対応できる設計
