# Sign言語型システム

## 1. 「見えない強い静的型付け」の本質

Sign言語の型システムは、従来のプログラミング言語とは異なるアプローチを採用しています。特に「見えない強い静的型付け」という概念は、型の存在を意識させずに、型安全性を確保することを目指しています。
この型の本質は、以下のようにして担保されています：

- **名前＝型**：識別子の名前自体が型を表現し、明示的な型宣言を不要にする
- **値＝型**：値そのものが型を持ち、型の不一致はコンパイル時に検出される
- **構文＝型**：言語の構文が型を担保し、プログラマーは型を意識せずにコーディングできる

## 2. リスト基盤の統一データモデル

Sign言語の型システムは、リストという統一概念を中心に構築されています：

- **文字列** = 文字のリスト（「文字のリストは文字列として扱う」）
- **ブーリアン評価** = 値のパターンマッチング（「空のリストと未評価なラムダ項はfalse」）
- **関数** = 操作のリスト、または演算子の関数化
- **コレクション** = 値のリスト、またはキー・値ペアのリスト

この一貫したアプローチにより、特殊ケース処理が最小化され、言語の学習と理解が容易になります。

## 3. 数値リテラルとハードウェア型対応

Sign言語の数値リテラルは単なる値ではなく、ハードウェア操作に対応する型として機能します：

- **0x**（16進数）：アーキテクチャのアドレス型、メモリアクセス専用
- **0o**（8進数）：メインフレーム互換のための特殊型
- **0b**（2進数）：レジスタ直接操作型（例：`0b0000`は4bitCPUのレジスタリセット…つまりOSの記述用のような用途）
- **通常の数値**：FPU、SIMD等に最適委譲可能な数値型

これらの区別は、型宣言なしに低レベルハードウェア操作を安全かつ直感的に表現することを可能にします。

## 4. 比較演算の値返却特性

Sign言語の比較演算は、単なるブール値ではなく具体的な値を返すという特性を持ちます。

### 4.1 基本原則

- 比較条件が `true` と評価される場合、比較演算は **変数項の値** を返します
  - 通常は左辺の値（特に変数）が返されます
  - 左辺が定数リテラルの場合は右辺の変数値が返されます
  - 実質的に、比較に関わる「値として意味のある方」の変数を返します
- 比較条件が `false` と評価される場合、比較演算は **Unit (`_`)** を返します
- この仕組みにより、条件分岐をブール値変換なしに直接値として扱えます

### 4.2 多項式比較の評価順序と変数値の返却

比較演算を含む多項式は、左から右へ順次評価され、各比較の結果は次の比較の入力となります：

```
3 < x = y < 20
```

この式は以下と等価です：

```
[[3 < x & x] = y & y] < 20 & y
```

評価プロセス：
1. `3 < x` が `true` なら **変数 x の値** が返され、それが次の比較の左辺になります
2. `x = y` が `true` なら **変数 y の値** が返され、それが次の比較の左辺になります
3. `y < 20` が `true` なら最終的な結果は **変数 y の値** になります
4. いずれかの条件が `false` なら、その時点で `_` (Unit) が返され、短絡評価により以降は評価されません

### 4.3 実用例

この特性により、条件分岐が簡潔かつ表現力豊かに記述できます：

```sign
getValue : x ?
` x < 0 が true なら x 自身の値が返され、それが -x の計算に使われる
	x < 0 : -x
` x > 100 が true なら x 自身の値が返され、それが無視されて100が返される
	x > 100 : 100
` デフォルトは x 自身を返す
	x

inRange : x ?
` 0 <= x かつ x <= 100 なら x 自身を返す
	0 <= x <= 100 & x
` そうでなければ Unit (_) を返す
```

## 5. 型変換の左辺優先規則

Sign言語は二項演算において型が異なる場合、常に **左辺の型** に合わせて右辺を変換します。

### 5.1 基本原則

- 二項演算の左辺と右辺の型が異なる場合、右辺が左辺の型に変換されます
- 変換できない場合はコンパイルエラーとなります
- 型の一致は「見えない強い静的型付け」の一部として、コンパイル時に検証されます

### 5.2 型変換の例

```sign
` 結果: `123456` (文字列結合として評価)
`123` + 456

` 結果: 579 (数値加算として評価、"456"が数値456に変換)
123 + `456`
```

### 5.3 演算の理論的根拠

Sign言語の型システムは、違う型同士の演算になる場合は基本的に左辺の型を採用します。
これは、文字列内に数値を数字として連結したい場合の自然な型変換など、便利な機能を提供します。
なぜなら、2項演算の右辺は演算を動詞として考えたときに目的語として動詞に掛かるという考えがあるからです。

## 6. 識別子と型の関係

Sign言語の識別子は、従来の型システムとは異なる特性を持ちます。識別子の名前そのものが型の名前として機能し、柔軟な型表現を可能にします。
この設計により、明示的な型宣言なしに、識別子を通じて型情報を自然に表現できます。

## 7. 除算処理の安全設計

### 7.1 除算演算子の制約解除

Sign言語では除算処理において、従来の「ゼロ除算エラー」を回避する革新的なアプローチを採用しています：

- `a / b` 形式の除算演算では、結果はそのアーキテクチャで最良の精度を持つ浮動小数点型とする
- 分母が0である場合は、そのアーキテクチャ上で表現可能な最小値との割り算とする
- 微分可能空間での零元を根拠とし、物理的に真の真空が存在しない仮定による仕様である
- 大抵の場合は、上述はレジスタのオーバーフローとなるであろうことを予測している

### 7.2 安全性の哲学

プログラマーは直感的な数学表記を使いながらも、潜在的な実行時エラーから保護されます。

Sign言語の「Syntaxが型を担保する」哲学を拡張し、「構文が安全性も担保する」という強力な特性が実現できます。

## 8. 型安全性とハードウェア最適化

Sign言語の型システムは、安全性と効率性を両立させます：

コンパイル時型検証：強い静的型付けにより実行時エラーを防止
型情報を活用した最適化：コンパイラが型情報を使って適切な処理を選択

この設計により、プログラマーは型を意識することなく、安全で効率的なコードを記述できます。

## 9. 言語設計の革新的アプローチ

Sign言語は、従来の言語設計とは逆の道を歩んでいます：

- **従来の言語**：コンピュータ操作を抽象化し、複雑な安全機構を追加
- **Sign言語**：言語自体を抽象化し、コンピュータ操作を直感的に表現可能に

型システムもこの哲学を反映しており、「型を見せないことで単純さを実現しながら、背後では強力な型安全性を維持する」という革新的なアプローチを取っています。
