# Sign言語におけるUnit (`_`) 仕様

## 1. イントロダクション

Sign言語におけるUnit値 (`_`) は言語設計の中核をなす概念であり、数学的に一貫した特性を持ちます。本ドキュメントでは、Unitの理論的基盤から実装詳細まで包括的に解説します。

## 2. Unitの数学的基盤

### 2.1 基本性質

- **値としての性質**: `_ = []` (空リストと等価)
- **左単位元**: `_ X = X` (Unitを左から適用すると引数がそのまま返る)
- **関数単位元**: `F _ = F` (算術と論理の範疇ではUnitを引数として渡すと関数自体が返る)
- **二重性**: 値であると同時に関数でもある
- **論理評価**: `_` はfalseと評価される
- **アドレス**: `$_ = _` (Unitのアドレス値はUnitを指す)
- **Input**: `@_ = _` (吸収元の挙動)
- **Output**: `$_ # X` は /dev/null へのファイル移動のような挙動

### 2.2 圏論的背景

圏論において、Unitは恒等射と自然変換の役割を持ちます：

- **恒等射**: `_ : X → X` として機能
- **自然変換**: 関数合成における中立的な変換
- **部分適用の変換子**: Unit位置が順序変換を意味する

## 3. Unit演算の完全仕様

### 3.1 論理演算子とUnitの相互作用

論理演算子は短絡評価を基本とし、Unitとの相互作用は次のように定義されます：

#### 3.1.1 論理積 (`&`)

```
` Unitが左辺ならUnit(`_`)（短絡評価）
_ & X
`→ _

` Unitが右辺ならUnit(`_`)（右辺まで評価）
X & _
`→ _

` 左辺がtrueなら右辺の値を返す
true値 & X
`→ X
```

#### 3.1.2 論理和 (`|`)

```
` Unitが左辺なら右辺を評価
_ | X
`→ X

` 左辺がtrueなら左辺を返す（短絡評価）
X | _
`→ X

` 左辺がfalseなら右辺を評価
false値 | X
`→ X
```

#### 3.1.3 排他的論理和 (`;`)

```
` Unitとの排他的論理和は常に相手の値
_ ; X
`→ X

` Unitとの排他的論理和は常に相手の値
X ; _
`→ X
```

#### 3.1.4 否定 (`!`)

```
` Unit（false扱い）の否定は、Unit以外の値（true扱い）を返す
!_
```

### 3.2 算術・比較演算子とUnitの相互作用

Unit以外の演算子との相互作用では、部分適用されたラムダ式を返します：

#### 3.2.1 算術演算子 (`+`, `-`, `*`, `/`, `%`, `^`)

```
`「Unitが置き換わったら+Xする」というラムダを返す
_ + X
` →[y ? y + X]

`「Unitが置き換わったらX+する」というラムダを返す
X + _
` →[y ? X + y]

```

同様に：
```
_ - X
` → [y ? y - X]
X - _
` → [y ? X - y]
_ * X
` → [y ? y * X]
X * _
` → [y ? X * y]
_ / X
` → [y ? y / X]
X / _
` → [y ? X / y]
_ % X
` → [y ? y % X]
X % _
` → [y ? X % y]
_ ^ X
` → [y ? y ^ X]
X ^ _
` → [y ? X ^ y]
```

#### 3.2.2 比較演算子 (`<`, `<=`, `=`, `>=`, `>`, `!=`)

```
`「Unitが置き換わったら<Xと比較する」というラムダを返す
_ < X
` → [y ? y < X]  

`「Unitが置き換わったらX<と比較する」というラムダを返す
X < _
` → [y ? X < y]
```

同様に：
```
_ <= X
` → [y ? y <= X]
X <= _
` → [y ? X <= y]
_ = X
` → [y ? y = X]
X = _
` → [y ? X = y]
_ >= X
` → [y ? y >= X]
X >= _
` → [y ? X >= y]
_ > X
` → [y ? y > X]
X > _
` → [y ? X > y]
_ != X
` → [y ? y != X]
X != _
` → [y ? X != y]
```

### 3.3 関数適用とUnitの相互作用

```
` Unitは左単位元として挙動
_ X
` → X

` 関数にUnitを適用すると関数自体が返る
F _
` → F
```

## 4. ARM64上での最適実装

### 4.1 Unit値の表現

- **xZR専用使用**: xZRをUnit表現レジスタとして使用（常にゼロを保持）
- **呼び出し先保存**: 関数間で一貫性を維持

### 4.2 条件付き命令を活用した空スタック処理

```assembly
// 条件付き命令による効率的な空スタックPOP
cmp sp, xZR              // スタック境界チェック
csel x0, xZR, x0, eq     // 空ならUnit、そうでなければスタック値
cbnz sp, .pop_value      // 実際のPOP操作が必要な場合のみ分岐
.continue:
// 処理継続

.pop_value:
ldr x0, [sp], #8         // 実際のPOP操作
b .continue
```

### 4.3 Unit関数（空の関数ポインタ）の効率的処理

```assembly
// 条件付き命令による関数ポインタ処理
cmp x9, #0               // 関数ポインタがNULLか確認
csel x16, x30, x9, eq    // NULLならx30(リンクレジスタ)、そうでなければ関数ポインタ
blr x16                  // 条件付き呼び出し（NULLなら実質NOP）
```

### 4.4 部分適用と順序変換の実装

```assembly
// myFunc _ 4 のコンパイル結果（順序変換）
// 1. 固定引数のキャプチャ
mov w8, #4               // 固定引数(4)のロード
str w8, [x28]            // クロージャ環境に保存

// 2. 変換された関数の生成
adr x9, .Ltransformed    // 変換関数のアドレス
mov x0, x9               // 戻り値として関数ポインタを設定
ret

// 3. 変換された関数の実装
.Ltransformed:
ldr w1, [x28]            // 固定引数(4)の取得
mov w9, w0               // 新しく与えられた引数の保存
mov w0, w9               // 第一引数として設定（順序変換）
bl myFunc                // 元の関数呼び出し
ret
```

### 4.5 条件付き命令の最適化利点

1. **分岐予測ミスの回避**: パイプラインストールを防止
2. **命令数削減**: 実行パスがより効率的
3. **命令レベル並列性**: 他の命令と並列実行可能
4. **最新プロセッサでの効率**: 最新ARM64プロセッサで高いパフォーマンス

### 4.6 最適化パターン

- **条件付き選択（CSEL）**: Unit/値の選択に最適
- **条件付きインクリメント（CINC）**: カウンタ操作の最適化
- **条件付き保存（CSET）**: フラグベースの計算最適化
- **条件付きデータ処理（CCMP）**: 複合条件の効率的処理

## 5. 実用的な例と応用

### 5.1 Unitを用いた条件分岐

```sign
` xが正ならxを返し、そうでなければUnitを返す
isPositive : x ? x > 0

` 使用例
` 「負またはゼロ」が返る
result : isPositive -5 | `負またはゼロ`

` 10が返る
result : isPositive 10 | `負またはゼロ`
```

### 5.2 Unitを用いた部分適用

```sign
add : x y ? x + y
` yに何かが入るまで待機するラムダ
addSomething : add _

` 使用例
` 結果は「5を加える」関数
addFive : addSomething 5
` 結果は8
addFive 3
```

### 5.3 引数順序の変換

```sign
` 部分適用による順序変換の例
myFunc : x y z ? x * y + z

` _を第2引数位置に指定することで引数順序を変換
partialFunc : myFunc _ 4 7  `y=4, z=7を固定

` 呼び出し時: partialFunc 3 は myFunc 3 4 7 と等価
result : partialFunc 3  `結果は 3 * 4 + 7 = 19
```

## 6. 未評価ラムダの扱い

### 6.1 論理コンテキストでの評価

- 未実行のラムダ項はfalseとして評価
- それ以外のコンテキストでは通常のラムダとして扱われる

### 6.2 関数の存在確認

```sign
` アドレス演算子を使用した存在確認
$func & `存在します` | `存在しません`
```

### 6.3 型チェック

```sign
` 型チェックによる関数判定
"f" = "?" & `関数です` | `関数ではありません`
```

## 7. コンパイラの静的最適化戦略

1. **フロー解析**: スタック状態と関数ポインタ状態の静的追跡
2. **冗長チェック除去**: 状態が静的に判明している場合のチェック削除
3. **インライン化**: 小さな関数やUnit関数のインライン展開
4. **ループ最適化**: 再帰関数のループ変換
5. **レジスタ割り当て**: Unit専用レジスタと一般レジスタの効率的な管理

## 8. 設計原則

Sign言語のUnit演算設計は以下の原則に基づいています：

1. **一貫性**: Unitは「まだ値がない」または「無効な値」を表現する一貫した方法
2. **自然な短絡評価**: 論理演算では意味的に正しい短絡評価を提供
3. **部分適用の拡張**: 算術演算子や比較演算子でもラムダを返すことで部分適用のメカニズムを拡張
4. **エラー回避**: 実行時エラーを発生させるよりも、Unitやラムダを返すことで柔軟なプログラミングを可能に

## 9. 理論と実装の統合

Sign言語のUnit設計は深い数学的基盤と効率的な実装を見事に統合しています：

- **圏論的基盤**: Unit概念が恒等射と自然変換として機能
- **関数型パラダイム**: 部分適用と合成が自然に表現される
- **例外なしの設計**: すべての操作が数学的に一貫した結果を持つ
- **実行効率**: 理論的な美しさを保ちながら高効率なコード生成

Sign言語は、「見えない強い型付け」と「Unit」の概念を軸に、理論的な純粋さと実用的な効率性を両立させています。特にARM64アーキテクチャの条件付き命令を活用することで、Unit処理というSign言語の中核機能を最大限に効率化することができます。

この実装アプローチにより、Sign言語は理論的に美しいだけでなく、実際の計算環境で高効率に動作する言語として大きな可能性を秘めています。