# Sign言語におけるUnit (`_`) 仕様：双代数的基盤

## 1. イントロダクション

Sign言語におけるUnit値 (`_`) は言語設計の中核をなす概念であり、双代数の単位元として数学的に一貫した特性を持ちます。本ドキュメントでは、Unitの圏論的基盤から実装詳細まで包括的に解説します。

## 2. 双代数としての数学的基盤

### 2.1 基本性質

- **双代数の単位元**: リスト構造（余代数）と関数合成（代数）の両方の単位元
- **値としての性質**: `_ = []` (空リストと等価)
- **関数としての性質**: 恒等射として機能
- **論理評価**: `_` はfalseと評価される（付帯的性質）
- **重要な区別**: `_ ≠ 0`（数値ゼロとは明確に異なる）

### 2.2 双代数構造の定義

Sign言語のリスト構造は双代数 `(List, unit, join, extract, duplicate)` を形成します：

**代数構造（モナド）**:
- `unit : A → List A` where `unit(x) = [x]`
- `join : List(List A) → List A` where `join([[a₁, a₂], [b₁, b₂]]) = [a₁, a₂, b₁, b₂]`

**余代数構造（コモナド）**:
- `extract : List A → A` where `extract([x]) = x`, `extract([]) = _`
- `duplicate : List A → List(List A)` where `duplicate([a, b]) = [[a], [b]]`, `duplicate([]) = [[]]`

### 2.3 圏論的証明：`_`の双代数単位元性

**定理**: `_`は双代数 `(List, unit, join, extract, duplicate)` の単位元である

**証明**:

#### モナド単位元の証明
```
_ >>= f = f(_) = f([])     // left unit law
m >>= (\x → _) = _         // right unit law

具体例：
_ >>= [+ 2] = [+ 2](_) = [+ 2]
[1,2,3] >>= (\x → _) = _
```

#### コモナド単位元の証明
```
extract(_) = extract([]) = _           // extraction law
duplicate(_) = duplicate([]) = [[]] = [_]   // duplication law
```

#### 双代数互換条件の検証
```
extract ∘ unit = id:
extract(unit(_)) = extract([_]) = _ = id(_) ✓

duplicate ∘ unit = unit ∘ unit:
duplicate(unit(_)) = duplicate([_]) = [[_]]
unit(unit(_)) = unit([_]) = [[_]] ✓
```

## 3. Unit演算の完全仕様

### 3.1 関数文脈での演算

#### 3.1.1 算術演算子との相互作用
```
`関数の単位元として部分適用を生成
_ + X → [+ X]
X + _ → [X +]

`同様に他の演算子も
_ - X → [- X]    X - _ → [X -]
_ * X → [* X]    X * _ → [X *]
_ / X → [/ X]    X / _ → [X /]
_ % X → [% X]    X % _ → [X %]
_ ^ X → [^ X]    X ^ _ → [X ^]
```

#### 3.1.2 比較演算子との相互作用
```
`関数の単位元として比較関数を生成
_ < X → [< X]    X < _ → [X <]
_ <= X → [<= X]  X <= _ → [X <=]
_ = X → [= X]    X = _ → [X =]
_ >= X → [>= X]  X >= _ → [X >=]
_ > X → [> X]    X > _ → [X >]
_ != X → [!= X]  X != _ → [X !=]
```

#### 3.1.3 関数適用
```
`恒等射として機能
_ X → [X]

`関数に適用すると恒等射
F _ → F
```

### 3.2 リスト文脈での演算

#### 3.2.1 リスト結合
```
`空リストとしての単位元
_ [X] → [X]
[X] _ → [X]

`明示的なリスト同士の算術演算は型エラー
[_] + [X] → TypeError
[A] * [B] → TypeError
```

#### 3.2.2 リスト操作
```
`空リストのmapは空リスト
map f _ → _

`空リストのfoldは初期値
fold f init _ → init
```

### 3.3 論理文脈での演算

論理演算では付帯的に`false`として機能：

#### 3.3.1 論理積 (`&`)
```
_ & X → _    `短絡評価
X & _ → _    `右辺まで評価
```

#### 3.3.2 論理和 (`|`)
```
_ | X → X    `左辺がfalseなので右辺を評価
X | _ → X    `左辺がtrueなら短絡評価
```

#### 3.3.3 排他的論理和 (`;`)
```
_ ; X → X
X ; _ → X
```

#### 3.3.4 否定 (`!`)
```
!_ → true相当
```

### 3.4 アドレス・入出力演算

```
`Unit自身への参照
$_ → _

`Unitからの入力は吸収
@_ → _

`Unitへの出力は無効化（/dev/null相当）
_ # X → _
```

## 4. 双代数の分配法則

Sign言語の演算子関数化は双代数の分配法則として表現されます：

```
`分配法則: (f ⊗ g)(unit(x)) = unit(f(x)) ⊗ unit(g(x))
(+ ⊗ *)(unit(x)) = unit(+(x)) ⊗ unit(*(x))

具体例:
_ + 3 → [+ 3]    `unit(+(3))を生成
_ * 5 → [* 5]    `unit(*(5))を生成
```

この分配法則により、演算子の自然な関数化と部分適用が双代数の構造から導かれます。

## 5. ARM64上での最適実装

### 5.1 Unit値の表現

- **NULL pointer使用**: Unit値をNULLポインタとして表現
- **条件付き命令活用**: AArch64の条件付き命令でUnit判定を効率化
- **レジスタ最適化**: xZRレジスタの特性を活用

### 5.2 双代数演算の最適化

```assembly
// _ + X の実装例
cmp x0, #0               // Unit判定
b.eq .generate_partial   // Unitなら部分適用生成
// 通常の加算処理

.generate_partial:
adr x1, .add_closure     // [+ X]クロージャのアドレス
mov x0, x1               // 関数ポインタを返す
ret
```

### 5.3 条件付き命令による効率化

```assembly
// Unit判定と処理の統合
cmp x0, #0               // Unit判定
csel x1, xZR, x0, eq     // UnitならxZR、そうでなければx0
cbnz x1, .normal_process // 通常処理
// Unit専用処理
```

## 6. 実用的な例と応用

### 6.1 双代数性を活用した関数合成

```sign
`map操作の双代数的表現
map_double : [* 2,]
result : map_double [1, 2, 3, 4]  `→ [2, 4, 6, 8]

`部分適用の連鎖

`関数合成
add_then_multiply : [+] [* 2]

result : add_then_multiply 3 5  `→ (5 + 3) * 2 = 16
```

### 6.2 Unitを用いた条件分岐

```sign
`Unitの論理的性質を活用
safe_divide : x y ?
    y = 0 & _ | [x / y]

result : safe_divide 10 0   `→ _ (Unit)
result : safe_divide 10 2   `→ [5] (結果のリスト)
```

### 6.3 双代数の自然変換

```sign
`自然変換としてのUnit
natural_transform : f list ?
    f _ ` list  `空の場合の処理
    f list      `通常の処理

example : natural_transform [* 2,] 1, 2, 3
```

## 7. 設計原則と理論的意義

### 7.1 双代数単位元としての一貫性

1. **代数的一貫性**: モナド法則を満たす関数合成の単位元
2. **余代数的一貫性**: コモナド法則を満たすリスト構造の単位元
3. **双代数互換性**: 代数と余代数の相互作用を保持
4. **自然変換性**: 関数とリストの間の自然な変換を提供

### 7.2 実装効率との統合

- **理論的純粋性**: 深い数学的基盤に基づく設計
- **実装効率**: ARM64での高効率な機械語生成
- **型安全性**: コンパイル時の双代数構造検証
- **最適化可能性**: 双代数の性質を活用した自動最適化

## 8. 結論

Sign言語のUnit (`_`) は、単なる「便利な記号」ではなく、双代数の単位元として深い数学的構造を持つ言語の基盤要素です。モナドとコモナドの両方の単位元として機能することで、関数型プログラミングとリスト処理の統一的な表現を可能にし、「見えない強い型付け」と「ゼロコスト抽象化」の理論的基盤を提供しています。

この双代数的設計により、Sign言語は理論的に美しく、実装効率的に優れ、プログラマにとって直感的な言語として実現されています。