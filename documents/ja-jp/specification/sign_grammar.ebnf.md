# Sign言語 EBNF文法 (proto/a7)

> [!NOTE]
> この文法は `proto/a7` で実装されているSign言語を記述しています。
> 字句構造、式文法、演算子の優先順位を扱います。

---

## 1. 字句文法

```ebnf
(* === 文字クラス === *)
letter        = "a" | ... | "z" | "A" | ... | "Z" ;
digit         = "0" | "1" | ... | "9" ;
word_char     = letter | digit | "_" ;
symbol_char   = "!" | "#" | "$" | "%" | "&" | "'" | "*" | "+" | ","
              | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?"
              | "@" | "^" | "|" | "~" | "\" ;

(* === トークン === *)
integer       = [ "-" ] digit { digit } ;
float         = [ "-" ] digit { digit } "." digit { digit } ;
number        = float | integer ;

identifier    = ( letter | "_" ) { word_char } ;
              (* 注: 単独の "_" は変数ではなくUnitとして解析される *)

string        = "`" { any_char - newline } "`" ;

char_literal  = "\" any_char ;              (* 例: \M \n \t *)

comment       = "`" { any_char - newline } newline ;
              (* ` で始まる行はコメント *)

unit          = "_" ;

(* === 空白と構造 === *)
newline       = "\n" | "\r\n" | "\r" ;
indent        = "\t" ;
separator     = newline ;
```

---

## 2. 演算子表

演算子を**優先順位**順に並べたもの（低い＝結合が緩い → 高い＝結合が強い）。

| 優先順位 | 記号 | 位置 | 機能 | 意味論 |
|---------|------|------|------|--------|
| 1 | `#` `##` `###` | 前置 | 出力 | 名前の発見可能性を設定（スコープレベル） |
| 2 | `:` | 中置右 | 定義 | 名前／条件を値に束縛 |
| 3 | `#` | 中置 | 出力 | データをアドレスに関連付け |
| 4 | ` ` | 中置 | **適用** | 余積：関数適用 |
| 5 | `?` | 中置右 | ラムダ | 関数定義 |
| 6 | `,` | 中置右 | 積 | 右結合リスト構築 |
| 7 | ` ` | 中置 | **合成** | 余積：関数合成 |
| 8 | ` ` | 中置 | **追加/結合** | 余積：リスト追加 / 連結 |
| 9 | `~` `~+` `~-` `~*` `~/` `~^` | 中置 | 範囲 | 範囲 / 数列の構築 |
| 10 | `~` | 前置 | 連続 | 連続リスト構築 |
| 11 | `;` | 中置 | 排他的論理和 | 排他的論理OR |
| 11 | `\|` | 中置 | 論理和 | 論理OR（短絡評価） |
| 12 | `&` | 中置 | 論理積 | 論理AND（短絡評価） |
| 13 | `!` | 前置 | 否定 | 論理否定 |
| 14 | `<` `<=` `=` `==` `>=` `>` `!=` | 中置 | 比較 | 比較（連鎖可能） |
| 15 | `+` `-` | 中置 | 加減算 | 算術加算/減算 |
| 16 | `*` `/` `%` | 中置 | 乗除余 | 算術乗算/除算/剰余 |
| 17 | `^` | 中置右 | 累乗 | 冪乗 |
| 18 | `!` | 後置 | 階乗 | 階乗 |
| 19 | `\|…\|` | 囲み | 絶対値 | 絶対値 |
| 20 | `~` | 後置 | 展開 | 展開 / 実行 |
| 21 | `$` | 前置 | アドレス | アドレス取得 |
| 22 | `'` | 中置 | 取得 | 構造体から値を取得（左） |
| 22 | `@` | 中置右 | 取得 | 構造体から値を取得（右） |
| 23 | `@` | 前置 | 入力 | アドレスからデータを読み出し |
| 24 | `<<` `>>` | 中置 | シフト | ビットシフト |
| 25 | `\|\|` | 中置 | ビットOR | ビット論理和 |
| 26 | `;;` | 中置 | ビットXOR | ビット排他的論理和 |
| 27 | `&&` | 中置 | ビットAND | ビット論理積 |
| 28 | `!!` | 前置 | ビットNOT | ビット否定 |
| 29 | `@` | 後置 | インポート | ファイルから取得 |
| 30 | `(…)` `{…}` `[…]` | 囲み | ブロック | インラインブロック |
| 30 | `\t` | 前置 | インデント | インデントブロック |
| 31 | `\` | 前置 | エスケープ | 次の文字を文字リテラルとして扱う |

---

## 3. 余積境界（空白の多重化）

Signにおいて、**空白（スペース）はそれ自体が演算子** — **余積演算子**として機能します。
トークン間のすべての空白は余積境界として機能し、その意味はオペランドの型に基づいて
意味解析時に決定される**多重化**されたものです：

```
余積演算子（SPACE）の4つの意味：

  1. 関数適用         func arg       add 5 3
  2. 関数合成         [f] [g] x      [+1] [*2] 5
  3. リスト追加/結合   list1 list2    [1,2] [3,4]
  4. 一般余積         expr1 expr2    x y z

構文的には、これらはすべて並置として同一に解析されます。
区別は意味解析の段階で、オペランドの型（関数、リスト、または値）
に基づいて行われます。
```

---

## 4. 演算子の空白規則

```
空白が演算子の表記法（前置 / 中置 / 後置）を決定します：

  中置:   SPACE op SPACE     x + y     a | b     n ~ m
  前置:   SPACE op·operand   !x        ~expr     $var
  後置:   operand·op SPACE   n!        expr~     file@

  (· = 空白なし、オペランドに直接付着)

これにより、パーサーは複数の表記法に出現する演算子を曖昧性なく
判定します：
  !   → 前置（NOT） vs  後置（階乗）
  ~   → 前置（連続） vs  中置（範囲）  vs  後置（展開）
  @   → 前置（参照解決） vs 中置（アクセス） vs  後置（インポート）

注: SPACE自体が余積演算子（§3）であるため、空白は
トークン区切りと余積中置演算子の二重の役割を果たします。
```

---

## 5. 式文法 (EBNF)

```ebnf
(* === トップレベル === *)
program        = block ;

(* === ブロック（インデントベース） === *)
block          = { line separator } ;
line           = expr ;

(* === 式（Prattパーサー — 優先順位上昇法） === *)
(*
   expr(minPrec) はアトムを解析し、以下を繰り返します：
   1. prec >= minPrec の後置演算子 (op·SPACE) を確認
   2. prec >= minPrec の中置演算子 (SPACE·op·SPACE) を確認
   3. それ以外の場合、prec 4 の並置 (SPACE·atom) を確認
   有効な継続が見つからなければ停止。
*)

expr           = atom { postfix_tail | infix_tail | apply_tail } ;

postfix_tail   = postfix_op ;
infix_tail     = infix_op expr ;
apply_tail     = atom ;                        (* 並置、prec 4 *)

(* === 演算子トークン集合 === *)

prefix_op      = "#" | "##" | "###"            (* IOチャネル *)
               | "!" | "!!"                    (* 論理NOT / ビットNOT *)
               | "$"                           (* アドレス取得 *)
               | "@"                           (* 参照解決 / 読み出し *)
               | "~"                           (* 連続 *)
               | "\"                           (* エスケープ / 文字リテラル *)
               ;

infix_op       = ":"                           (* 定義 / 条件 *)
               | "#"                           (* IO書き込み / ストア *)
               | "?"                           (* ラムダ *)
               | ","                           (* ペア / cons *)
               | "~"                           (* 範囲 *)
               | "~+" | "~-" | "~*" | "~/" | "~^"
               | ";"                           (* 選択 / XOR *)
               | "|"                           (* 論理OR *)
               | "&"                           (* 論理AND *)
               | "<" | "<=" | "=" | "==" | ">=" | ">" | "!="
               | "+" | "-"                     (* 加法 *)
               | "*" | "/" | "%"               (* 乗法 *)
               | "^"                           (* 累乗 *)
               | "'"                           (* アクセス / nth *)
               | "@"                           (* 逆アクセス *)
               | "<<" | ">>"                   (* ビットシフト *)
               | "||"                          (* ビットOR *)
               | ";;"                          (* ビットXOR *)
               | "&&"                          (* ビットAND *)
               ;

postfix_op     = "!"                           (* 階乗 *)
               | "~"                           (* 展開 / 実行 *)
               | "@"                           (* インポート *)
               ;

(* === アトム === *)
atom           = number
               | string
               | char_literal
               | identifier
               | unit
               | abs_expr
               | bracket_expr
               | prefix_expr
               ;

prefix_expr    = prefix_op expr ;

(* === 絶対値 === *)
abs_expr       = "|" expr "|" ;

(* === ブラケット式 === *)
bracket_expr   = "[" block_content "]"
               | "(" block_content ")"         (* lexerが [ ] に正規化 *)
               ;

block_content  = section | block ;

(* === 演算子セクション === *)
section        = full_section
               | right_section
               | left_section
               ;

full_section   = infix_op ;                    (* [+]   → λx.λy. x + y *)
right_section  = infix_op expr ;               (* [+ 1] → λx. x + 1    *)
left_section   = expr infix_op ;               (* [1 +] → λx. 1 + x    *)
```

---

## 6. 中置演算子による構文形式

これらは独立した文法規則ではなく、Prattパーサーが処理する中置演算子の
特定の用法です。明確にするためここに列挙します。

```
定義:         name : value              (:  prec 2, 右結合)
関数定義:     name : params ? body      (: + ? の組み合わせ)
条件:         guard : consequent        (:  prec 2, 右結合)
ラムダ:       params ? body             (?  prec 5, 右結合)
ペア:         head , tail               (,  prec 6, 右結合)
適用:         func arg                  (並置, prec 4, 左結合)

引数:         x                         単一引数
              x , y , z                 "," による複数引数

本体:         単一式                     同じ行に記述
              インデントブロック          次行以降、より深いインデントで記述
```

---

## 7. ブロック意味論（複数式）

```
ブロックが改行で区切られた複数の式を含む場合、
短絡ORとして動作します（最初の非Unit値が勝ちます）：

  expr1          -- expr1 ≠ Unit → expr1を返す
  expr2          -- そうでなければ expr2 を評価
  ...            -- そうでなければ最後の式を評価
```

---

## 8. インデント規則

```
1. 行頭のTAB文字がインデントレベルを決定する。
2. インデントの増加 → 新しいネストブロックを開始。
3. インデントの減少 → 現在のブロックを閉じる。
4. 開いた演算子 (? : =) で終わる行は改行セパレータを抑制し、
   続くインデントブロックがその演算子の右辺として
   解析されることを可能にする。
5. ブラケット [ ]、括弧 ( )、波括弧 { } は
   インラインネストブロックを作成する。( ) と { } は [ ] に正規化される。
```

---

## 9. 合成規則

```
適用 (f x) には2つの実行時動作があります：
  - x がデータの場合  → f(x) を呼び出す
  - x が関数の場合    → 合成: h(y) = x(f(y))

演算子セクションも合成をサポートします：
  [+] f     → compose(section, f)
  [+] 3     → セクションを3に適用  (つまり λy. 3 + y)
```

---

## 10. 真偽モデル

```
偽  =  _ (Unit)       番兵値
真  =  Unit以外の値    (0, -1 等を含む)

guard : body       guard ≠ Unit の場合のみ body を評価
!x                 → 真なら Unit、偽なら 0
a & b              → a が真なら b、そうでなければ Unit
a | b              → a が真なら a、そうでなければ b
a ; b              → ちょうど一方が真 → その値、そうでなければ Unit
a < b              → 真なら → 値、そうでなければ Unit
```

---

## 11. プログラム例

```sign
` 階乗（再帰）
fact : n ?
	n < 2 : 1
	n * [fact n - 1]

1 # fact 5
```

```sign
` セクションによる合成
1 # [+ 1] [* 2] 3      ` → 8  (3 → +1 → 4 → *2 → 8)
```

```sign
` ラムダと直接呼び出し
inc : n ? n + 1
1 # inc 20
```

```sign
` 絶対値
1 # |-5|
1 # |1 - 2| * 3
```

```sign
` 論理演算子
1 # _ | 1               ` → 1
1 # 0 & 1               ` → 1  (0 は真)
```
