# System Semantics (Sign言語 システム記述仕様)

## 概要
Sign言語は「高水準な関数型記述（アプリケーション層）」と「低水準なプリミティブ操作（システム層）」を同一の構文でサポートします。
本ドキュメントでは、特にシステム層（コンパイラ、アロケータ、ドライバ等）の実装において使用される**明示的なメモリ操作**について定義します。

## アプリケーション層とシステム層の違い

### アプリケーション層 (ユーザーコード)
*   **メモリ管理**: 自動（コンパイラ/GCが隠蔽）。`alloc` などの直接呼び出しは行わない。
*   **値の扱い**: 参照渡し・値渡しはコンテキスト（関数適用）によって自動的に最適化される。
*   **禁止事項**: ポインタ演算、直接的なメモリアドレス操作。

### システム層 (関数ブロック内部)
*   **メモリ管理**: 明示的。`alloc` 相当のロジックを構成可能。
*   **明示的な参照操作**: `$` (Address Of), `@` (Deref), `#` (Store) を使用して、物理的なメモリ配置やポインタの受け渡しを制御する。

## 明示的な参照操作 (Explicit References)

システム記述（特にアロケータや高効率なライブラリ機能の実装）において、値(Value)と参照(Reference/Address)を区別するために以下の演算子を使用します。

### 1. `$` Reference (Address Of)
変数の「値」ではなく「場所（アドレス）」を取得します。
主に関数へ「参照渡し」を行いたい場合や、変数のスロットそのものを操作したい場合に使用します。

```sign
map $[* 2] ...  ` 関数オブジェクトを値コピーせず、参照として渡す
$heap_ptr # ... ` heap_ptr変数そのもの（スロット）に書き込む
```

### 2. `@` Dereference (Load)
参照（アドレス）から実体（値）を取り出します。
参照渡しされた引数を利用する際に使用します。

```sign
map : f ... ?
    @f ...      ` 参照 f から関数実体を取り出して適用
```

### 3. `#` Store (Update)
参照先（アドレス）に値を書き込みます。
変数の更新（再代入）や、ヒープメモリへの書き込みに使用します。
左辺は必ずアドレス（L-Value）でなければなりません。

```sign
$heap_ptr # next ` heap_ptr変数のアドレス($)を取得し、そこに next を書き込む
```

## コンパイラの挙動 (Proto A5)

*   **識別子 (Identifier)**: 常に **R-Value (Value)** として評価されます。
    *   `x` -> `ldr x0, [x_addr]`
*   **代入文脈 (# の左辺)**: 特別扱いはしません。左辺はアドレスとして評価される式でなければなりません。
    *   `$x # y` -> `adr x0, x_addr; ... str y, [x0]`
    *   `x # y` -> `x`の値（ポインタとして解釈）の指す先へ書き込み（`*x = y`）
*   **明示的な操作**: `$` や `@` を全面的に使用し、マジック（暗黙の型変換）を排除します。
