# Sign WASM版 フェーズ1 実装計画 (制御構文と論理演算)

この計画では、Sign言語のWebAssembly（`WAT`）コンパイラにおける真偽値、論理演算、および制御構文の実装について説明します。

## 目標
Sign言語では、真偽値、論理演算、および分岐を処理するための統一された方法が必要です。AArch64 (`a9`) の実装では、`sign_id`（ポインタ）が `Unit`（Falsy = 偽）の値として機能し、`0`やその他の数値/ポインタは `Truthy`（真）として扱われていました。
現在のWASM実装は `f64`（64ビット浮動小数点数）のみで動作するため、WebAssemblyの `NaN`（Not a Number、非数）を使用して `Unit` / `False` を表現します。有効な Wasm 側の `f64` 数値（`0.0`を含む）はすべて `Truthy`（真）と見なされます。

## 実装内容

1.  **WASM の真偽値判定ヘルパー ($is_truthy)**
    -   Wasm内に `$is_truthy` 関数を追加し、スタックの値が `NaN` かどうかを判定して `Truthy` なら `1` (i32)、`Falsy (NaN)` なら `0` (i32) を返すようにします。

2.  **比較演算子 (`==`, `!=`, `<`, `>`, `<=`, `>=`)**
    -   比較結果の真偽をWASMネイティブの命令 (`f64.eq` など)で行い、結果に応じて `1.0` (True) または `NaN` (False) を返すようにスタックマシンの処理をコンパイルします。

3.  **論理演算子とビット演算子の分離**
    -   **論理演算子 (`&`, `|`, `;`)**:
        -   `&` と `|` はWASMの `if / else / end` ブロックを使用して**短絡評価**（Short-circuit evaluation）を行います。右辺が不要な場合は評価されません。
        -   `;`（XOR）は、仕様書に従い**短絡評価されず**、必ず両辺を評価した上で真理値判定を行います。「どちらか一方のみ」が 真 (Truthy) の場合にその値を返します。両方とも 真 または 偽(Unit) なら `NaN` を返します。
    -   **ビット演算子 (`&&`, `||`, `;;`, `!!`, `<<`, `>>`)**: これらはオペランドを双方とも評価した上で、WASMの `i32` 空間へとキャストし、`i32.and`, `i32.or`, `i32.xor`, `i32.shl`, `i32.shr_s` を用いて演算を行います。結果は `f64` としてスタックに戻されます。

4.  **条件分岐 (`:`) と関数定義 (`?`)**
    -   **`:` (定義 / 条件分岐)**: Signでは `Condition : TrueBranch` のように条件式としても機能します。条件式の結果を `$is_truthy` で評価し、`True` なら右辺を実行し、`False` なら `NaN (Unit)` を返す `if/else` ブロックを生成します。
    -   **`?` (ラムダ定義)**: フェーズ1の範囲外であるため、現時点では `UNIMPLEMENTED` を出力するようにします（フェーズ3で本格実装予定）。

## テスト方法 (ブラウザ実行による検証)
以下のようなSignコードをコンパイルし、出力を確認して動作検証を行います。

` --- 比較演算 ---
1 # (5 == 5)            ` 期待値: 5
1 # (1 != 2)            ` 期待値: 2
1 # (1 < 2)             ` 期待値: 2
1 # (2 > 1)             ` 期待値: 1
1 # (1 <= 1)            ` 期待値: 1
1 # (2 >= 2)            ` 期待値: 2

` --- 論理演算 (0, 1 は Truthy, _ は Falsy) ---
1 # (_ & 0)             ` 期待値: NaN (左辺Falsyのため_)
1 # (0 & _)             ` 期待値: NaN (右辺の_)
1 # (0 & 1)             ` 期待値: 1   (右辺の1)
1 # (_ | 0)             ` 期待値: 0   (右辺の0)
1 # (0 | _)             ` 期待値: 0   (左辺の0)
1 # (0 | 1)             ` 期待値: 0   (左辺の0)
1 # (_ ; 0)             ` 期待値: 0   (右辺のみTruthy)
1 # (1 ; _)             ` 期待値: 1   (左辺のみTruthy)
1 # (0 ; 1)             ` 期待値: NaN (両方Truthyのため_)
1 # (_ ; _)             ` 期待値: NaN (両方Falsyのため_)

` --- ビット演算 ---
1 # (1 && 42)           ` 期待値: 0 (i32の1 AND 42)
1 # (0 || 99)           ` 期待値: 99 (i32の0 OR 99)
1 # (1 ;; 1)            ` 期待値: 0 (i32の1 XOR 1)
1 # (1 ;; 0)            ` 期待値: 1 (i32の1 XOR 0)
1 # (1 << 2)            ` 期待値: 4
1 # (4 >> 1)            ` 期待値: 2
1 # (!!0)               ` 期待値: -1 (0xFFFFFFFF)

` --- その他制御・単項演算 ---
1 # (!1)                ` 期待値: NaN
1 # (!(1 == 2))         ` 期待値: 1
1 # ((1 == 1) : 100)    ` 期待値: 100
1 # ((1 == 2) : 200)    ` 期待値: NaN
1 # (x ? x + 1)         ` 期待値: NaN (未実装)