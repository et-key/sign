# 実装計画: WASM フェーズ 2 (メモリ管理とデータ型)

本計画では、Sign言語のWebAssembly（`WAT`）コンパイラに向けたメモリ管理および複合データ型（リスト、文字列）の実装について説明します。

## 目標
フェーズ1では、`f64`値を用いた制御フローと論理演算を実装し、`NaN`を`Unit`（偽）として扱い、それ以外の`f64`をTruthy（真）としました。
リストや文字列を同じ`f64`スタック構造のままサポートするため、**NaN-boxing**（NANボクシング）を実装します。これにより、複数のWebAssemblyの型（値型）を必要とせずに、ポインタ（メモリアドレス）を浮動小数点数と同様にスタック経由で安全に渡すことができます。

## 提案する変更

### 1. WASM Linear Memory（線形メモリ）とBump Allocator
- Wasmの `(memory 1)`（初期サイズ64 KiB）をヒープとして要求します。
- Bump allocatorとして機能するグローバルの可変変数 `(global $heap_alloc_ptr (mut i32) (i32.const 8))` を定義します。アドレス `0` はヌルポインタ参照を検知・回避するために予約されます。
- 現在の `$heap_alloc_ptr` を返し、指定された `$size` 分だけポインタを進めるヘルパー関数 `(func $alloc (param $size i32) (result i32))` を実装します。

### 2. NaN-Boxing スキーム
`i64.reinterpret_f64` を使用して `f64` のビット単位のパターンを検査します。
- **通常の数値**: 標準的な `f64` ビットパターン
- **Unit (Falsy)**: `0x7FF8000000000000` (標準的な Quiet NaN)
- **リストのポインタ**: `0x7FFC000000000000 | ptr`
- **文字列のポインタ**: `0x7FFD000000000000 | ptr`

*備考: WASM32のポインタは32ビット（`i32`）であるため、NaNペイロードの下位32ビットに完全に収まります。*

### 3. 論理とTruthy判定の更新
- **`$is_truthy`**: 値が完全に `Unit` のNaNパターンと一致するかどうかを判定するように更新します。`Unit`であれば `0`（偽）を返し、それ以外は `1`（真）を返します。これにより、ポインタ（リスト/文字列）は正しくTruthyとして評価されるようになります！
- **等価演算 (`==`)**: `compileInfix` の `==` 処理を更新し、参照（ID）でのポインタ比較が正常に行われるように、`i64` のビット表現同士で比較するようにします。

### 4. リスト（Consセル）の実装
- **`$cons`** 関数:
  - 16バイト（`car`用に8バイト、`cdr`用に8バイト）を確保します。
  - 2つの `f64` 引数をメモリに格納します。
  - メモリアドレスをリストタグ（`0x7FFC...`）とビットORし、`f64`として返します。
- **`$head`** および **`$tail`** 関数:
  - 引数がリストタグを持っているかチェックします。
  - 持っている場合は `i32` ポインタを取り出し、1番目または2番目の8バイトスロットから `f64.load` します。
  - 持っていない場合は `Unit` を返します。
- パーサーの `,`（Cons演算子）および `~`（Spread演算子）をこれらのWasm関数に繋ぎ込みます。

### 5. 文字列の実装
- **文字列リテラル**: コンパイル時に文字列リテラル用のデータセクション `(data (i32.const offset) "...")` を出力します。
- 文字列オブジェクトは単なる文字列タグ（`0x7FFD...`）付きのポインタになります。
- **`#` (Print)**: 値が文字列タグを持っているかチェックするように出力処理を更新します。持っている場合は、ポインタと長さを指定してJSヘルパーの `$print_string` を呼び出します。

*（注意: `a9` では辞書を第一級のクロージャ/関数として実装した（関数ポインタや環境が必要）ため、辞書についてはフェーズ3まで延期します。）*

## 検証計画

### 自動化・ブラウザテスト
1. **リストの作成**: `[1, 2, 3]` -> スタックを壊さずに安全に評価されること。
2. **リストのアクセス**: `head [10, 20]` -> `10` を返すこと。`tail [10, 20]` -> `[20]` を返すこと。
3. **文字列**: \`\` \`Hello World\` \`\` -> メモリに正しく配置されること。
4. **文字列の出力**: \`\` 1 # \`Test\` \`\` -> `NaN` 浮動小数点数を出力するのではなく、コンソールに文字列 "Test" を出力すること。
5. **Truthy判定**: `1 # ( [1,2] ? 100 : 200 )` -> リストポインタはTruthyであるため、`100` を出力すること。

## テスト方法 (ブラウザ実行による検証)
以下のようなSignコードをコンパイルし、出力を確認して動作検証を行います。

### テスト1: 文字列（Strings）の割り当てと出力
UTF-8対応の文字列メモリ確保と、print_stringによる出力のテストです。

```sign
1 # `Hello! WASM Strings!`
```
期待される結果: [Print] Hello! WASM Strings!

### テスト2: リスト作成と結合 (cons と ,)
コンスセル（リスト）のメモリ確保のテストです。

 ```sign
list : 100, 200
1 # list
```
期待される結果: [Print] NaN （※ list はポインタ値となります。f64のNaNペイロードであるため、そのままPrintするとJS側には NaN として見えます！）

### テスト3: リスト要素の抽出 (head, tail)
メモリ上のリストポインタから実データを読み出すテストです。

```sign
list : 100, 200
1 # head list
1 # tail list
```
期待される結果: [Print] 100 と [Print] 200 が連続で出力される。

### テスト4: ブロックの短絡評価 ([...])
先ほどのスタックオーバーフロー対策のテストです。

```sign
1 # [ _ 42 99 ]
```
期待される結果: [Print] 42 （Signでは [ ... ] は短絡評価のように働き、最初の Truthy な値である 42 が評価され、それ以降はスタックがクリーンに保たれます）

