# 実装計画: WASM フェーズ 3.5 (フェイルファストとUnit評価)

## 目標
Sign言語のコンパイラ（WASM生成部）において、構文エラーやオペランドの欠落（例: `1 + ` や `* 5`）が発生した場合に、コンパイラをクラッシュさせたり無効なWATを出力してWASMインスタンス化を失敗させたりするのではなく、**「不正なノードの評価結果を強制的に Unit (NaN) としてWASMスタックに積み、実行を安全に継続させる（フェイルファスト）」**という強固なデバッグ基盤を構築します。

## 背景と課題
WASMにおけるスタックマシンアーキテクチャでは、各種命令（例: `f64.add`, `f64.mul`）は実行時にスタックから決められた数の引数（オペランド）を消費します。
以前の実装では、AST上で片方のオペランドが欠落している（`undefined` や `null` になっている）場合、コンパイラは「何もWASM命令を出力せずにスキップする」という挙動をしていました。
その結果、実行時にスタックの引数が足りなくなり、`type mismatch in f64.add, expected [f64, f64] but got [f64]` のようなWASMレベルでの致命的なバリデーションエラーを引き起こしていました。

## 実装された仕様と変更点 (`compiler_wat.js`)

### 1. 欠落ノードに対する完全なスタック保証
- `compileNode(node)` 関数の先頭において、引数 `node` が `null` や `undefined` などの欠落状態であった場合、単なる空文字 `''` を返すのではなく、**必ず `Unit`（Signにおける非数 `NaN`）を1つスタックに積む命令 (`f64.const nan`)** を出力してリターンするように修正しました。
- この「常に1つの値をスタックに積む」ルールの徹底により、スタックアンダーフローの発生を根本から防ぎます。

### 2. 演算子評価時のガード処理（`if (node.left)` 等）の撤廃
- 各種演算子（中置演算子、前置演算子など）の評価ロジック内に散在していた「対象ノードが存在する場合のみコンパイル（スタック積載）を行う」という条件分岐（ガード）をすべて削除しました。
- 欠落ノードに対しても前項1のルールが適用され自動的に `NaN` が積まれるため、欠落の有無に関わらず、演算子が必要とする数のオペランドがスタックに確実に準備されるようになりました。

### 3. 不完全な関数適用・演算子評価のフェイルファスト化
単独の演算子や引数が足りない状態で関数の適用が行われた際のスタック破壊を防止するため、以下の対応を行いました。

- **引数不足のネイティブ演算子適用（例: `* 5`）:**
  - `apply` ノードがネイティブ演算子（`+`, `*`, 等）を呼び出す際、その演算子が必要とする引数の数（arity）と、実際に提供された引数の数を比較します。
  - 不足している引数がある場合、演算子の命令（`f64.mul` 等）を出力する前に、**不足分だけ事前に `Unit` (`f64.const nan`) をスタックに自動パディング（補充）**します。
  - これにより、`* 5` は `NaN` -> `5.0` -> `f64.mul` として正しくWASM化されます。

- **単体の演算子評価（例: `[ 10 + - * ]` における演算子の孤立）:**
  - パース結果のAST構造上、値が期待される場所（識別子としての評価時）にネイティブ演算子が出現した場合、意図しないスタック消費を防ぐため、WASMの演算命令は出力せず **「未バインドのネイティブ関数」として扱い、代わりに `Unit` (`f64.const nan`) を1つだけプッシュ**します。

## 検証結果

以下の意図的な構文エラー（欠落コード）を含むテストにおいて、WASMのバリデーションエラーやクラッシュが発生せず、正常にスタック整合性が保たれて `NaN`（Unit）が出力されることを確認しました。

1. **テスト1：二項演算子の右辺欠落**
```sign
` 右辺が欠落した足し算
bad_calc : 10 + 
bad_calc	` 期待値: Unit (NaN)
```

2. **テスト2：二項演算子の左辺欠落**
```sign
` 左辺が欠落した掛け算
bad_calc2 : * 5
bad_calc2	` 期待値: Unit (NaN)
```

3. **テスト3：束縛（define）の値欠落**
```sign
` 値のない束縛を含む辞書
bad_dict : [
	valid_key : 100
	empty_key : 
]

bad_dict ' empty_key	` 期待値: Unit (NaN)
```

4. **テスト4：ルックアップ（get）のキー欠落**
```sign
` キー名のないルックアップ
my_dict : [
	id : 42
]

my_dict ' 	` 期待値: Unit (NaN)
```

5. **テスト5：中身のない関数（ラムダ）の評価**
```sign
` 処理のないクロージャ
empty_func : x ? 

empty_func 10	` 期待値: Unit (NaN)
```

6. **テスト6：複合的な崩壊（ストレステスト）**
```sign
` むちゃくちゃな構文
chaos : [ 10 + - * ]
chaos	` 期待値: Unit (NaN)
```
-> すべてのケースでコンパイラはパニックを起こさず、不正な演算結果として安全に `NaN` に帰着することを確認済みです。
