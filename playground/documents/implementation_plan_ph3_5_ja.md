# 実装計画: WASM フェーズ 3.5 (フェイルファストとUnit評価)

## 目標
Sign言語のコンパイラ（WASM生成部）において、構文エラーやオペランドの欠落（例: `1 + ` や `* 5`）が発生した場合に、コンパイラをクラッシュさせたり無効なWATを出力してWASMインスタンス化を失敗させたりするのではなく、**「不正なノードの評価結果を強制的に Unit (NaN) としてWASMスタックに積み、実行を安全に継続させる（フェイルファスト）」**という強固なデバッグ基盤を構築します。

## 背景と課題
WASMにおけるスタックマシンアーキテクチャでは、各種命令（例: `f64.add`, `f64.mul`）は実行時にスタックから決められた数の引数（オペランド）を消費します。
以前の実装では、AST上で片方のオペランドが欠落している（`undefined` や `null` になっている）場合、コンパイラは「何もWASM命令を出力せずにスキップする」という挙動をしていました。
その結果、実行時にスタックの引数が足りなくなり、`type mismatch in f64.add, expected [f64, f64] but got [f64]` のようなWASMレベルでの致命的なバリデーションエラーを引き起こしていました。

## 実装された仕様と変更点 (`compiler_wat.js`)

### 1. 欠落ノードに対する完全なスタック保証
- `compileNode(node)` 関数の先頭において、引数 `node` が `null` や `undefined` などの欠落状態であった場合、単なる空文字 `''` を返すのではなく、**必ず `Unit`（Signにおける非数 `NaN`）を1つスタックに積む命令 (`f64.const nan`)** を出力してリターンするように修正しました。
- この「常に1つの値をスタックに積む」ルールの徹底により、スタックアンダーフローの発生を根本から防ぎます。

### 2. 演算子評価時のガード処理（`if (node.left)` 等）の撤廃
- 各種演算子（中置演算子、前置演算子など）の評価ロジック内に散在していた「対象ノードが存在する場合のみコンパイル（スタック積載）を行う」という条件分岐（ガード）をすべて削除しました。
- 欠落ノードに対しても前項1のルールが適用され自動的に `NaN` が積まれるため、欠落の有無に関わらず、演算子が必要とする数のオペランドがスタックに確実に準備されるようになりました。

### 3. 不完全な関数適用・演算子評価のフェイルファスト化
単独の演算子や引数が足りない状態で関数の適用が行われた際のスタック破壊を防止するため、以下の対応を行いました。

- **引数不足のネイティブ演算子適用（例: `* 5`）:**
  - `apply` ノードがネイティブ演算子（`+`, `*`, 等）を呼び出す際、その演算子が必要とする引数の数（arity）と、実際に提供された引数の数を比較します。
  - 不足している引数がある場合、演算子の命令（`f64.mul` 等）を出力する前に、**不足分だけ事前に `Unit` (`f64.const nan`) をスタックに自動パディング（補充）**します。
  - これにより、`* 5` は `NaN` -> `5.0` -> `f64.mul` として正しくWASM化されます。

- **単体の演算子評価（例: `[ 10 + - * ]` における演算子の孤立）:**
  - パース結果のAST構造上、値が期待される場所（識別子としての評価時）にネイティブ演算子が出現した場合、意図しないスタック消費を防ぐため、WASMの演算命令は出力せず **「未バインドのネイティブ関数」として扱い、代わりに `Unit` (`f64.const nan`) を1つだけプッシュ**します。

### 4. パイプライン・部分適用の堅牢化（追加修正）

手動検証テストの結果判明した、動的な関数合成におけるWASMのスタックアライメント問題とマクロ展開のバグに対し、以下の堅牢化対応を行いました。

* **関数合成時の無限ループとカリー化によるクロージャ返却:**
* 連続した関数合成（例: `[+ 2] [* 5] [+] 4`）において、AST展開（`expandMacros`）が無限再帰に陥る問題をフラグ管理によって解決しました。
* データフローの途中で引数が尽き、部分適用状態（未評価のラムダ項）になった際、無理に計算を完結させてエラーにするのではなく、Signの仕様通りに「クロージャへのポインタ」を返すカリー化判定を実装しました。これにより、スタック整合性を完璧に保ったまま安全に終了（JS側ではポインタのフォールバックとして `NaN` を出力）できるようになりました。


* **ブロック構文のパイプラインフラット化:**
* 縦並びのブロック（例: `[ \n + 2 \n * \n 10 \n ]`）内の要素を、単なる値の羅列ではなく関数適用（apply）のパイプライン連鎖として暗黙的にフラット化するロジックを `expandMacros` に追加し、ブロックを用いた関数合成がデータフローとして正しく評価されるようになりました。


## 今後の課題・残件（次フェーズ以降へ持ち越し）

* **パーサのブロック直後の値の解釈ズレ:**
* `[ \n + 2 \n * \n ] 10` のように、ブロック（`]`）の直後に置かれた値に対し、現在のパーサ（`parser_browser.js`）はこれを「ブロックへの関数適用」として結合せず、「次の独立したステートメント」として解釈してしまいます。
* その結果、ブロックの短絡評価ルールと組み合わさり、意図しない値（上記の場合は `10`）が早期リターンされてしまう現象が確認されています。
* **当面の回避策:** パイプラインの入力値は明示的にブロックの中に含める（例: `[ \n + 2 \n * \n 10 \n ]`）ことで正しいデータフローとして処理されます。
* **今後の対応:** 将来的（クロージャや関数の返却機構が完全にJS側で視覚化できるようになった段階）に、パーサ側の文脈解釈（ブロックの後続トークンの結合規則）の改修を検討します。

## 検証結果（手動テストスイート）

以下の意図的な構文エラー（欠落コード）および引数不足のデータフローを含むテストにおいて、WASMのバリデーションエラーやクラッシュが発生せず、正常にスタック整合性が保たれて `NaN`（Unitまたは未評価ポインタのフォールバック）が出力されることを確認しました。

1. 算術・論理演算子のオペランド欠落
```sign
test_math_R : 10 +
test_math_L : * 5
test_logic_R : 1 &
1 # test_math_R
1 # test_math_L
1 # test_logic_R
`期待値: すべてスタックアンダーフローを起こさず Unit (NaN) を返す
```

2. 辞書の定義エラーとプロパティアクセスの崩壊
```sign
test_dict_bad : [ : 100 ]
test_prop_bad : test_dict_bad ' missing
1 # test_dict_bad
1 # test_prop_bad
`期待値: Unit (NaN) を返す
```
3. 関数定義（ラムダ構築子）の構文エラー
```sign
test_lambda_empty : x ?
test_lambda_no_arg : ? 10
1 # test_lambda_empty
1 # test_lambda_no_arg
`期待値: Unit (NaN) を返す
```

4. 演算子の関数化（ポイントフリー）での中身の崩壊
```sign
test_pf_empty : []
test_pf_bad_op : [+ -]
test_pf_bad_apply : [10 + *]
1 # test_pf_empty
1 # test_pf_bad_op
1 # test_pf_bad_apply
`期待値: Unit (NaN) を返す
```

5. 関数合成・適用における引数不足（カリー化・クロージャ返却の検証）
```
test_compose_short : [+ 2] [* 5] [+] 4
1 # test_compose_short
`期待値: 14などの誤った計算結果を出さず、スタック整合性を保ったまま未評価のラムダ項のポインタとして機能し、JS側へはフォールバックの NaN を返す
```

6. インデントブロックにおけるパイプライン連鎖の検証
```sign
test_pipeline : [
	* 2
	10
]
1 # test_pipeline
`期待値: ブロック内の配列が apply 連鎖にフラット化され、5と同様に引数不足の未評価関数となり NaN を返す
```

-> すべてのケースでコンパイラはパニックを起こさず、不正な演算結果または未評価の関数ポインタとして安全に `NaN` に帰着することを確認済みです。

### 4. パイプライン・部分適用の堅牢化（追加修正）

手動検証テストの結果判明した、動的な関数合成におけるWASMのスタックアライメント問題とマクロ展開のバグに対し、以下の堅牢化対応を行いました。

* 関数合成時の無限ループとカリー化によるクロージャ返却:
連続した関数合成（例: [+ 2] [* 5] [+] 4）において、AST展開（expandMacros）が無限再帰に陥る問題をフラグ管理によって解決しました。
データフローの途中で引数が尽き、部分適用状態（未評価のラムダ項）になった際、無理に計算を完結させてエラーにするのではなく、Signの仕様通りに「クロージャへのポインタ」を返すカリー化判定を実装しました。これにより、スタック整合性を完璧に保ったまま安全に終了（JS側ではポインタのフォールバックとして NaN を出力）できるようになりました。
* ブロック構文のパイプラインフラット化:
縦並びのブロック（例: [ \n + 2 \n * \n 10 \n ]）内の要素を、単なる値の羅列ではなく関数適用（apply）のパイプライン連鎖として暗黙的にフラット化するロジックを expandMacros に追加し、ブロックを用いた関数合成がデータフローとして正しく評価されるようになりました。

## 今後の課題・残件（次フェーズ以降へ持ち越し）

* パーサのブロック直後の値の解釈ズレ:
[ \n + 2 \n * \n ] 10 のように、ブロック（]）の直後に置かれた値に対し、現在のパーサ（parser_browser.js）はこれを「ブロックへの関数適用」として結合せず、「次の独立したステートメント」として解釈してしまいます。
その結果、ブロックの短絡評価ルールと組み合わさり、意図しない値（上記の場合は 10）が早期リターンされてしまう現象が確認されています。
当面の回避策: パイプラインの入力値は明示的にブロックの中に含める（例: [ \n + 2 \n * \n 10 \n ]）ことで正しいデータフローとして処理されます。
今後の対応: 将来的（クロージャや関数の返却機構が完全にJS側で視覚化できるようになった段階）に、パーサ側の文脈解釈（ブロックの後続トークンの結合規則）の改修を検討します。
