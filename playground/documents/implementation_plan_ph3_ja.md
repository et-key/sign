# 実装計画: WASM フェーズ 3 (クロージャと辞書)

## 目標
フェーズ1・2で構築した `f64` ベースのスタック処理および NaN-Boxing によるメモリ管理基盤の上に、Sign言語の最大の特徴である「第一級関数（クロージャ）」と「辞書」を実装します。

本フェーズの核心は、Sign実行環境において辞書を「値のみを連続保存する環境（Environment）」として捉え直し、コンパイル時のオフセット解決によってルックアップの実行時オーバーヘッドをなくす**「Zero Cost Domain Abstraction」**を、WASM上で完全に表現することにあります。

## 実装された仕様と変更点

### 1. WASM 間接呼び出し (`call_indirect`) と Function Table
- 動的な関数呼び出しを実現するため、WASMの `funcref` テーブル `(table N funcref)` を定義します。
- ユーザー定義の関数（ラムダ式 `?`）はコンパイル時にすべて名前付きのWASM関数（例 `$lambda_0`, `$lambda_1`）としてトップレベルにシリアライズされ、コンパイル時に順次テーブルへ登録されます。

### 2. 環境オブジェクトとクロージャのメモリ表現 (NaN-Boxing)
- リストや文字列と同様に、新たな型タグとして **クロージャポインタ**（例: `0x7FFE000000000000`）および **辞書（Environment）ポインタ**（例: `0x7FFB000000000000`）を導入します。
- どちらもベースは同じヒープ上の構造体ですが、以下のレイアウトで保存されます。
  - **環境（Environment）オブジェクト**: 確保された `+0`, `+8`, `+16`... の連続した8バイト領域に、「変数の値（f64）」のみが（変数名キーをもたず）保存されます。
  - **クロージャオブジェクト**: 16バイトのセル。
    - オフセット 0: 関数ポインタ（テーブルインデックス）
    - オフセット 8: 環境（Environment）ポインタ（キャプチャした変数を格納するヒープへのポインタ）

### 3. 関数定義 (`?` ラムダ演算子) と辞書ブロックのコンパイル
- 構文木上の `?` ノード（ラムダ式）をコンパイルする際：
  1. 関数内で使用される外部スコープの変数（自由変数）を特定。（レキシカルスコープ）
  2. 現在の環境からキャプチャ対象の変数を収集し、`alloc` で確保したメモリに保存。
  3. 「テーブル関数インデックス」と「Environmentポインタ」のペア（クロージャオブジェクト）を生成しスタックに積みます。
- 構文木上の `block` ノードがローカル定義（`:`）をもつ場合：
  1. ブロック内で定義されるすべての変数を特定。
  2. `alloc` によりその変数の数×8バイトのメモリを確保し、スタックマシン処理の中で値をオフセット順にストア（`f64.store`）します。
  3. 全ての文が定義（`:`）である場合、このブロックはその「環境ポインタ（辞書）」を返り値とします。

### 4. 静的なオフセット解決によるルックアップ (`'`) とレイアウト伝播
- 辞書のプロパティアクセスである `'` 演算子が評価される際、WASMの実行時にメモリ検索（文字列比較等）を行うことはありません。
- コンパイラはシンボルテーブル（`envMap` や ASTノードの `_layout`）を介してオブジェクトの型メタデータを伝播させます。これによってアクセス対象の変数名がメモリ上の「どのオフセット」にあるのかを静的に解決します。
- `match_case`（条件分岐）やネストされたブロックから返される辞書環境のレイアウト情報も、親ノードへと正確に伝播されるように設計されています。
- **生成されるWASM**: `i32.const [offset]` -> `i32.add` -> `f64.load` となり、WASM上の辞書アクセスはC言語の構造体アクセスと同等の完全な Zero-Cost になります。

### 5. カッコブロック (`[]`) と Match Case の統合
- Sign言語の糖衣構文であるカッコブロック（`[]` や `{}`）は、インデントによるブロックと完全に等価な辞書環境（Environment）としてWASM上にアロケートされます。
- `A : B` 形式の構文において、左辺 `A` が単なる識別子の場合は変数定義（辞書へのストア）となりますが、比較演算（例: `x == 0`）などの場合はスタックおよび制御フロー（`if`）を操作する `match_case` として振る舞います。

## 検証結果

### 自動化・ブラウザテスト
以下のテストコードにて、関数・クロージャおよび静的に解決される辞書アーキテクチャの正常動作と正しいWASM出力結果を確認しました。

1. **クロージャの生成と適用:**
```sign
f : x y ? x + y
1 # f 10 20
1 # f (10 20)
1 # (f 10) 20
1 # (f 10 20)

1 # [x y ? x + y] 10 20
```
-> 静的スコープがWASMメモリ上で維持され、`30` が出力されます。

2. **`match_case` (条件分岐) の機能:**
```sign
match_test : x ?
	x = 0 : 100
	x > 0 : 200
	x < 0 : 300
	400

match_test 0
```
-> 比較演算子 `=` が正常に条件分岐としてコンパイルされ、WASM上で `100` が出力されます。非数値を渡した場合はデフォルトで `400` を返します。

3. **カッコブロック `[]` を用いた辞書の生成とアクセス:** 
```sign
dict_test : x ? [
	id : x
	val : x + 2
]

my_dict : dict_test 40
1 # my_dict ' id
1 # my_dict ' val
```
-> カッコブロックが辞書環境として正しくアロケートされ、静的オフセット解決によってルックアップなしで `42` が出力されます。

4. **Match Case と辞書環境の統合テスト:** 
```sign
complex_test : code ?
	code == 200 : [
		status : 200
		msg : 1
	]
	code == 404 : [
		status : 404
		msg : 0
	]
	[
		status : 500
		msg : -1
	]

res : complex_test 200
1 # res ' status
1 # res ' msg
```
-> `match_case` 内で生成された異なるオフセットの辞書環境について、メタデータ(`_layout`)テーブルが正しく親関数へ追跡・伝播され、`200` が出力されます。
