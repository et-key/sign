# 実装計画: WASM フェーズ 3 (クロージャと辞書)

## 目標
フェーズ1・2で構築した `f64` ベースのスタック処理および NaN-Boxing によるメモリ管理基盤の上に、Sign言語の最大の特徴である「第一級関数（クロージャ）」と「辞書」を実装します。
`a9` コンパイラの仕様に則り、Signでは辞書が内部的に「クロージャ（キーを引数に取り、値を返す関数）」として表現されるため、本フェーズの核心はWASM上でのクロージャ（関数ポインタと環境キャプチャ）の実現にあります。

## 提案する変更

### 1. WASM 間接呼び出し (`call_indirect`) と Function Table
- 動的な関数呼び出しを実現するため、WASMの `funcref` テーブル `(table 1 funcref)` を定義します。
- ユーザー定義の関数（ラムダ式）はコンパイル時にすべて名前付きのWASM関数（例 `$lambda_0`, `$lambda_1`）としてトップレベルにシリアライズされ、コンパイル時に順次テーブルへ登録します。

### 2. クロージャ・オブジェクトのメモリ表現 (NaN-Boxing)
- リストや文字列と同様に、新たな型タグとして **クロージャポインタ**（例: `0x7FFE000000000000`）を導入します。
- クロージャオブジェクトはヒープ上に割り当てられる構造体（コンスセルに似たもの）です：
  - オフセット 0または下位ビット: 関数ポインタ（テーブルインデックス、i32のアドレス）
  - オフセット 8（またはペイロード上位）: 環境（Environment）ポインタ（キャプチャした変数を格納するヒープへのポインタ）

### 3. 関数定義 (`?` ラムダ演算子) のコンパイル
- 構文木上の `?` ノード（ラムダ式）をコンパイルする際の処理を追加します：
  1. 関数内で使用される外部スコープの変数（自由変数）を特定します（変数のキャプチャ）。
  2. 実行時の生成コードとして、「現在の環境からキャプチャ対象の変数を収集し、ヒープに保存（Environment構造体の生成）」します。
  3. 「テーブル関数インデックス」と「Environmentポインタ」のペア（クロージャオブジェクト）を `alloc` で確保し、クロージャタグを付与した `f64` としてスタックに積みます。

### 4. 関数適用 (`apply`) のコンパイル
- 既存の `apply`処理（現在は `unmapped` 時の安全な `drop` と `nan` 生成を設定済）に、対象がクロージャであるか判定するロジックを実装します。
- クロージャ呼び出しの手順：
  1. 引数と、クロージャポインタをスタックに積みます。
  2. クロージャポインタから「関数インデックス」と「環境ポインタ」を読み出します。
  3. WASMの `call_indirect` を用いて動的に関数へジャンプします。関数側は第一引数として「環境ポインタ」を受け取り、自身のローカル引数と共に処理を実行します。

### 5. 辞書 (Dictionary) とスプレッド (`~`) の実装
- `a9` の実装設計に従い、ASTにおける辞書リテラルは「連鎖的なクロージャ関数群」として展開・コンパイルされます。関数の機能を利用するため、追加での複雑なメモリデータ構造は不要です。
- リストおよび辞書の結合演算子であるスプレッド演算子 `~` についても、`bl _concat` 相当の機能をもつWASMヘルパー関数として実装します。

## 検証計画

### 自動化・ブラウザテスト
1. **クロージャの生成と適用**: `(x ? x) 42` -> `42` を返すこと。
2. **変数のキャプチャ (レキシカルスコープ)**:
```sign
f : (x ? (y ? x + y))
1 # (f 10) 20
```
-> 静的スコープが維持され、`30` が出力されること。
3. **辞書の生成とアクセス**: 
```sign
dict : { "name" : "Alice", "age" : 20 }
1 # dict "name"
```
-> `"Alice"`（の文字列ポインタ）に解決され、正しく出力されること。
