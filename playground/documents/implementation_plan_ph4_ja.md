# 実装計画: WASM フェーズ 4 (関数適用のコア評価モデルの完全化)

## 目標
フェーズ3.5までに構築されたWASM基盤の上に、Sign言語の関数型言語としての根幹機能である「ポイントフリー記法（関数合成）」と「引数不足時の部分適用（カリー化およびクロージャ返却）」を実装し、純粋関数型言語としての正しい遅延評価・データフローを確立します。
既存のWASMメモリ管理（NaN-Boxingによる辞書環境とクロージャ）を最大限に活用し、WASMの低レイヤーを無駄に複雑化させない「Zero Cost Domain Abstraction」を体現した設計を目指します。

## 実装された仕様と変更点

### 1. ポイントフリー記法（関数合成）の修復とスタック整合性の担保
- **スタックアンダーフローの修正:** 関数合成のために内部でラムダ（クロージャ）が生成される際、外部スコープの変数をキャプチャして環境（Environment）メモリに保存するコードにおいて、ローカル環境変数（`local_env`）をロードしてスタックに積む処理が抜け落ちていたバグを修正しました。
- **ASTノードの安全な伝播:** `expandMacros` 内で関数適用のパイプラインを展開する際、変数ノードを上書き破壊せず、クローンしてメタデータを安全に伝播させることで正常な関数合成を実現しました。
- **`isFunction` の認識修正:** 引数が不足している中置演算子（例: `10 +`）を関数（クロージャ）として正しく認識するように修正し、パイプライン展開で関数適用として正しく結合されるようにしました。

### 2. 引数不足時の部分適用（カリー化）の徹底
引数不足のネイティブ演算子に対して、強制的に計算を実行してエラーや `NaN` にするのではなく、Signの本来の仕様通り「未評価のクロージャ」を返すように設計を刷新しました。

- **ASTのローカル変換 (Desugar) によるクロージャ生成:**
  引数不足の演算（infix, prefix, postfix）を検知した際、新規に複雑なWASM命令を生成するのではなく、その場で「不足引数を補うラムダ（`?`）のAST」にローカル変換し、フェーズ3で完成している既存のコンパイルフローに流す設計を採用しました。
- **Call-by-value（事前評価）の実現:**
  `[重い計算] +` のような複雑な式が適用された際、クロージャ呼び出しのたびに再計算されるのを防ぐため、ASTを「変数を束縛（`:`）してラムダを返すブロック（`[]`）」に変換する仕組みを構築しました。
  *例:* `[ 0_cap_L : [重い計算], 0_curry_R ? (0_cap_L + 0_curry_R) ]`
  これにより、1度だけ評価された値が環境（辞書）に保存され、ユーザー定義変数と衝突しないよう `0_` 始まりのシステム変数名を用いて安全にクロージャ化されます。
- **ブロック実行のショートサーキット（早期リターン）の回避:**
  WASMコンパイラにおけるブロック実行が、内部でTruthyな値（クロージャポインタ等）を発見すると以降の評価をスキップしてしまう仕様バグを発見しました。変数束縛演算子（`:`）が常に Falsy な値（`Unit/NaN`）を返すように修正することで、ブロックが最後までシーケンシャルに正しく評価されるようになりました。

## 検証結果（手動テストスイート）

ポイントフリー記法（関数合成）および部分適用（カリー化）が正しく動作し、期待通りのデータフローが構築されること、また引数不足時にクラッシュせず `NaN` (未評価関数ポインタ) を返すことを確認しました。

### 1. ポイントフリー記法（関数合成）のテスト

```sign
` テスト1: ポイントフリー記法の基本（右から左への評価/関数合成）
` 処理順: 4 -> [+ 2] -> [* 5]
test_pf_basic : [+ 2] [* 5] 4
1 # test_pf_basic
` 期待値: (4 + 2) * 5 = 30

` テスト2: 3つ以上の関数合成
` 処理順: 5 -> [+ 3] -> [* 2] -> [- 4]
test_pf_multi : [+ 3] [* 2] [- 4] 5
1 # test_pf_multi
` 期待値: ((5 + 3) * 2) - 4 = 12

` テスト3: 関数適用の連鎖によるデータフロー
` 引数を明示しない関数合成 [+ 5] [/ 3] に対して、値 10 を適用する
` 処理順: 10 -> [+ 5] -> [/ 3]
test_pf_pipe : [+ 5] [/ 3] 10
1 # test_pf_pipe
` 期待値: (10 + 5) / 3 = 5

` テスト4: 変数への合成関数の束縛と、後からの値の適用
` f に合成関数を束縛し、それに値を渡す
f : [* 3] [+ 10]
test_pf_bind : f 4
` 処理順: 4 -> f( [* 3] -> [+ 10] )
1 # test_pf_bind
` 期待値: (4 * 3) + 10 = 22

` テスト5: 引数不足の未評価関数の返却（パイプライン途中での引数枯渇）
test_pf_short : [+ 2] [* 5] [+] 4
1 # test_pf_short
` 期待値: 途中で引数が尽きるため、関数ポインタのフォールバックとして NaN を返す

```

### 2. 部分適用（カリー化）のテスト

```sign
` テスト6: 右辺不足の部分適用 (10 + ?)
` 10 がキャプチャされ、後から 5 を受け取って 10 + 5 を計算する
f1 : 10 +
1 # f1 5
` 期待値: 15

` テスト7: 左辺不足の部分適用 (? + 2)
` 2 がキャプチャされ、後から 10 を受け取って 10 + 2 を計算する
f2 : + 2
1 # f2 10
` 期待値: 12

` テスト8: 両辺不足の完全なカリー化 (?)
` 2段階で引数を受け取る関数となる
f3 : +
f4 : f3 100
1 # f4 50
` 期待値: 150

` テスト9: 事前評価（Call-by-value）の確認
` 複雑な式 [10 * 2] が環境に1度だけ事前計算・キャプチャされてクロージャになるか
f5 : [10 * 2] +
1 # f5 3
` 期待値: 23
```