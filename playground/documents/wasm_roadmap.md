# Sign WASM版 実装状況とロードマップ

`playground/public_html` 以下の現状のコード（主に `compiler_wat.js`）と、`proto/a9` でのコンパイラ実装を比較し、WASM版の実装状況と今後のロードマップを整理しました。

## 1. 現在の実装状況（実装済みの機能）
現状の Wasm (`WAT`) コンパイラは、初期のスタックマシンのプロトタイプとして機能しており、**f64型（浮動小数点数）を基本とした数値計算と、ごく基本的なAST変換**が実装されています。

- **基本的な数値と四則演算など**:
  - `+`, `-`, `*`, `/` のWasmネイティブ命令 (`f64.add` など)
  - `^` (べき乗), `%` (剰余) のJS環境側関数呼び出し (`math_pow`, `math_fmod` インポート)
- **標準入出力（単一の数値のみ）**:
  - `#` による出力 (`print_float` インポート)
  - `@` による入力 (`input_float` インポート)
- **マクロ展開と変数バインディング（インライン展開メイン）**:
  - `:` 演算子による単純な変数バインディングと環境（辞書）への登録、および参照環境に基づいたASTのインライン展開（ディープコピー）。
- **パイプライン・関数適用の最適化**:
  - `apply` ノードや空白等による左結合の関数適用の構造再構築がマクロ展開で行われています。カリー化や `|>` スタイルに対応するためのスタック順序の制御が入っています。

---

## 2. 今後追加すべき機能（a9との差分・ロードマップ）
`proto/a9` で実装されていた（AArch64アーキテクチャ向けの）機能群と比較すると、Wasm版として Sign 言語を本格稼働させるためには、以下の機能追加が必要です。

これらを大きく3つのフェーズに分けて実装していくことをお勧めします。

### フェーズ1: 制御構文と論理・比較演算（スタックマシンの完成）
現在のスタックマシンには、まだ「分岐」と「真偽値の計算」が含まれていません。
- **比較演算子**: `==`, `<`, `>`, `<=`, `>=`, `!=` (`f64.eq`, `f64.lt` などのWasm命令の生成)
- **論理・ビット演算子**: `&&`, `||`, `!`, `;;`(XOR), `<<`, `>>` など。Wasmではビット演算に `i32` 型が必要になるため、値のキャスト体系やスタック上での扱い（f64ベースでいくか等）の整理が必要です。
- **条件分岐 (`?`)**: Signの実行時評価ブロックをWasm側の `if` / `else` / `end` ブロックとしてどうコンパイルするかの実装。

### フェーズ2: メモリ管理の導入と複合データ（文字列・リスト）
現状はWasmのスタックとインライン変数しか使っていませんが、今後はリストや文字列を扱うために「ヒープ領域（Wasm Linear Memory）」の導入が不可欠になります。
- **動的メモリ (Linear Memory) の導入**: Wasmの `(memory 1)` 等のエクスポート/インポート。
- **メタデータ（型タグ）の仕組み**:
  - 単なる `f64` の数値なのか、ヒープを指す「ポインタ」（文字列、リスト、クロージャ）なのかを実行時に判別する仕組み（a9でやっていたようなポインタ判定の概念や NaN-boxing など）。
- **ヒープオブジェクトのサポート**:
  - リスト生成 (`cons`, `head`, `tail`)
  - 文字列や配列の構築と出力 (`_print_str` などの対応)
  - 辞書型（a9の最終版で実装したクロージャベースの辞書、あるいはヒープベースのもの）
- **ランタイム（コア関数）の提供**: アロケータ (`_alloc`) などをWATで実装するか、JS側からインポートして提供する。

### フェーズ3: 関数定義とクロージャの本格対応
- **ユーザー定義関数のコンパイル**: 現在はマクロでインライン展開していますが、本格的な巨大関数や再帰に備えて、Wasmの `(func ...)` として切り出し、`call` で呼び出す対応。
- **クロージャと環境（Env）のキャプチャ**:
  - a9で行ったように、環境変数をヒープに保存し、関数のインデックス (`call_indirect`) とポインタを組み合わせたクロージャの構築。
- **再帰・ループ処理の実現**。
