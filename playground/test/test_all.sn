` =========================================================
1 # `===== Ph1 =====`
` =========================================================
` --- 比較演算 ---
1 # (5 == 5)
1 # (1 != 2)
1 # (1 < 2)
1 # (2 > 1)
1 # (1 <= 1)
1 # (2 >= 2)

` --- 論理演算 (0, 1 は Truthy, _ は Falsy) ---
1 # (_ & 0)
1 # (0 & _)
1 # (0 & 1)
1 # (_ | 0)
1 # (0 | _)
1 # (0 | 1)
1 # (_ ; 0)
1 # (1 ; _)
1 # (0 ; 1)
1 # (_ ; _)

` --- ビット演算 ---
1 # (1 && 42)
1 # (0 || 99)
1 # (1 ;; 1)
1 # (1 ;; 0)
1 # (1 << 2)
1 # (4 >> 1)
1 # (!!0)

` --- その他制御・単項演算 ---
1 # (!1)
1 # (!(1 == 2))
1 # ((1 == 1) : 100)
1 # ((1 == 2) : 200)
1 # (x ? x + 1)

` =========================================================
1 # `===== Ph2 =====`
` =========================================================
` テスト1: 文字列（Strings）の割り当てと出力
1 # `Hello! WASM Strings!`

` テスト2: リスト作成と結合 (cons と ,)
list : 100, 200
1 # list

` テスト3: リスト要素の抽出 (head, tail)
list : 100, 200
1 # head list
1 # tail list

` テスト4: ブロックの短絡評価 ([...])
1 # [ _ 42 99 ]

` =========================================================
1 # `===== Ph3 =====`
` =========================================================
` 1.クロージャの生成と適用
f : x y ? x + y
1 # f 10 20
1 # f (10 20)
1 # (f 10) 20
1 # (f 10 20)

1 # [x y ? x + y] 10 20


` 2.`match_case` (条件分岐) の機能
match_test : x ?
	x = 0 : 100
	x > 0 : 200
	x < 0 : 300
	400
1 # match_test 0
1 # match_test 1
1 # match_test -1
1 # match_test _
1 # match_test `a`
1 # match_test a

` 3.カッコブロック `[]` を用いた辞書の生成とアクセス
dict_test : x ? [
	id : x
	val : x + 2
]

my_dict : dict_test 40
1 # my_dict ' id
1 # my_dict ' val


` 4.Match Case と辞書環境の統合テスト
complex_test : code ?
	code == 200 : [
		status : 200
		msg : 1
	]
	code == 404 : [
		status : 404
		msg : 0
	]
	[
		status : 500
		msg : -1
	]

res : complex_test 200
1 # res ' status
1 # res ' msg

res : complex_test 404
1 # res ' status
1 # res ' msg

res : complex_test _
1 # res ' status
1 # res ' msg

res : complex_test a
1 # res ' status
1 # res ' msg

` =========================================================
1 # `===== Ph3.5 =====`
` =========================================================
` 1. 算術・論理演算子のオペランド欠落
test_math_R : 10 +
test_math_L : * 5
test_logic_R : 1 &
1 # test_math_R
1 # test_math_L
1 # test_logic_R
`期待値: すべてスタックアンダーフローを起こさず Unit (NaN) を返す


` 2. 辞書の定義エラーとプロパティアクセスの崩壊
test_dict_bad : [ : 100 ]
test_prop_bad : test_dict_bad ' missing
1 # test_dict_bad
1 # test_prop_bad
`期待値: Unit (NaN) を返す

` 3. 関数定義（ラムダ構築子）の構文エラー
test_lambda_empty : x ?
test_lambda_no_arg : ? 10
1 # test_lambda_empty
1 # test_lambda_no_arg
`期待値: Unit (NaN) を返す

` 4. 演算子の関数化（ポイントフリー）での中身の崩壊
test_pf_empty : []
test_pf_bad_op : [+ -]
test_pf_bad_apply : [10 + *]
1 # test_pf_empty
1 # test_pf_bad_op
1 # test_pf_bad_apply
`期待値: Unit (NaN) を返す

` 5. 関数合成・適用における引数不足（カリー化・クロージャ返却の検証）
test_compose_short : [+ 2] [* 5] [+] 4
1 # test_compose_short
`期待値: 14などの誤った計算結果を出さず、スタック整合性を保ったまま未評価のラムダ項のポインタとして機能し、JS側へはフォールバックの NaN を返す

` 6. インデントブロックにおけるパイプライン連鎖の検証
test_pipeline : [
	* 2
	10
]
1 # test_pipeline
`期待値: ブロック内の配列が apply 連鎖にフラット化され、5と同様に引数不足の未評価関数となり NaN を返す


` =========================================================
1 # `===== Ph4 =====`
` =========================================================
` 1. ポイントフリー記法（関数合成）のテスト

` テスト1: ポイントフリー記法の基本（右から左への評価/関数合成）
` 処理順: 2 -> [+ 4] -> [* 3]
` 期待値: (2 + 4) * 3 = 18
foo : [+ 4]
bar : [* 3]
baz : 2
1 # foo bar baz

` テスト2: 3つ以上の関数合成
` 処理順: 5 -> [+ 3] -> [* 2] -> [- 4]
test_pf_multi : [+ 3] [* 2] [- 4] 5
1 # test_pf_multi
` 期待値: ((5 + 3) * 2) - 4 = 12

` テスト3: 関数適用の連鎖によるデータフロー
` 引数を明示しない関数合成 [+ 5] [/ 3] に対して、値 10 を適用する
` 処理順: 10 -> [+ 5] -> [/ 3]
test_pf_pipe : [+ 5] [/ 3] 10
1 # test_pf_pipe
` 期待値: (10 + 5) / 3 = 5

` テスト4: 変数への合成関数の束縛と、後からの値の適用
` f に合成関数を束縛し、それに値を渡す
f : [* 3] [+ 10]
test_pf_bind : f 4
` 処理順: 4 -> f( [* 3] -> [+ 10] )
1 # test_pf_bind
` 期待値: (4 * 3) + 10 = 22

` テスト5: 引数不足の未評価関数の返却（パイプライン途中での引数枯渇）
test_pf_short : [+ 2] [* 5] [+] 4
1 # test_pf_short
` 期待値: 途中で引数が尽きるため、関数ポインタのフォールバックとして NaN を返す

`2. 部分適用（カリー化）のテスト

` テスト6: 右辺不足の部分適用 (10 + ?)
` 10 がキャプチャされ、後から 5 を受け取って 10 + 5 を計算する
f1 : 10 +
1 # f1 5
` 期待値: 15

` テスト7: 左辺不足の部分適用 (? + 2)
` 2 がキャプチャされ、後から 10 を受け取って 10 + 2 を計算する
f2 : + 2
1 # f2 10
` 期待値: 12

` テスト8: 両辺不足の完全なカリー化 (?)
` 2段階で引数を受け取る関数となる
f3 : +
f4 : f3 100
1 # f4 50
` 期待値: 150

` テスト9: 事前評価（Call-by-value）の確認
` 複雑な式 [10 * 2] が環境に1度だけ事前計算・キャプチャされてクロージャになるか
f5 : [10 * 2] +
1 # f5 3
` 期待値: 23


` =========================================================
1 # `===== end =====`
` =========================================================

