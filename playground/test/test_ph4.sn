` 1. ポイントフリー記法（関数合成）のテスト

` テスト1: ポイントフリー記法の基本（右から左への評価/関数合成）
` 処理順: 2 -> [+ 4] -> [* 3]
` 期待値: (2 + 4) * 3 = 18
foo : [+ 4]
bar : [* 3]
baz : 2
1 # foo bar baz

` テスト2: 3つ以上の関数合成
` 処理順: 5 -> [+ 3] -> [* 2] -> [- 4]
test_pf_multi : [+ 3] [* 2] [- 4] 5
1 # test_pf_multi
` 期待値: ((5 + 3) * 2) - 4 = 12

` テスト3: 関数適用の連鎖によるデータフロー
` 引数を明示しない関数合成 [+ 5] [/ 3] に対して、値 10 を適用する
` 処理順: 10 -> [+ 5] -> [/ 3]
test_pf_pipe : [+ 5] [/ 3] 10
1 # test_pf_pipe
` 期待値: (10 + 5) / 3 = 5

` テスト4: 変数への合成関数の束縛と、後からの値の適用
` f に合成関数を束縛し、それに値を渡す
f : [* 3] [+ 10]
test_pf_bind : f 4
` 処理順: 4 -> f( [* 3] -> [+ 10] )
1 # test_pf_bind
` 期待値: (4 * 3) + 10 = 22

` テスト5: 引数不足の未評価関数の返却（パイプライン途中での引数枯渇）
test_pf_short : [+ 2] [* 5] [+] 4
1 # test_pf_short
` 期待値: 途中で引数が尽きるため、関数ポインタのフォールバックとして NaN を返す

`2. 部分適用（カリー化）のテスト

` テスト6: 右辺不足の部分適用 (10 + ?)
` 10 がキャプチャされ、後から 5 を受け取って 10 + 5 を計算する
f1 : 10 +
1 # f1 5
` 期待値: 15

` テスト7: 左辺不足の部分適用 (? + 2)
` 2 がキャプチャされ、後から 10 を受け取って 10 + 2 を計算する
f2 : + 2
1 # f2 10
` 期待値: 12

` テスト8: 両辺不足の完全なカリー化 (?)
` 2段階で引数を受け取る関数となる
f3 : +
f4 : f3 100
1 # f4 50
` 期待値: 150

` テスト9: 事前評価（Call-by-value）の確認
` 複雑な式 [10 * 2] が環境に1度だけ事前計算・キャプチャされてクロージャになるか
f5 : [10 * 2] +
1 # f5 3
` 期待値: 23