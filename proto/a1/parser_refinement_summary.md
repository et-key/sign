# Sign言語パーサー実装の変遷と修正内容まとめ

本ドキュメントは、Sign言語パーサー（`proto/a1`）の実装において、初期実装からユーザー様のフィードバックに基づいて行った修正およびその解説をまとめたものです。

## 1. 初期の課題と修正方針

### 1-1. semantics変換の廃止
*   **初期状態**: `operators.js` の `semantics` テーブルを使用し、演算子記号を意味論名（例: `+` → `add`, `:` → `define`）に変換して出力していました。
*   **課題**: 仕様書（`A_Operator_Table.md`）にある通り、記号そのものが意味を持つ言語設計であるため、変換は不要でした。
*   **修正**: `test_output.json` において、記号をそのまま（例: `+`, `:`）出力するように変更しました。

### 1-2. 独自演算子名（semanticsにないもの）の廃止
*   **初期状態**:
    *   改行 → `sequence`
    *   空白 → `apply`
    *   これらはパーサー内で便宜的に名付けられた独自の名前でした。
*   **修正**: 仕様に基づき、以下の記号として扱うようにしました。
    *   改行 → `,`（積／Product）：リスト構築や連続処理として扱う場合。
    *   空白 → `" "`（Apply）：関数適用やリストの区切りとして扱う場合。
    *   これにより、すべての出力が純粋なSign言語の演算子記号で統一されました。

## 2. 構文解析ロジックの改良

### 2-1. 改行の扱い（独立した処理 vs 連続処理）
*   **フィードバック**: 「改行後にタブを含まない場合は独立した処理になるはず」
*   **対応**:
    *   以前は改行をすべて単一のトップレベルシーケンス（`sequence`演算子による結合）として処理しており、プログラム全体が1つの巨大なS式になっていました。
    *   **修正後**: 同一インデントレベルでの改行は「文の区切り」とみなし、独立したS式のリスト（配列）として出力するようにしました。
    *   結果: `test_output.json` のルート構造は `[Expr1, Expr2, ...]` という配列になります。

### 2-2. 単項演算子・二項演算子の区別
*   **解説**: S式の配列長（要素数）によって区別されます。
    *   **単項演算**: `["-", 10]` （要素数2：オペレータ + 引数）
    *   **二項演算**: `["-", 10, 3]` （要素数3：オペレータ + 左辺 + 右辺）

### 2-3. ポイントフリー記法（部分適用）の扱い
*   **解説**: Sign言語の構文通り、演算子を含むリストとして出力されます。
    *   入力: `[+ 1]`
    *   出力: `[["+", 1]]` （リストの中に、引数が1つ欠けた演算式が入っている構造）
    *   これにより、実行系（インタプリタ）は「リスト先頭が演算子である」ことを検知して、関数（セクション）として扱うことができます。

## 3. 曖昧性の解決（演算子の多重定義）

### 3-1. 前置・中置・後置の完全な区別
*   **課題**: `!`, `~`, `@`, `#` などの記号は、前置・中置・後置ですべて同じ記号を使うため、単純な `["!", "x"]` という出力では、それが「前置のnot」なのか「後置のfactorial」なのか区別がつきにくい（あるいはコンテキスト依存になる）問題がありました。
*   **対応**: **装飾付き記号（Decorated Symbols）** を導入し、出力段階で明確に区別しました。
    *   `!` の例:
        *   前置（not）: `!_`
        *   後置（factorial）: `_!`
    *   `~` の例:
        *   前置（範囲など）: `~`
        *   後置（展開）: `_~`
    *   これらは `operators.js` の `semantics` キー（内部識別子）としても定義されている記号体系を活用しています。

### 3-2. 負の数リテラルと減算記号の区別
*   **フィードバック**: 「`-` は単項演算子には存在しない（負数はリテラルである）」
*   **対応**: トークナイザー（字句解析器）を改良し、文脈依存のスキャンを実装しました。
    *   `-` の直前が「値（数値、識別子、閉じ括弧等）」であれば **減算演算子**（中置 `["-", A, B]`）として解析。
    *   そうでなければ（行頭、演算子の直後など）、後続の数字と結合して **負の数値リテラル**（プリミティブな `-123`）として解析。
    *   これにより、`-` という単項演算子を出力することなく、負数を正しく表現できるようになりました。

---

## 4. 最終的な出力形式 (S-Expression)

現在のパーサーは以下の特長を持つJSONを出力します。

```json
[
  [":", "x", 10],             // 定義
  ["+", 1, ["*", 2, 3]],      // 算術演算 (プリミティブ値)
  [":", "negative", -5],      // 負の数リテラル
  ["!_", "flag"],             // 前置演算子 (装飾付き)
  ["_!", "n"]                 // 後置演算子 (装飾付き)
]
```

以上の修正により、仕様書およびユーザー様の意図に即した、解釈の曖昧さがない構文解析結果が得られるようになりました。
