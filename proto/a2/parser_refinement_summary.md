# Sign言語パーサー実装の変遷と修正内容まとめ (proto/a2)

本ドキュメントは、Sign言語パーサー（`proto/a2`）の実装において、`proto/a1` からの進化および修正内容をまとめたものです。

## 1. 絶対値表記 (`|...|`) のサポート

### 1-1. 課題と解決策
*   **課題**: パイプ記号 `|` は絶対値（囲み）とビット演算 OR（中置）の両方で使われるため、単純なトークン分割では衝突する。
*   **対応**:
    *   **厳格な空白ルール**:
        *   `a | b` (両側に空白あり) → 中置演算子（OR）
        *   `|x` (直後に空白なし) → 絶対値開始 (`[|`)
        *   `x|` (直前に空白なし) → 絶対値終了 (`|]`)
        *   `a|b` (両側空白なし) → 構文エラー
    *   **内部処理**:
        *   Tokenizerで空白のコンテキストを保持し、Pass 1で `|` を `[|` (Open) または `|]` (Close)、あるいは通常の `|` (Infix) に置換。
        *   Shunting Yardアルゴリズム内で `[| ... |]` を括弧と同様に処理し、リスト構築ではなく **算術式の一部** としてパース。

### 1-2. 出力シンボルの変更
*   **初期案**: `["|", expr]`
*   **採用案**: `["!-", expr]`
*   **理由**:
    *   ビット演算（`|`）やリスト構築との混同を防ぐため。
    *   `!-` (Not Minus) という記号により、「負ではない＝絶対値」という意味を明確化。
    *   S式としての可読性が向上。

---

## 2. 実装アーキテクチャの変更

*   **prepare_lexer.js の分離**: `|` 記号をトークンとして認識させるため区切り文字を変更する必要が生じ、`proto/a1` と分離して `proto/a2` 用に独自のLexer定義を作成。
*   **Parser構造**:
    *   `structurize`（ブロック構築）ではなく `parseExpr`（式解析）フェーズで絶対値を処理することで、演算子の優先順位を正しく反映。

---

## 3. Lambda (`?`) の構造化パース対応とHybrid Parserの導入

### 3-1. 課題（Lambda `?` の構造化）
*   **課題**: `?` (Lambda) の優先順位が `,` (Comma) よりも高かったため、`func arg1, arg2 ? body` のような式が `(func arg1, arg2) ? body` と誤って結合され、引数リストが正しく構造化されなかった。
*   **要件**: Lambdaの左辺（LHS）は式ではなく「パラメータリスト」として、右辺（RHS）は「関数本体」として分離してパースする必要がある。

### 3-2. 解決策：Hybrid Parserの実装

Lambda構文のような「構造的な分割」を正しく処理するため、従来の Shunting Yard アルゴリズムの前段に、構造決定を行うフェーズを導入した **Hybrid Parser** アーキテクチャへ移行しました。
これにより、Lambdaだけでなく、Export (`#`) のような前置演算子も文脈に応じて正しく処理される堅牢なパーサーとなりました。

1.  **Token Resolution Phase (Pass 1)**:
    *   トークン列をスキャンし、各演算子がその文脈において **Preifx** なのか **Infix** なのかを確定させます。
    *   これにより、従来の単純な優先順位処理では曖昧だった `#` (Export) などの前置演算子も正確に識別されます。

2.  **Precedence Climbing Splitter**:
    *   優先順位が **3以下** の構造的演算子（`?`: Lambda, `:`: Define, `#`: Export）に対して、最も優先順位が低い箇所でトークン列を分割します。
    *   **Infix Split (`?`)**: 左辺を**パラメータリスト**として専用処理 (`parseParams`) し、`["?", Params, Body]` を生成します。
    *   **Prefix Split (`#`等)**: 前置演算子がルートとなる場合、右辺全体を引数として正しくラップします。

3.  **Fallback to Shunting Yard**:
    *   分割が不要な通常の式（算術演算など）は、従来の Shunting Yard アルゴリズムで処理されます。

この変更により、Lambda式の正しい構造化と、他の演算子の優先順位処理の整合性が両立されました。
