# Sign言語演算子テスト チェックリスト

このドキュメントは、`proto/a5` の現在の実装と Sign言語仕様との違いを確認するためのチェックリストです。

## テストファイル

- **test_operators.sn**: 全演算子を網羅的にテスト
- **test_operators_minimal.sn**: 仕様との違いが疑われる演算子に焦点

## 確認手順

各テストケースについて以下を確認：

```powershell
# 1. S式形式で確認
python main.py test_operators_minimal.sn --format sexp

# 2. Common Lisp形式で確認
python main.py test_operators_minimal.sn --format clisp

# 3. (オプション) AST構造で確認
python main.py test_operators_minimal.sn --format ast
```

## 重点確認項目

### 1. `#` 演算子（Export/Output）

#### 仕様
- **前置**: `#x : 42` → 変数を外部公開（export）
- **中置**: `addr # data` → アドレスにデータを関連付け（出力）

#### 現在の実装（修正済み）
- **前置**: `; EXPORTED` コメントを出力（Common Lispのexportとは異なるため）
- **中置**: アドレス依存の変換
  - `0x1 # expr` → `(format t "~a" expr)` (標準出力)
  - `expr # _` → `(format t "~a" expr)` (標準出力)
  - その他 → TODOコメント

#### 確認ポイント
- [x] 前置と中置の区別が正しく解析されているか？
- [x] 中置の `#` が `print` でなく本来は何に変換されるべきか？（修正済み）
- [x] `expr # _` は標準出力と解釈して `print` で問題ないか？（修正済み）

---

### 2. `:` 演算子（Define）

#### 仕様
- `x : 42` → 左辺の名前を右辺の値に束縛

#### 現在の実装（修正済み）
- 変数定義: `(defparameter x 42)`
- 関数定義（Lambda）: `(defun x (...) ...)`

#### 確認ポイント
- [x] `defparameter` は適切か？（`defvar`, `setf`, `let` との違い）
- [x] スコープは正しく扱われるか？
- [x] 再代入の挙動は？
- [x] 関数定義（Lambda代入）が `defun` に変換されるか？（修正済み）

---

### 3. ポイントフリー記法

#### 仕様
- `[+]` → DirectFold（畳み込み）
- `[+ 1]` → 右部分適用（`x -> x + 1`）
- `[5 -]` → 左部分適用（`x -> 5 - x`）
- `[* 2,]` → map関数（各要素に `x -> x * 2` を適用）

#### 現在の実装
```lisp
[+]    → (lambda (lst) (reduce #'+ lst))
[+ 1]  → (lambda (x) (+ x 1))
[5 -]  → (lambda (x) (- 5 x))
[* 2,] → (lambda (lst) (mapcar (lambda (x) (* x 2)) lst))
```

#### 確認ポイント
- [x] DirectFoldの変換は正しいか？
- [x] 部分適用の左右の区別は正しいか？
- [x] map用のカンマ(`,`)の処理は正しいか？
- [x] Common Lispで実際に動作するか？

---

### 4. `?` 演算子（Lambda）

#### 仕様
- `x y ? x + y` → 2引数のラムダ式

#### 現在の実装
- `(lambda (x y) (+ x y))`

#### 確認ポイント
- [x] 複数引数の処理は正しいか？
- [x] カリー化は不要か？（Sign言語の仕様確認）
- [x] 本体の式の変換は正しいか？（Output演算子の優先順位修正済み）

---

### 5. `,` 演算子（Product）

#### 仕様
- `1, 2, 3` → 積（リスト構築）、右結合

#### 現在の実装
- `(list 1 2 3)`

#### 確認ポイント
- [x] `list` で正しいか？
- [x] 右結合は実装されているか？
- [x] ネストした積の処理は？

---

### 6. `~` 演算子（Range/Continuous/Expand）

#### 仕様（文脈依存）
- **中置**: `1 ~ 10` → 範囲リスト
- **中置3項**: `0 ~ 2 ~ 10` → ステップ指定範囲
- **前置**: `~x` → 連続パラメータ（可変長引数）
- **後置**: `x~` → 展開

#### 現在の実装
- 中置: `(loop for i from 1 to 10 by 1 collect i)`
- 前置: `&rest x`

#### 確認ポイント
- [ ] `loop` マクロは適切か？（一部変換エラーあり）
- [ ] ステップ指定は正しく処理されるか？
- [x] 連続パラメータの `&rest` は正しいか？
- [ ] 後置展開は実装されているか？

---

### 7. 比較演算子の連鎖

#### 仕様
- `0 < x < 100` → 連鎖比較

#### 現在の実装
- AST構造で連鎖を保持しているが、Common Lispへの変換は？

#### 確認ポイント
- [ ] 連鎖比較が正しく変換されるか？
- [ ] `(and (< 0 x) (< x 100))` のような形になるべきか？

---

### 8. 論理演算子の短絡評価

#### 仕様
- `&` (AND), `|` (OR) は短絡評価

#### 現在の実装
- `(and ...)`, `(or ...)`

#### 確認ポイント
- [x] Common Lispの `and`, `or` は短絡評価なので問題ないはず
- [ ] XOR (`;`) の実装は？（`xor` 関数へのマッピング追加済みだが、CLに標準関数なし）

---

### 9. Get演算子（`'`, `@`）

#### 仕様
- `'` : 左単位元、構造から値を取得
- `@` : 複数の用途（前置input、中置get、後置import）

#### 現在の実装
- 要確認

#### 確認ポイント
- [ ] 実装されているか？
- [ ] Common Lispではどう表現するか？（`getf`, `nth`, `aref`?）

---

### 10. Address演算子（`$`）

#### 仕様
- `$x` → アドレス取得

#### 現在の実装
- 要確認

#### 確認ポイント
- [ ] 実装されているか？
- [ ] Common Lispでのアドレス概念は？

---

## 実装済みの改善機能

1. **予約語回避**
   - Common Lispの予約語（`print`, `list`, `identity` 等）を自動的にリネーム（`print-sign`）
   - エラー `SYMBOL-PACKAGE-LOCKED-ERROR` を回避

2. **エスケープシーケンス処理**
   - 文字列リテラル内の `\n`, `\t`, `\r` 等を正しく処理

3. **ファイル出力オプション**
   - `--output` オプションでBOMなしUTF-8出力をサポート
   - SBCLでのエンコーディングエラーを回避

## 未実装・部分実装の可能性がある機能

- [ ] Range演算子の完全な変換（`1 ~ 10` 等でエラーあり）
- [ ] XOR関数（Common Lisp側での実装が必要）
- [ ] 絶対値（`|...|`）
- [ ] 階乗（後置 `!`）
- [ ] Expand（後置 `~`）
- [ ] ビット演算子（`<<`, `>>`, `||`, `;;`, `&&`, `!!`）
- [ ] @ 演算子の中置・後置用途
- [ ] $ 演算子
- [ ] Get演算子（`'`）

## その他の確認事項

- [x] エラーメッセージは分かりやすいか？
- [x] パーサーの優先順位は仕様と一致しているか？（Lambda修正済み）
- [x] インデントブロックは正しく処理されるか？
- [x] コメント（`` ` ``）は正しく無視されるか？
