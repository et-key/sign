# Sign言語演算子テスト チェックリスト

このドキュメントは、`proto/a5` の現在の実装と Sign言語仕様との違いを確認するためのチェックリストです。

## テストファイル

- **test_operators.sn**: 全演算子を網羅的にテスト
- **test_operators_minimal.sn**: 仕様との違いが疑われる演算子に焦点

## 確認手順

各テストケースについて以下を確認：

```powershell
# 1. S式形式で確認
python main.py test_operators_minimal.sn --format sexp

# 2. Common Lisp形式で確認
python main.py test_operators_minimal.sn --format clisp

# 3. (オプション) AST構造で確認
python main.py test_operators_minimal.sn --format ast
```

## 重点確認項目

### 1. `#` 演算子（Export/Output）

#### 仕様
- **前置**: `#x : 42` → 変数を外部公開（export）
- **中置**: `addr # data` → アドレスにデータを関連付け（出力）

#### 現在の実装
- **前置**: `(export ...)`
- **中置**: `(print ...)`

#### 確認ポイント
- [ ] 前置と中置の区別が正しく解析されているか？
- [ ] 中置の `#` が `print` でなく本来は何に変換されるべきか？
- [ ] `expr # _` は標準出力と解釈して `print` で問題ないか？

---

### 2. `:` 演算子（Define）

#### 仕様
- `x : 42` → 左辺の名前を右辺の値に束縛

#### 現在の実装
- `(defparameter x 42)`

#### 確認ポイント
- [ ] `defparameter` は適切か？（`defvar`, `setf`, `let` との違い）
- [ ] スコープは正しく扱われるか？
- [ ] 再代入の挙動は？

---

### 3. ポイントフリー記法

#### 仕様
- `[+]` → DirectFold（畳み込み）
- `[+ 1]` → 右部分適用（`x -> x + 1`）
- `[5 -]` → 左部分適用（`x -> 5 - x`）
- `[* 2,]` → map関数（各要素に `x -> x * 2` を適用）

#### 現在の実装
```lisp
[+]    → (lambda (lst) (reduce #'+ lst))
[+ 1]  → (lambda (x) (+ x 1))
[5 -]  → (lambda (x) (- 5 x))
[* 2,] → (lambda (lst) (mapcar (lambda (x) (* x 2)) lst))
```

#### 確認ポイント
- [ ] DirectFoldの変換は正しいか？
- [ ] 部分適用の左右の区別は正しいか？
- [ ] map用のカンマ(`,`)の処理は正しいか？
- [ ] Common Lispで実際に動作するか？

---

### 4. `?` 演算子（Lambda）

#### 仕様
- `x y ? x + y` → 2引数のラムダ式

#### 現在の実装
- `(lambda (x y) (+ x y))`

#### 確認ポイント
- [ ] 複数引数の処理は正しいか？
- [ ] カリー化は不要か？（Sign言語の仕様確認）
- [ ] 本体の式の変換は正しいか？

---

### 5. `,` 演算子（Product）

#### 仕様
- `1, 2, 3` → 積（リスト構築）、右結合

#### 現在の実装
- `(list 1 2 3)`

#### 確認ポイント
- [ ] `list` で正しいか？（`cons` ベースの方が良い？）
- [ ] 右結合は実装されているか？
- [ ] ネストした積の処理は？

---

### 6. `~` 演算子（Range/Continuous/Expand）

#### 仕様（文脈依存）
- **中置**: `1 ~ 10` → 範囲リスト
- **中置3項**: `0 ~ 2 ~ 10` → ステップ指定範囲
- **前置**: `~x` → 連続パラメータ（可変長引数）
- **後置**: `x~` → 展開

#### 現在の実装
- 中置: `(loop for i from 1 to 10 by 1 collect i)`
- 前置: `&rest x`

#### 確認ポイント
- [ ] `loop` マクロは適切か？
- [ ] ステップ指定は正しく処理されるか？
- [ ] 連続パラメータの `&rest` は正しいか？
- [ ] 後置展開は実装されているか？

---

### 7. 比較演算子の連鎖

#### 仕様
- `0 < x < 100` → 連鎖比較

#### 現在の実装
- AST構造で連鎖を保持しているが、Common Lispへの変換は？

#### 確認ポイント
- [ ] 連鎖比較が正しく変換されるか？
- [ ] `(and (< 0 x) (< x 100))` のような形になるべきか？

---

### 8. 論理演算子の短絡評価

#### 仕様
- `&` (AND), `|` (OR) は短絡評価

#### 現在の実装
- `(and ...)`, `(or ...)`

#### 確認ポイント
- [ ] Common Lispの `and`, `or` は短絡評価なので問題ないはず
- [ ] XOR (`;`) の実装は？（Common Lispには標準XORがない）

---

### 9. Get演算子（`'`, `@`）

#### 仕様
- `'` : 左単位元、構造から値を取得
- `@` : 複数の用途（前置input、中置get、後置import）

#### 現在の実装
- 要確認

#### 確認ポイント
- [ ] 実装されているか？
- [ ] Common Lispではどう表現するか？（`getf`, `nth`, `aref`?）

---

### 10. Address演算子（`$`）

#### 仕様
- `$x` → アドレス取得

#### 現在の実装
- 要確認

#### 確認ポイント
- [ ] 実装されているか？
- [ ] Common Lispでのアドレス概念は？

---

## 未実装・部分実装の可能性がある機能

- [ ] 絶対値（`|...|`）
- [ ] 階乗（後置 `!`）
- [ ] Expand（後置 `~`）
- [ ] ビット演算子（`<<`, `>>`, `||`, `;;`, `&&`, `!!`）
- [ ] @ 演算子の中置・後置用途
- [ ] $ 演算子
- [ ] Get演算子（`'`）

## その他の確認事項

- [ ] エラーメッセージは分かりやすいか？
- [ ] パーサーの優先順位は仕様と一致しているか？
- [ ] インデントブロックは正しく処理されるか？
- [ ] コメント（`` ` ``）は正しく無視されるか？
