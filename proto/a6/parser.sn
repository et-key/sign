
`parser.sn - Infix / Postfix Parser`

`--- Precedence Table ---`
`Higher number = Higher precedence`
PREC_NONE : 0
PREC_ASSIGN : 1    `:`
PREC_FUNC : 2      `?`
PREC_COMPARE : 3   `=`
PREC_TERM : 4      `+ -`
PREC_FACTOR : 5    `* /`
PREC_POSTFIX : 6   `! (Factorial)`

get_precedence : op ? (
    op = `:` : PREC_ASSIGN
    op = `?` : PREC_FUNC
    op = `=` : PREC_COMPARE
    op = `+` : PREC_TERM
    op = `-` : PREC_TERM
    op = `*` : PREC_FACTOR
    op = `/` : PREC_FACTOR
    op = `!` : PREC_POSTFIX
    PREC_NONE
)

TOK_INDENT : 4
TOK_DEDENT : 5
TOK_BLOCK : 6

`--- Constants ---`
EOF : -1

`parse_block_list : tokens -> [list_of_nodes, rest]`
parse_block_list : tokens ? (
    tokens = _ : [_, _]
    
    token : tokens ' 0
    type : token ' 0
    
    type = TOK_DEDENT : (
        `End of Block`
        rest : tokens ' 1
        [_, rest]
    )
    type = TOK_EOF : (
        `End of Block (Allow EOF to close)`
        [_, tokens]
    )
    
    `Parse Expr`
    res : parse_expr tokens
    node : res ' 0
    rest : res ' 1
    
    `Recurse`
    res2 : parse_block_list rest
    nodes : res2 ' 0
    final_rest : res2 ' 1
    
    `Cons`
    final_nodes : node , nodes , _
    [final_nodes, final_rest]
)

`--- Parser State Handling ---`
`State is just the token stream list`

`parse_atom : tokens -> [node, rest]`
`Parses: Number, or ( Expression )`
parse_atom : tokens ? (
    tokens = _ : [_, _] `Error`
    
    token : tokens ' 0
    rest : tokens ' 1
    
    type : token ' 0
    val : token ' 1
    
    type = TOK_NUM : (
        `Wrap in [TOK_NUM, val]`
        node : TOK_NUM , val , _
        tokens_after_num : rest
        
        `Check Postfix Loop`
        parse_postfix_loop node tokens_after_num
    )
    
    type = TOK_ID : (
        `Just return val (assume number/charcode for now)`
        `For CodeGen to work, it needs to print this.`
        `If val is CharCode, we need to print char.`
        node : val
        [node, rest]
    )
    
    type = TOK_INDENT : (
        `Start of Block`
        `Parse List`
        res : parse_block_list rest
        nodes : res ' 0
        rest_after_block : res ' 1
        
        `Wrap in TOK_BLOCK`
        node : TOK_BLOCK , nodes , _
        [node, rest_after_block]
    )
    
    `TODO: Handle Parens`
    
    `Error/Skip`
    [_, rest]
)

`parse_postfix_loop : lhs, tokens -> [node, rest]`
parse_postfix_loop : lhs tokens ? (
    tokens = _ : [lhs, _]
    
    token : tokens ' 0
    type : token ' 0
    val : token ' 1
    
    `Check if Postfix Op`
    is_postfix : val = `!`
    
    is_postfix = _ : [lhs, tokens] `False`
    
    `Consume`
    rest : tokens ' 1
    
    `Build Unary Node: [Op, LHS]`
    `Correct List: Op, LHS, _`
    new_lhs : val , lhs , _
    
    `Loop`
    parse_postfix_loop new_lhs rest
)

`parse_expr_climb : lhs, min_prec, tokens -> [node, rest]`
parse_expr_climb : lhs min_prec tokens ? (
    tokens = _ : [lhs, _]
    
    token : tokens ' 0
    type : token ' 0
    
    `Check if it is an operator`
    type = TOK_OP : (
        op : token ' 1
        prec : get_precedence op
        
        `Check Precedence`
        should_climb : prec >= min_prec
        
        should_climb = _ : [lhs, tokens] `False (Unit) -> Return LHS`
        
        `Consume Op`
        rest : tokens ' 1
        
        `Parse RHS`
        next_prec : prec + 1
        
        `Parse RHS Atom`
        res_rhs : parse_atom rest
        rhs_atom : res_rhs ' 0
        rest_after_atom : res_rhs ' 1
        
        `Climb RHS`
        res_tree : parse_expr_climb rhs_atom next_prec rest_after_atom
        rhs : res_tree ' 0
        final_rest : res_tree ' 1
        
        `Build Node: [Op, LHS, RHS]`
        `Correct List: Op, LHS, RHS, _`
        new_lhs : op , lhs , rhs , _
        
        `Loop / Continue Climbing`
        parse_expr_climb new_lhs min_prec final_rest
    )
    
    `Not an op, return lhs`
    [lhs, tokens]
)

`parse_expr : tokens -> [node, rest]`
parse_expr : tokens ? (
    `Parse Left`
    res : parse_atom tokens
    lhs : res ' 0
    rest : res ' 1
    
    `Climb`
    parse_expr_climb lhs PREC_NONE rest
)
    
`parse_block : tokens -> [ast_list, rest]`
parse_block : tokens ? (
    tokens = _ : [_, _]
    
    `Check EOF`
    token : tokens ' 0
    type : token ' 0
    type = TOK_EOF : [_, tokens]
    
    `Parse Expr`
    res : parse_expr tokens
    node : res ' 0
    rest : res ' 1
    
    `Recurse`
    res2 : parse_block rest
    nodes : res2 ' 0
    final_rest : res2 ' 1
    
    `Cons result`
    final_nodes : node , nodes
    [final_nodes, final_rest]
)
