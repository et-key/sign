`
  Sign Self-Hosting Compiler
  Compiles AST to AArch64 Assembly
`

`--- String Helpers ---`
#str_len : s ?
    c : @s
    c = 0 : 0
    1 + str_len (s + 1)

#str_cpy : dest src ?
    c : @src
    c = 0 : (
        dest # 0
        dest
    )
    dest # c
    str_cpy (dest + 1) (src + 1)

#str_cat : s1 s2 ?
    len1 : str_len s1
    len2 : str_len s2
    new_s : alloc (len1 + len2 + 1)
    
    end_s1 : str_cpy new_s s1
    ; end_s1 points to null terminator of first copy
    ; str_cpy returns pointer to null terminator? 
    ; My impl above returns `dest` (ptr to 0).
    ; So we can chain.
    
    str_cpy end_s1 s2
    new_s

#int_to_str : n ?
    n = 0 : `0`
    n < 0 : str_cat `-` (int_to_str_rec (0 - n))
    int_to_str_rec n

#int_to_str_rec : n ?
    n = 0 : ``
    str : int_to_str_rec (n / 10)
    digit : (n % 10) + 48
    
    ; Append digit char to string
    ; Since we don't have mutable buffer easily in functional style,
    ; we might recurse differently or stick to str_cat.
    ; str_cat is expensive (allocs).
    ; Optimization: Use a local buffer or list then convert?
    ; For now, use str_cat for correctness.
    
    char_str : alloc 2
    char_str # digit
    (char_str + 1) # 0
    
    str_cat str char_str

`--- Compiler ---`
#compile_program : ast ?
    ast = 0 : ``
    
    expr : @ast
    
    ; Check if expr is definition (infix :)
    type : @expr
    type = ast_infix : (
        op : @(expr + 8)
        streq op `:` : (
            code : compile_global_def expr
            rest : compile_program (tail ast)
            str_cat code rest
        )
    )
    
    ; Skip non-definitions for now
    compile_program (tail ast)

#compile_global_def : node ?
    lhs : @(node + 16)
    rhs : @(node + 24)
    
    ; lhs should be ast_id for function name
    name : @(lhs + 8)
    
    ; rhs should be ast_infix ? for function body
    rhs_type : @rhs
    rhs_type = ast_infix : (
        op : @(rhs + 8)
        streq op `?` : (
            compile_function_def name rhs
        )
    )
    
    `; TODO: Global variable def\n`

#compile_function_def : name node ?
    ; node is (infix ? args body)
    args_node : @(node + 16)
    body_node : @(node + 24)
    
    label : str_cat `_` name
    label_colon : str_cat label `:\n`
    
    ; Generate end label for recursive blocks to jump to
    end_label : str_cat label `_end`
    
    body_code : compile_expr body_node end_label
    
    ret_label : str_cat end_label `:\n    ret\n`
    
    str_cat label_colon (str_cat body_code ret_label)

#compile_expr : node end_label ?
    node = 0 : ``
    type : @node
    val : @(node + 8)
    
    type = ast_num : (
        s_val : int_to_str val
        str_cat `    mov x0, #` (str_cat s_val `\n`)
    )
    
    type = ast_block : (
        compile_block val end_label
    )
    
    type = ast_infix : (
        compile_infix val end_label
    )
    
    type = ast_apply : (
        compile_apply val
    )
    
    type = ast_id : (
        compile_id val
    )
    
    ``

#compile_id : name ?
    label : str_cat `_` name
    
    load_env : `    adr x0, sign_id\n`
    load_code : str_cat `    adr x1, ` (str_cat label `\n`)
    make_cons : `    bl _cons\n`
    
    str_cat load_env (str_cat load_code make_cons)

#compile_apply : node ?
    func : @(node + 8)
    arg : @(node + 16)
    
    code_f : compile_expr func 0
    code_a : compile_expr arg 0
    
    push_f : `    str x0, [sp, #-16]!\n`
    
    pop_f : `    ldr x9, [sp], #16\n`
    load_code : `    ldr x10, [x9]\n`
    load_env : `    ldr x9, [x9, #8]\n`
    call : `    blr x10\n`
    
    str_cat code_f (str_cat push_f (str_cat code_a (str_cat pop_f (str_cat load_code (str_cat load_env call)))))

#compile_infix : node end_label ?
    op : @(node + 8)
    lhs : @(node + 16)
    rhs : @(node + 24)
    
    is_match : streq op `:`
    
    is_match : (
        ; Match Case: cond : val
        cond_code : compile_expr lhs end_label
        val_code : compile_expr rhs end_label
        
        check : `    cmp x0, #0\n    beq 1f\n`
        docase : str_cat val_code (str_cat `    b ` (str_cat end_label `\n`))
        next : `1:\n`
        
        str_cat cond_code (str_cat check (str_cat docase next))
    )
    
    is_match = 0 : (
        code_l : compile_expr lhs end_label
        code_r : compile_expr rhs end_label
        
        push_x0 : `    str x0, [sp, #-16]!\n`
        pop_x1 : `    ldr x1, [sp], #16\n`
        
        op_code : emit_op op
        
        str_cat code_l (str_cat push_x0 (str_cat code_r (str_cat pop_x1 op_code)))
    )

#emit_op : op ?
    streq op `+` : `    add x0, x1, x0\n`
    streq op `-` : `    sub x0, x1, x0\n`
    streq op `*` : `    mul x0, x1, x0\n`
    streq op `|` : `    orr x0, x1, x0\n`
    `    ; Unknown Op\n`

#compile_block : exprs end_label ?
    exprs = 0 : ``
    expr : @exprs
    code : compile_expr expr end_label
    rest : compile_block (tail exprs) end_label
    str_cat code rest
