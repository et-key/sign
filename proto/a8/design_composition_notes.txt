
// Optimized Apply: Handles Composition
// x0: Function Closure (or Label?)
// x1: Argument

_apply:
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    // Check if Argument (x1) is a Closure?
    // How to distinguish Closure from Number?
    // Numbers are raw values. Closures are pointers (likely > 4096).
    // But pointers can be matched by chance?
    // Sign uses NaN boxing or Tagging? 
    // Current Proto: All numbers are double (f64). Pointers are ... passed as i64?
    // Wait, everything is passed in x0/x1.
    // If x1 is a large integer (pointer), it might be a closure.
    // If x1 is a small float? 
    // This is fragile without a Type System or Tagging.
    // User requested "Sign philosophy".
    // Does Sign assume everything is a function?
    
    // Alternative: Compiler knows the types?
    // No, `[+ 1]` takes `x`. If `x` is polymorphic, we rely on runtime.
    
    // Let's assume for this Prototype:
    // If x1 (Arg) is a pointer to the heap (Closure), we Compose.
    // If not, we Execute.
    // But `1` is 1. `[* 2]` is a pointer.
    
    // We need usage convention.
    // For now, let's implement `Operator Section` simply returning a lambda.
    // And `apply` logic:
    // We already generate `blr` in `compiler.js`.
    // I will replace the inline `blr` sequence with a call to `_apply` helper.
    
    // Implementation of _apply:
    // x0: Func (Closure Pointer)
    // x1: Arg
    
    // Unpack x0
    str x0, [sp, #-16]! // Save Func
    str x1, [sp, #-16]! // Save Arg
    
    // Check if Arg (x1) looks like a closure?
    // We need a robust way. 
    // For now, let's assume if it is in Heap range?
    // Or maybe we add a 'tag' word to closures?
    // Closure: [FunctionAddress, EnvPointer]
    // Let's Add Tag: [TAG, FunctionAddress, EnvPointer]
    // TAG = 0xCL05URE
    
    // Proceed with assuming simple pointer check or Always Compose if x1 is a function?
    // But `map` takes a function. `map f list`.
    // `f` is a function. `list` is data.
    // `map` should NOT be composed with `f`. `map` should be APPLIED to `f`.
    // So `map f` returns a Partial Application (Closure).
    
    // The user's example: `[+ 1] [* 2] 3`.
    // `[+ 1]` is applied to `[* 2]`.
    // Functional composition: `f(g)` -> result.
    // If `f` expects a number, but gets a function, normally Type Error.
    // But Sign says "Compose".
    
    // So if `f` is a "Math Operator" (expects Number), and gets "Function", it Composes.
    // If `f` is "Higher Order Function" (expects Function), and gets "Function", it Applies.
    // Ambiguity!
    // `map` expects Function. `map f` -> Apply.
    // `+ 1` expects Number. `(+ 1) f` -> Compose.
    
    // We need Type Info on Functions?
    // Or `[+ 1]` is special?
    // `Parser` generated `x ? x + 1`. This effectively says "Expects x".
    // If x is function, `function + 1` should be `Compose(function, 1)` ? No.
    
    // Maybe `[+ 1]` is NOT `x ? x + 1`.
    // Maybe `[+ 1]` returns a `PrimitiveOperatorState`.
    
    // User strategy: "Left to Right Procedurally".
    // `3` -> `[* 2]` -> `6` -> `[+ 1]` -> `7` ?
    // User said: `[+ 1] [* 2] 3 = 8`.
    // `3` -> `[+ 1]` -> `4` -> `[* 2]` -> `8`.
    // This is `( * 2 ) ( ( + 1 ) ( 3 ) )`.
    // So `g( f(x) )` where f=`[+ 1]`, g=`[* 2]`.
    // In syntax `f g x`.
    // `(f g) x` ?
    // If `f g` -> `Composition g . f` (Apply f then g).
    // This matches "Left to Right".
    
    // So `_apply(f, g)` where f, g are functions:
    // Returns `x ? g(f(x))`.
    
    // We need `_apply` to detect if `g` is a function.
    // If `map` is a function. `map f`.
    // `map` (f).
    // If `map` logic is `x ? ...`, and it gets `f`, it executes.
    // `map` implementation consumes `f`.
    // `[+ 1]` implementation attempts to ADD `1` to `f`.
    // `f + 1` -> Failure.
    
    // So we rely on `[+ 1]` implementation to Fail/Fallback?
    // Or we inject checks in `+` operator?
    // If `+` sees a function, return Composition?
    
    // Let's try to handle it in `_apply` wrapper ONLY if `f` is generic?
    // No, `_apply` calls `f`'s code.
    // `f` has control.
    
    // Maybe we just check in `_apply`:
    // If `f` and `g` are both closures...
    // But `map` (f) is valid application.
    // We can't auto-compose `map` and `f`.
    
    // User said: "map f list". `map` takes `f`.
    // User said: `[+ 1] [* 2]`.
    // Difference?
    // `map` is defined to take a function.
    // `[+ 1]` is defined to takes a number.
    
    // Checking `test_section.ast.json`:
    // `[+ 1]` -> `x ? x + 1`.
    // If I pass a closure `g` to it. `g + 1`.
    // I need `+` implementation (in assembly) to handle closure?
    // `add x0, x1`.
    // If x0 is closure pointer (huge integer), adding 1 makes garbage pointer.
    
    // PROPOSAL:
    // Modify `compiler.js` `compileExpr` for Binary Ops (`+`, `-`, etc).
    // Instead of raw `add`, call `_add_wrapper` or check types?
    // Or simply: The User's "Composition" is a feature of `apply` syntax?
    // But `map f` is also `apply`.
    
    // Maybe `[+ 1]` generates a special "Operator Section Closure" which has a "Composable" flag?
    
    // Alternative Interpretation:
    // The user said "Function composition has higher precedence".
    // Maybe `f g` is parsed as composition if they are "simple" functions?
    // No.
    
    // "Left to Right Execution"
    // `x |> f |> g` ?
    // Sign syntax is `f x`.
    // User: `[+ 1] [* 2] 3`.
    // This looks like `(Compose [+ 1] [* 2]) 3`.
    
    // Let's implement `_apply` to check if `f` handles composition?
    // OR: Just implement `+`, `*` etc to support composition at runtime.
    // If `lhs` of `+` is function... wait `[+ 1]` -> `arg + 1`. `arg` is lhs.
    // If `arg` is function, `function + 1`.
    // Make `+` return `x ? function(x) + 1` ?
    // `(f + 1) (x)` -> `f(x) + 1`.
    // This is "Lifting".
    
    // But User wants `[+ 1] [* 2] 3` -> `8`.
    // `(f g) 3`.
    // `f` is `+ 1`. `g` is `* 2`.
    // `f(g)`.
    // If `f` lifts `g`: `g + 1`.
    // `(g + 1) (3) = g(3) + 1 = (3 * 2) + 1 = 7`.
    // User wants 8.
    // `3` -> `[+ 1]` -> `4` -> `[* 2]` -> `8`.
    // So `f(g)` resulted in `g . f` (Apply f then g).
    // `Compose(f, g) = g . f`.
    
    // So if I pass `g` to `f`, and f is `[+ 1]`, `f` should return `Compose(f_inner, g)`?
    
    // Let's look at `compiler.js` `compileApply`. It generates `blr`.
    // I will replace `blr` with `bl _sign_apply`.
    // `_sign_apply` will:
    // 1. Execute `f(g)` normally.
    // 2. If `f(g)` returns valid result, done.
    // 3. If `f` crashes? No.
    
    // Hack:
    // If `f` and `g` are closures.
    // Return `Compose(f, g)`.
    // But `map f`... `map` returns a function (waiting for list). `f` is function.
    // So `map f` would become `Compose(map, f)` ? 
    // `(Compose(map, f)) (list)`.
    // `f( map(list) )` ? No.
    
    // The distinction is: `map` *consumes* the function. `[+ 1]` *cannot* consume a function (arithmetically).
    // So: If `f` consumes `g`, done.
    // If `f` cannot consume `g` (Type mismatch?), then Compose?
    
    // Easier path:
    // `[+ 1]` is syntactic sugar for `Compose(+ 1)`.
    // No, `test_section.sn` parsed it as lambda.
   
    // Let's implement `_sign_apply` to ALWAYS compose if `Arg` is closure?
    // And `map` is written such that it *expects* `Arg` to be closure and handles it manually?
    // `map` implementation: `map : f list ? ...`
    // When `map f` runs. `map` is closure. `f` is closure.
    // `_sign_apply(map, f)`.
    // If it returns `Compose(map, f)`, then `map` logic is never run!
    // Breaking `map`.
    
    // Conclusion: We can't generic compose.
    
    // Re-read user: "map f list ? [@f,] list".
    // "map [* 2] 1 2 3".
    // Here `map` is applied to `[* 2]`. It works.
    // `[+ 1] [* 2] 3`.
    // Here `[+ 1]` is applied to `[* 2]`.
    // `[+ 1]` is `x ? x + 1`.
    // `[* 2]` is `y ? y * 2`.
    // `([* 2]) + 1`. 
    // Function + Number.
    // Transform this to Composition?
    
    // YES. If `+` encounters a function, it should return a composed function.
    // `f + 1` -> `x ? f(x) + 1`.
    // Wait, this is `7`.
    
    // User wants: `g(f(x))`.
    // `f` is applied to `g`.
    // `f(g)`.
    // If `f` sees `g`...
    // Maybe `[+ 1]` isn't `x ? x + 1`.
    // Maybe `[+ 1]` is `Input ? (Input) + 1`.
    // If `Input` is Function, `Compose(Input, (+ 1))`.
    // If `Input` is Number, `Input + 1`.
    
    // YES!
    // I need to modify `[+ 1]` expansion in `parser.js`.
    // Instead of `x ? x + 1`,
    // `x ? (typeof x == func) ? Compose(x, $self_logic) : x + 1`.
    
    // This works!
    // `[+ 1]` applied to `[* 2]`.
    // `[* 2]` is func.
    // Returns `Compose([* 2], [+ 1])`. (Inner then Outer? Wait).
    // `Compose(g, f)`.
    // Applied to `3`.
    // `Compose(g, f)(3)`.
    // `f( g(3) )`.
    // `f` is `[+ 1]`. `g` is `[* 2]`.
    // `[+ 1]( [* 2](3) )`.
    // `[+ 1]( 6 )` -> `7`.
    
    // Still 7!
    // User wants 8.
    // `3` -> `[+ 1]` (4) -> `[* 2]` (8).
    // `g(f(x))`.
    // To get `g(f(x))`, I need `Compose(f, g)`.
    // `f(g)` needs to return `Compose(f, g)`.
    
    // So `[+ 1]` applied to `[* 2]`.
    // `x` is `[* 2]`.
    // logic is `+ 1`.
    // Return `Compose(x, (+ 1))` ? No must be `Compose((+ 1), x)`.
    // `Compose(f, g)`.
    
    // So `parser.js` should expand `[+ 1]` to:
    // `x ? (is_func x) ? Compose(this_logic, x) : x + 1`.
    // `this_logic` is `v ? v + 1`.
    
    // This seems robust.
    
    // Implementation Plan:
    // 1. Add `_compose` runtime (Cons two functions).
    // 2. Add `_is_func` check (Tagging or Range check).
    // 3. Modify `parser.js` to emit this complex logic for Sections?
    //    Or keep `parser.js` clean and handle `+` runtime?
    //    If `+` operator checks for function, it applies to `1 + f` too.
    //    `1 + [* 2]`. `x ? 1 + (x*2)`. (Lifting).
    //    User wants `Sequencing / Piping`.
    
    //    Let's modify `parser.js` to generate a call to `_section_wrapper(op, arg)`.
    
    //    Actually, simple solution:
    //    User said "Function composition has HIGHER precedence".
    //    Maybe `[+ 1]` is NOT applied to `[* 2]` standardly?
    //    `[+ 1] [* 2]` -> `Compose([+ 1], [* 2])`.
    //    Implicit composition operator?
    //    Juxtaposition `f g` is Composition? AND Application?
    //    If `g` is "Expression" -> Application.
    //    If `g` is "Function" -> Composition.
    
    // This is valid.
    // `map f`. `f` is function.
    // `Compose(map, f)`.
    // `(Compose(map, f)) (list)`.
    // `f( map(list) )`.
    // If `map(list)` returns a list... `f(list)`.
    // `map` isn't `list -> list`. `map` is `f -> list -> list`.
    // `map` takes `f`.
    // If we compose: `map` isn't run. `f` waits for result of `map`. 
    // `map` waits for list.
    // `map` returns `list -> list`.
    // `f( map_part_applied(list) )`.
    // Not what we want.
    
    // User said: `map f list` -> `Apply`.
    // `[+ 1] [* 2]` -> `Compose`.
    
    // The difference is `map` Explicitly wants a function.
    // `[+ 1]` Explicitly wants a number.
    
    // Implementation:
    // `parseBlock` generates `x ? x + 1`.
    // WE ADD RUNTIME CHECK in `_apply`? 
    // No, `_apply` calls the function.
    // The function `[+ 1]` is called with `[* 2]`.
    // It executes `x + 1`.
    // `[* 2] + 1` -> Runtime `_add` handler.
    // `_add` sees Function + Number.
    // Returns `Compose`?
    
    // If `_add(f, 1)` returns `Compose(f, (+ 1))` ?
    // `f + 1` -> `x ? f(x) + 1`.
    
    // Let's go back to 8 vs 7.
    // 7 is `f(x) + 1`.
    // 8 is `(x+1) * 2` (if `[* 2]` is outer).
    // `[+ 1] [* 2]`. `f g`.
    // `f = (+ 1)`. `g = (* 2)`.
    // If `f g` -> `Compose(f, g)`.
    // `Compose(f, g)(3) = g( f(3) )`.
    // `g( 3+1 )` = `g(4)` = `4*2` = 8.
    
    // CORRECT.
    // So `f g` must be `Compose(f, g)` (Apply f then g).
    
    // When does `f g` mean Apply?
    // When `g` is NOT a function (composed into f pipeline).
    // Or when `f` explicitly consumes `g`.
    
    // But how to distinguish?
    // `map f`. `map` needs to consume `f`.
    // If `map f` becomes `Compose(map, f)`.
    // `Compose(map, f) (list)`.
    // `f( map(list) )`.
    // `map(list)` -> failure (map needs 2 args).
    
    // Unless `map` is curried? `map f`. Returns `list ? ...`.
    // `f( map_closure )`.
    // `f` is `[* 2]`. 
    // `map_closure * 2`. Failure.
    
    // So `map f` MUST be Application.
    
    // What distinguishes `map` from `[+ 1]`?
    // `map` consumes function.
    // `[+ 1]` consumes number.
    
    // If we assume "Juxtaposition is Composition by default", `map` breaks.
    // If we assume "Juxtaposition is Application by default", `[+ 1] f` breaks (type error).
    
    // HYBRID:
    // Default to Application.
    // `f(g)`.
    // If `f` handles `g`, good. (`map` handles `f`).
    // If `f` crashes (Type Error), catch and Switch to Composition?
    // Too slow/complex.
    
    // OPTIMIZED HYBRID:
    // `_apply(f, g)`.
    // If `f` takes `Number` (known primitive op like `+`) and `g` is `Function`.
    // Then `Compose`.
    
    // Steps for now:
    // 1. Implement `_apply` assembly.
    // 2. Modify `compiler.js` `compileApply` to call `_apply`.
    // 3. In `_apply`, check if it's a `Primitives`. (How?)
    //    Maybe `[+ 1]` returns a special `PrimitiveFunc`?
    
    // SIMPLE START:
    // Just implement `[+ 1]` as `x ? x + 1`.
    // And implement `+` runtime to handle function?
    // No, `f g` -> `f` applied to `g`.
    // `[+ 1]` applied to `[* 2]`.
    // `[* 2] + 1` executed.
    // `add` operator sees Function.
    // Returns `Compose([* 2], (+ 1))`.
    // -> `f(g(x))` -> `(x*2) + 1` -> 7.
    
    // Still getting 7.
    // To get 8, we need `Compose((+ 1), [* 2])`.
    // `g(f(x))`.
    // `[+ 1]` applied to `[* 2]` -> `Compose([+ 1], [* 2])`.
    // This means `+` operator must return `Compose(lhs, rhs)` ??? No.
    
    // `[+ 1]` receives `[* 2]` as argument `x`.
    // It runs `x + 1`.
    // We need this to evaluate to `Compose([+ 1], x)`.
    // But `[+ 1]` IS the function.
    // `x` is `[* 2]`.
    // `Compose(Self, x)`.
    
    // How can `x + 1` result in `Compose(Self, x)`?
    // It can't.
    
    // So the parser/logic `x ? x + 1` is wrong for this goal.
    // `[+ 1]` must be `x ? Compose(..., x)` if x is func.
    // `x ? (is_func x) ? Compose(SECTION_SELF, x) : x + 1`.
    // SECTION_SELF = `v ? v + 1`.
    
    // YES.
    // I will implement this logic in `parser.js` transformation.
    // But I need `Compose` and `is_func` available in runtime.
    
    // Let's create `_compose` and `_is_func` in `compiler.js` assembly.
