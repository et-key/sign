`
  Sign Pure Functional Parser
  
  Philosophy:
  - No global state
  - No local bindings (:)
  - Logic: tokens -> [ast_node, remaining_tokens]
`

`--- AST Constants ---`
ast_unit : 0
ast_num : 1
ast_id : 2
ast_str : 3
ast_op : 4
ast_def : 5
ast_apply : 6
ast_block : 7
ast_infix : 8
ast_prefix : 9
ast_postfix : 10
ast_lambda : 11
ast_char : 12

`--- Token Constants (Match Lexer) ---`
tok_eof : -1
tok_id : 1
tok_num : 2
tok_str : 3
tok_op : 4
tok_punc : 5
tok_sep : 6
tok_unit : 0

`--- Helper: Get Token Info ---`
#tok_type : tok ? @tok
#tok_val : tok ? @(tok + 8)

`--- String Comparison (Pure) ---`
#streq : s1 s2 ?
    (c1 ? 
        (c2 ?
            c1 != c2 : 0
            c1 = 0 : 1
            streq (s1 + 1) (s2 + 1)
        ) (@s2)
    ) (@s1)

`--- Precedence Table (Pure) ---`
#get_prec : op_str ?
    streq op_str "+" : 15
    streq op_str "-" : 15
    streq op_str "*" : 16
    streq op_str "/" : 16
    streq op_str "%" : 16
    streq op_str ":" : 2
    streq op_str "?" : 5
    streq op_str "," : 6
    streq op_str "=" : 14
    streq op_str "==" : 14
    streq op_str "<" : 14
    streq op_str ">" : 14
    streq op_str "<=" : 14
    streq op_str ">=" : 14
    streq op_str "!=" : 14
    0

#is_right_assoc : op_str ?
    streq op_str ":" : 1
    streq op_str "?" : 1
    streq op_str "," : 1
    streq op_str "^" : 1
    0

`--- Parser Helpers ---`

`peek : tokens -> token`
#peek : tokens ? 
    tokens = 0 : cons tok_eof 0
    head tokens

`next : tokens -> rest`
#next : tokens ?
    tokens = 0 : 0
    tail tokens

`expect : tokens type -> [bool, tokens]`
#expect : tokens type ?
    (tok ? 
        (tok_t ?
            tok_t = type : cons 1 (next tokens)
            cons 0 tokens
        ) (tok_type tok)
    ) (peek tokens)

`--- Core Parser Logic ---`

`parse_program : tokens -> [ast_block, rest]`
#parse_program : tokens ?
    (res ? 
         cons (cons ast_block (head res)) (cons (head (tail res)) 0)
    ) (parse_stmts tokens)

`parse_stmts : tokens -> [list<node>, rest]`
#parse_stmts : tokens ?
    (tok ?
        (type ?
            type = tok_eof : cons 0 (cons tokens 0)
            
            type = tok_sep : parse_stmts (next tokens)
            
            `Parse Expression`
            (res ?
                (expr ?
                     (rest ?
                         (res2 ?
                             cons (cons expr (head res2)) (cons (head (tail res2)) 0)
                         ) (parse_stmts rest)
                     ) (head (tail res))
                ) (head res)
            ) (parse_expr tokens 0)
            
        ) (tok_type tok)
    ) (peek tokens)

`parse_block : tokens -> [ast_block, rest]`
#parse_block : tokens ?
    `TODO: Block logic, Section logic`
    parse_program tokens `Temporary: Treat block same as program for now`

`parse_expr : tokens min_prec -> [node, rest]`
#parse_expr : tokens min_prec ?
    (res_lhs ?
        (lhs ?
            (rest_1 ? 
                _parse_expr_loop lhs rest_1 min_prec
            ) (head (tail res_lhs))
        ) (head res_lhs)
    ) (parse_primary tokens)

`_parse_expr_loop : lhs tokens min_prec -> [node, rest]`
#_parse_expr_loop : lhs tokens min_prec ?
    (tok ?
        (type ?
            `Check for Apply (Implicit)`
            (can_start_expr type) : (
                `Apply: lhs next_expr`
                (res_rhs ? 
                     (rhs ?
                         (rest_rhs ?
                             (new_lhs ? 
                                  _parse_expr_loop new_lhs rest_rhs min_prec
                             ) (cons ast_apply (cons lhs (cons rhs 0)))
                         ) (head (tail res_rhs))
                     ) (head res_rhs)
                ) (parse_expr tokens 6) 
                `6 is Apply Precedence`
            )
            
            type != tok_op : cons lhs (cons tokens 0)
            
            (op_str ?
                (prec ?
                    prec < min_prec : cons lhs (cons tokens 0)
                    
                    (next_tokens ?
                        (next_min_prec ?
                            (res_rhs ?
                                (rhs ?
                                    (rest_rhs ?
                                        (new_lhs ?
                                            _parse_expr_loop new_lhs rest_rhs min_prec
                                        ) (cons ast_infix (cons op_str (cons lhs (cons rhs 0))))
                                    ) (head (tail res_rhs))
                                ) (head res_rhs)
                            ) (parse_expr next_tokens next_min_prec)
                        ) ((is_right_assoc op_str) ? prec (prec + 1))
                    ) (next tokens)
                    
                ) (get_prec op_str)
            ) (tok_val tok)
            
        ) (tok_type tok)
    ) (peek tokens)

#can_start_expr : type ?
    type = tok_id : 1
    type = tok_num : 1
    type = tok_str : 1
    type = tok_punc : 1 `(`
    0

#is_prefix_op : op ?
    streq op "!" : 1
    streq op "#" : 1
    streq op "$" : 1
    streq op "@" : 1 
    0

`parse_primary : tokens -> [node, rest]`
#parse_primary : tokens ?
    (tok ?
        (type ?
            (tokens_next ? 
                type = tok_num : (
                    (val ? 
                        cons (cons ast_num (cons val 0)) (cons tokens_next 0)
                    ) (tok_val tok)
                )
                
                type = tok_id : (
                    (val ?
                        cons (cons ast_id (cons val 0)) (cons tokens_next 0)
                    ) (tok_val tok)
                )
                
                type = tok_str : (
                     (val ?
                         cons (cons ast_str (cons val 0)) (cons tokens_next 0)
                     ) (tok_val tok)
                )

                type = tok_op : (
                    (op ?
                         is_prefix_op op : (
                             `Prefix Ops`
                             (res ? 
                                 cons (cons ast_prefix (cons op (cons (head res) 0))) (cons (head (tail res)) 0)
                             ) (parse_expr tokens_next 20 `Prefix Prec`)
                         )
                         
                         `Standalone Operator (for Sections)`
                         cons (cons ast_op (cons op 0)) (cons tokens_next 0)
                         
                    ) (tok_val tok)
                )
                
                type = tok_punc : (
                     (val ?
                         val = 91 : (
                             `LBRACKET -> Block (Potential Section)`
                             parse_block tokens_next
                         )
                         
                         val = 40 : (
                             `LPAREN -> Group (No Section)`
                             (res ? 
                                 (exprs ?
                                     (rest ?
                                         `Expect RPAREN (val 41)`
                                         (tok_r ?
                                             `Consume RPAREN`
                                             `Check if single expr for paren group`
                                             (is_single ? 
                                                 cons (head exprs) (cons (next rest) 0)
                                                 cons (cons ast_block (cons exprs 0)) (cons (next rest) 0)
                                             ) (is_null (tail exprs))
                                         ) (peek rest)
                                     ) (head (tail res))
                                 ) (head res)
                             ) (parse_stmts tokens_next)
                         )
                         `Default Unknown`
                         cons (cons ast_unit 0) (cons tokens_next 0)
                     ) (tok_val tok)
                )
                
                `Unknown`
                cons (cons ast_unit 0) (cons tokens_next 0)
                
            ) (next tokens)
        ) (tok_type tok)
    ) (peek tokens)

`parse_block : tokens -> [node, rest]`
#parse_block : tokens ?
    (res ?
        (exprs ?
            (rest ?
                `Expect RBRACKET (93)`
                 (tok_r ?
                     `Consume RBRACKET`
                     (node ? 
                          cons node (cons (next rest) 0)
                     ) (transform_section exprs)
                 ) (peek rest)
            ) (head (tail res))
        ) (head res)
    ) (parse_stmts tokens)

#is_null : list ?
    list = 0 : 1
    0

`--- AST Constructors ---`
#make_node : type val ?
    cons type (cons val 0)

#make_num : val ? make_node ast_num val
#make_id : val ? make_node ast_id val
#make_op : val ? make_node ast_op val
#make_str : val ? make_node ast_str val

#make_infix : op lhs rhs ?
    cons ast_infix (cons op (cons lhs (cons rhs 0)))

#make_lambda : params body ?
    make_infix "?" params body

`transform_section : exprs -> node`
#transform_section : exprs ?
    (len ?
        (p1 ? (p2 ? 
            len = 1 : (
                 (e1 ?
                     (type ?
                         type = ast_op : (
                             `[op] -> (p1 p2 ? p1 op p2)`
                             (op_str ? 
                                 make_lambda
                                     (make_infix "," p1 p2)
                                     (make_infix op_str p1 p2)
                             ) (tok_val (head (tail e1))) `e1=(type val). val=op`
                         )
                         cons ast_block (cons exprs 0)
                     ) (head e1)
                 ) (head exprs)
            )
            
            len = 2 : (
                 (e1 ? 
                      (e2 ?
                          (t1 ? 
                               (t2 ?
                                    t1 = ast_op : (
                                        `[op expr] -> (p1 ? p1 op expr)`
                                        (op_str ?
                                             make_lambda p1 (make_infix op_str p1 e2)
                                        ) (tok_val (head (tail e1)))
                                    )
                                    t2 = ast_op : (
                                        `[expr op] -> (p1 ? expr op p1)`
                                        (op_str ?
                                             make_lambda p1 (make_infix op_str e1 p1)
                                        ) (tok_val (head (tail e2)))
                                    )
                                    cons ast_block (cons exprs 0)
                               ) (head e2)
                          ) (head e1)
                      ) (head (tail exprs))
                 ) (head exprs)
            )
            
            cons ast_block (cons exprs 0)
        ) (make_id "$2") ) (make_id "$1")
    ) (length exprs)

