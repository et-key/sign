`--- Runtime IO Helpers (From combined_lexer_test.sn) ---`

#print_char : c ?
    buf : cons c 0
    sys_write 1 buf 1

#print_str : str ?
    len : (len_loop ?
        p : $1
        cnt : $2
        char : @p
        char = 0 : cnt
        len_loop (p + 1) (cnt + 1)
    ) str 0
    sys_write 1 str len

#print_num : n ?
    n = 0 : (
        print_char 48
        0
    )
    n < 0 : (
        print_char 45
        print_num (0 - n)
        0
    )
    _print_num_rec n

#_print_num_rec : n ?
    n = 0 : 0
    _print_num_rec (n / 10)
    print_char (48 + (n % 10))

#print_str_ln : str ?
    print_str str
    print_char 10

#print_list_str : list ?
    list = 0 : 0
    print_str (head list)
    print_list_str (tail list)

`--- Allocation (Assuming bare runtime provides sys_brk) ---`
`Note: combined_lexer_test.sn had heap management. We need it here.`

heap_start : sys_brk 0
heap_end : sys_brk (heap_start + 1048576)
heap_addr : heap_start

#alloc : size ?
    $curr # heap_addr
    $heap_addr # curr + size
    curr

#cons : head tail ?
    $addr : alloc 16
    addr # head
    (addr + 8) # tail
    addr

#head : list ?
    @(list)

#tail : list ?
    @(list + 8)

#nth : list index ?
    index <= 0 : head list
    nth (tail list) (index - 1)
`
  Sign Pure Functional Lexer
  (Strict No-Local-Binding Version)
`

`--- Token Constants ---`
tok_eof : -1
tok_id : 1
tok_num : 2
tok_str : 3
tok_op : 4
tok_punc : 5
tok_sep : 6
tok_unit : 0

`--- Predicates (Pure) ---`
#is_space : c ? c = 32 | c = \	 | c = 13
#is_digit : c ? c >= 48 & c <= 57
#is_alpha : c ? (c >= 65 & c <= 90) | (c >= 97 & c <= 122) | c = 95
#is_op_char : c ? c = 61 | c = 43 | c = 45 | c = 42 | c = 47 | c = 37 | c = 94 | c = 38 | c = 124 | c = 33 | c = 60 | c = 62 | c = 63 | c = 58 | c = 59 | c = 126

`--- Helper: List Construction ---`
#length : list ?
    list = 0 : 0
    1 + length (tail list)

#reverse : list ?
    _rev list 0

#_rev : list acc ?
    list = 0 : acc
    _rev (tail list) (cons (head list) acc)

#list_to_string : list ?
    (len ? 
        (str ? 
            _write_list list str 0
            (str + len) # 0
            str
        ) (alloc (len + 1))
    ) (length list)

#_write_list : list buf idx ?
    list = 0 : 0
    (buf + idx) # head list
    _write_list (tail list) buf (idx + 1)

`--- Core Lexer Logic ---`

`tokenize : source -> tokens`
#tokenize : source ?
    _tokenize_loop source (len source) 0

#_tokenize_loop : source source_len pos ?
    (res ?
        (token ? 
            (type ?
                type = tok_eof : cons token 0
                cons token (_tokenize_loop source source_len (head (tail res)))
            ) (@token)
        ) (head res)
    ) (scan_token source source_len pos)


`scan_token : (source, len, pos) -> [token, next_pos]`
#scan_token : source source_len pos ?
    pos >= source_len : (
        cons (cons tok_eof 0) (cons pos 0)
    )
    
    (c ? 
        is_space c : (
            scan_token source source_len (pos + 1)
        )
        
        c = \ : (
            cons (cons tok_sep 0) (cons (pos + 1) 0)
        )
        
        is_digit c : (
            (res ?
                (val_str ?
                    (val ?
                        cons (cons tok_num val) (cons (head (tail res)) 0)
                    ) (_parse_int val_str)
                ) (head res)
            ) (scan_num source source_len pos)
        )
        
        is_alpha c : (
            (res ? 
                cons (cons tok_id (head res)) (cons (head (tail res)) 0)
            ) (scan_id source source_len pos)
        )
        
        is_op_char c : (
            (res ? 
                cons (cons tok_op (head res)) (cons (head (tail res)) 0)
            ) (scan_op source source_len pos)
        )
        
        c = \` : (
            (res ?
                cons (cons tok_str (head res)) (cons (head (tail res)) 0)
            ) (scan_str source source_len pos)
        )
        
        `Default: Punctuation`
        cons (cons tok_punc c) (cons (pos + 1) 0)
    ) (nth source pos)


`--- Specific Scanners ---`

#scan_num : source source_len pos ?
    _scan_while source source_len pos is_digit

#scan_id : source source_len pos ?
    `ID can contain alpha or digit after first char`
    _scan_while source source_len pos (c ? is_alpha c | is_digit c)

#scan_op : source source_len pos ?
    _scan_while source source_len pos is_op_char

#_scan_while : source source_len pos pred ?
    (res ?
        (chars_rev ?
             (chars ?
                  cons (list_to_string chars) (cons (head (tail res)) 0)
             ) (reverse chars_rev)
        ) (head res)
    ) (_scan_while_rec source source_len pos pred 0)

#_scan_while_rec : source source_len pos pred acc ?
    pos >= source_len : (
        cons acc (cons pos 0)
    )
    (c ?
        pred c : (
            _scan_while_rec source source_len (pos + 1) pred (cons c acc)
        )
        cons acc (cons pos 0)
    ) (nth source pos)

#scan_str : source source_len pos ?
    `Skip opening backtick`
    (start_pos ?
        (res ?
            (chars_rev ?
                (chars ?
                    cons (list_to_string chars) (cons (head (tail res)) 0)
                ) (reverse chars_rev)
            ) (head res)
        ) (_scan_str_rec source source_len start_pos 0)
    ) (pos + 1)

#_scan_str_rec : source source_len pos acc ?
    pos >= source_len : (
        cons acc (cons pos 0)
    )
    (c ?
        (c = \` | c = -1) : (
            `End of string`
            cons acc (cons (pos + 1) 0)
        )
        _scan_str_rec source source_len (pos + 1) (cons c acc)
    ) (nth source pos)

`--- Utils ---`
#_parse_int : str ?
    str
`
  Sign Pure Functional Parser
  
  Philosophy:
  - No global state
  - No local bindings (:)
  - Logic: tokens -> [ast_node, remaining_tokens]
`

`--- AST Constants ---`
ast_unit : 0
ast_num : 1
ast_id : 2
ast_str : 3
ast_op : 4
ast_def : 5
ast_apply : 6
ast_block : 7
ast_infix : 8
ast_prefix : 9
ast_postfix : 10
ast_lambda : 11
ast_char : 12

`--- Token Constants (Match Lexer) ---`
tok_eof : -1
tok_id : 1
tok_num : 2
tok_str : 3
tok_op : 4
tok_punc : 5
tok_sep : 6
tok_unit : 0

`--- Helper: Get Token Info ---`
#tok_type : tok ? @tok
#tok_val : tok ? @(tok + 8)

`--- String Comparison (Pure) ---`
#streq : s1 s2 ?
    (c1 ? 
        (c2 ?
            c1 != c2 : 0
            c1 = 0 : 1
            streq (s1 + 1) (s2 + 1)
        ) (@s2)
    ) (@s1)

`--- Precedence Table (Pure) ---`
#get_prec : op_str ?
    streq op_str "+" : 15
    streq op_str "-" : 15
    streq op_str "*" : 16
    streq op_str "/" : 16
    streq op_str "%" : 16
    streq op_str ":" : 2
    streq op_str "?" : 5
    streq op_str "," : 6
    streq op_str "=" : 14
    streq op_str "==" : 14
    streq op_str "<" : 14
    streq op_str ">" : 14
    streq op_str "<=" : 14
    streq op_str ">=" : 14
    streq op_str "!=" : 14
    0

#is_right_assoc : op_str ?
    streq op_str ":" : 1
    streq op_str "?" : 1
    streq op_str "," : 1
    streq op_str "^" : 1
    0

`--- Parser Helpers ---`

`peek : tokens -> token`
#peek : tokens ? 
    tokens = 0 : cons tok_eof 0
    head tokens

`next : tokens -> rest`
#next : tokens ?
    tokens = 0 : 0
    tail tokens

`expect : tokens type -> [bool, tokens]`
#expect : tokens type ?
    (tok ? 
        (tok_t ?
            tok_t = type : cons 1 (next tokens)
            cons 0 tokens
        ) (tok_type tok)
    ) (peek tokens)

`--- Core Parser Logic ---`

`parse_program : tokens -> [ast_block, rest]`
#parse_program : tokens ?
    (res ? 
         cons (cons ast_block (head res)) (cons (head (tail res)) 0)
    ) (parse_stmts tokens)

`parse_stmts : tokens -> [list<node>, rest]`
#parse_stmts : tokens ?
    (tok ?
        (type ?
            type = tok_eof : cons 0 (cons tokens 0)
            
            type = tok_sep : parse_stmts (next tokens)
            
            `Parse Expression`
            (res ?
                (expr ?
                     (rest ?
                         (res2 ?
                             cons (cons expr (head res2)) (cons (head (tail res2)) 0)
                         ) (parse_stmts rest)
                     ) (head (tail res))
                ) (head res)
            ) (parse_expr tokens 0)
            
        ) (tok_type tok)
    ) (peek tokens)

`parse_block : tokens -> [ast_block, rest]`
#parse_block : tokens ?
    `TODO: Block logic, Section logic`
    parse_program tokens `Temporary: Treat block same as program for now`

`parse_expr : tokens min_prec -> [node, rest]`
#parse_expr : tokens min_prec ?
    (res_lhs ?
        (lhs ?
            (rest_1 ? 
                _parse_expr_loop lhs rest_1 min_prec
            ) (head (tail res_lhs))
        ) (head res_lhs)
    ) (parse_primary tokens)

`_parse_expr_loop : lhs tokens min_prec -> [node, rest]`
#_parse_expr_loop : lhs tokens min_prec ?
    (tok ?
        (type ?
            `Check for Apply (Implicit)`
            (can_start_expr type) : (
                `Apply: lhs next_expr`
                (res_rhs ? 
                     (rhs ?
                         (rest_rhs ?
                             (new_lhs ? 
                                  _parse_expr_loop new_lhs rest_rhs min_prec
                             ) (cons ast_apply (cons lhs (cons rhs 0)))
                         ) (head (tail res_rhs))
                     ) (head res_rhs)
                ) (parse_expr tokens 6) 
                `6 is Apply Precedence`
            )
            
            type != tok_op : cons lhs (cons tokens 0)
            
            (op_str ?
                (prec ?
                    prec < min_prec : cons lhs (cons tokens 0)
                    
                    (next_tokens ?
                        (next_min_prec ?
                            (res_rhs ?
                                (rhs ?
                                    (rest_rhs ?
                                        (new_lhs ?
                                            _parse_expr_loop new_lhs rest_rhs min_prec
                                        ) (cons ast_infix (cons op_str (cons lhs (cons rhs 0))))
                                    ) (head (tail res_rhs))
                                ) (head res_rhs)
                            ) (parse_expr next_tokens next_min_prec)
                        ) ((is_right_assoc op_str) ? prec (prec + 1))
                    ) (next tokens)
                    
                ) (get_prec op_str)
            ) (tok_val tok)
            
        ) (tok_type tok)
    ) (peek tokens)

#can_start_expr : type ?
    type = tok_id : 1
    type = tok_num : 1
    type = tok_str : 1
    type = tok_punc : 1 `(`
    0

#is_prefix_op : op ?
    streq op "!" : 1
    streq op "#" : 1
    streq op "$" : 1
    streq op "@" : 1 
    0

`parse_primary : tokens -> [node, rest]`
#parse_primary : tokens ?
    (tok ?
        (type ?
            (tokens_next ? 
                type = tok_num : (
                    (val ? 
                        cons (cons ast_num (cons val 0)) (cons tokens_next 0)
                    ) (tok_val tok)
                )
                
                type = tok_id : (
                    (val ?
                        cons (cons ast_id (cons val 0)) (cons tokens_next 0)
                    ) (tok_val tok)
                )
                
                type = tok_str : (
                     (val ?
                         cons (cons ast_str (cons val 0)) (cons tokens_next 0)
                     ) (tok_val tok)
                )

                type = tok_op : (
                    (op ?
                         is_prefix_op op : (
                             `Prefix Ops`
                             (res ? 
                                 cons (cons ast_prefix (cons op (cons (head res) 0))) (cons (head (tail res)) 0)
                             ) (parse_expr tokens_next 20 `Prefix Prec`)
                         )
                         
                         `Standalone Operator (for Sections)`
                         cons (cons ast_op (cons op 0)) (cons tokens_next 0)
                         
                    ) (tok_val tok)
                )
                
                type = tok_punc : (
                     (val ?
                         val = 91 : (
                             `LBRACKET -> Block (Potential Section)`
                             parse_block tokens_next
                         )
                         
                         val = 40 : (
                             `LPAREN -> Group (No Section)`
                             (res ? 
                                 (exprs ?
                                     (rest ?
                                         `Expect RPAREN (val 41)`
                                         (tok_r ?
                                             `Consume RPAREN`
                                             `Check if single expr for paren group`
                                             (is_single ? 
                                                 cons (head exprs) (cons (next rest) 0)
                                                 cons (cons ast_block (cons exprs 0)) (cons (next rest) 0)
                                             ) (is_null (tail exprs))
                                         ) (peek rest)
                                     ) (head (tail res))
                                 ) (head res)
                             ) (parse_stmts tokens_next)
                         )
                         `Default Unknown`
                         cons (cons ast_unit 0) (cons tokens_next 0)
                     ) (tok_val tok)
                )
                
                `Unknown`
                cons (cons ast_unit 0) (cons tokens_next 0)
                
            ) (next tokens)
        ) (tok_type tok)
    ) (peek tokens)

`parse_block : tokens -> [node, rest]`
#parse_block : tokens ?
    (res ?
        (exprs ?
            (rest ?
                `Expect RBRACKET (93)`
                 (tok_r ?
                     `Consume RBRACKET`
                     (node ? 
                          cons node (cons (next rest) 0)
                     ) (transform_section exprs)
                 ) (peek rest)
            ) (head (tail res))
        ) (head res)
    ) (parse_stmts tokens)

#is_null : list ?
    list = 0 : 1
    0

`--- AST Constructors ---`
#make_node : type val ?
    cons type (cons val 0)

#make_num : val ? make_node ast_num val
#make_id : val ? make_node ast_id val
#make_op : val ? make_node ast_op val
#make_str : val ? make_node ast_str val

#make_infix : op lhs rhs ?
    cons ast_infix (cons op (cons lhs (cons rhs 0)))

#make_lambda : params body ?
    make_infix "?" params body

`transform_section : exprs -> node`
#transform_section : exprs ?
    (len ?
        (p1 ? (p2 ? 
            len = 1 : (
                 (e1 ?
                     (type ?
                         type = ast_op : (
                             `[op] -> (p1 p2 ? p1 op p2)`
                             (op_str ? 
                                 make_lambda
                                     (make_infix "," p1 p2)
                                     (make_infix op_str p1 p2)
                             ) (tok_val (head (tail e1))) `e1=(type val). val=op`
                         )
                         cons ast_block (cons exprs 0)
                     ) (head e1)
                 ) (head exprs)
            )
            
            len = 2 : (
                 (e1 ? 
                      (e2 ?
                          (t1 ? 
                               (t2 ?
                                    t1 = ast_op : (
                                        `[op expr] -> (p1 ? p1 op expr)`
                                        (op_str ?
                                             make_lambda p1 (make_infix op_str p1 e2)
                                        ) (tok_val (head (tail e1)))
                                    )
                                    t2 = ast_op : (
                                        `[expr op] -> (p1 ? expr op p1)`
                                        (op_str ?
                                             make_lambda p1 (make_infix op_str e1 p1)
                                        ) (tok_val (head (tail e2)))
                                    )
                                    cons ast_block (cons exprs 0)
                               ) (head e2)
                          ) (head e1)
                      ) (head (tail exprs))
                 ) (head exprs)
            )
            
            cons ast_block (cons exprs 0)
        ) (make_id "$2") ) (make_id "$1")
    ) (length exprs)

`
  Sign Self-Hosted Compiler
  Target: ARM64 Assembly
`

`--- AST Constants (Match Parser) ---`
ast_unit : 0
ast_num : 1
ast_id : 2
ast_str : 3
ast_op : 4
ast_def : 5
ast_apply : 6
ast_block : 7
ast_infix : 8
ast_prefix : 9
ast_postfix : 10
ast_lambda : 11
ast_char : 12

`--- Context Management ---`
`Context : [LabelCount, StringList, Env]`

#get_lbl_cnt : ctx ? @ctx
#get_strs : ctx ? @(ctx + 8)
#get_env : ctx ? @(ctx + 16)

#mk_ctx : lbl strs env ?
    cons lbl (cons strs (cons env 0))

#update_ctx_lbl : ctx new_lbl ?
    mk_ctx new_lbl (get_strs ctx) (get_env ctx)

#update_ctx_strs : ctx new_strs ?
    mk_ctx (get_lbl_cnt ctx) new_strs (get_env ctx)

#update_ctx_env : ctx new_env ?
    mk_ctx (get_lbl_cnt ctx) (get_strs ctx) new_env

`--- String Table Helpers ---`
`Items in StringList: [LabelName, StringContent]`

#add_string : ctx str ?
    (curr_strs ?
        `Check if already exists to deduplicate? For now, just add.`
        `Generate label: str_[count]`
        (cnt ?
            (lbl ? 
                (new_node ? 
                    cons (cons lbl (cons str 0)) curr_strs
                ) (mk_ctx cnt new_node (get_env ctx))
            ) (make_label "str_" cnt)
        ) (get_lbl_cnt ctx)
    ) (get_strs ctx)

`--- Helpers ---`

#make_label : prefix cnt ?
    str_concat prefix (int_to_str cnt)

#emit : str ?
    cons str 0

#emit_seq : list ?
    list

`--- String Utils ---`

#str_len : str ?
    (c ? 
        c = 0 : 0
        1 + str_len (str + 1)
    ) (@str)

#str_concat : s1 s2 ?
    (len1 ? 
        (len2 ?
             (new_str ? 
                 _str_cpy s1 new_str
                 _str_cpy s2 (new_str + len1)
                 (new_str + len1 + len2) # 0 `Null terminate`
                 new_str
             ) (alloc (len1 + len2 + 1))
        ) (str_len s2)
    ) (str_len s1)

#_str_cpy : src dst ?
    (c ? 
        c = 0 : dst
        dst # c
        _str_cpy (src + 1) (dst + 1)
    ) (@src)

#int_to_str : n ?
    n = 0 : "0"
    (len ?
        (str ? 
            _int_to_str_rec n (str + len - 1)
            (str + len) # 0
            str
        ) (alloc (len + 1))
    ) (_num_digits n)

#_num_digits : n ?
    n < 10 : 1
    1 + _num_digits (n / 10)

#_int_to_str_rec : n ptr ?
    ptr # (48 + (n % 10))
    n < 10 : 0
    _int_to_str_rec (n / 10) (ptr - 1)

`--- Context Helpers ---`

#lookup_id : env id ?
    env = 0 : 0
    (entry ? 
        (name ? 
             streq name id : (tail entry)
             lookup_id (tail env) id
        ) (head entry)
    ) (head env)

`--- Compiler Core ---`

`compile_program : ast -> assembly`
#compile_program : ast ?
    (ctx ? 
        (res ? 
            (asm ? 
                `TODO: Post-process asm (add header, data section)`
                asm
            ) (head res)
        ) (compile_stmts ast ctx)
    ) (mk_ctx 0 0 0)

`compile_stmts : stmts ctx -> [asm, ctx]`
#compile_stmts : stmts ctx ?
    stmts = 0 : cons 0 (cons ctx 0)
    
    (res1 ? 
        (asm1 ? 
            (ctx1 ? 
                (res2 ? 
                    (asm2 ? 
                        (ctx2 ? 
                            cons (append asm1 asm2) (cons ctx2 0)
                        ) (head (tail res2))
                    ) (head res2)
                ) (compile_stmts (tail stmts) ctx1)
            ) (head (tail res1))
        ) (head res1)
    ) (compile_node (head stmts) ctx)

`compile_node : node ctx -> [asm, ctx]`
#compile_node : node ctx ?
    (type ? 
        type = ast_num : compile_num node ctx
        type = ast_id : compile_id node ctx
        type = ast_apply : compile_apply node ctx
        type = ast_infix : compile_infix node ctx
        `Default: Unit`
        cons (emit "mov x0, #0\n") (cons ctx 0)
    ) (head node)

#compile_num : node ctx ?
    (val ? 
        (asm ? 
            cons asm (cons ctx 0)
        ) (cons "mov x0, #" (cons val (cons "\n" 0)))
    ) (head (tail node))

#compile_id : node ctx ?
    (id ?
        (offset ?
            offset = 0 : (
                `Unknown var -> emit error comment or 0`
                cons (emit "mov x0, #0 // Unknown var\n") (cons ctx 0)
            )
            (asm ? 
                cons asm (cons ctx 0)
            ) (str_concat "ldr x0, [x29, #" (str_concat (int_to_str offset) "]\n"))
        ) (lookup_id (get_env ctx) id)
    ) (head (tail node))

#compile_apply : node ctx ?
    (lhs ? 
        (rhs ?
             (res1 ?
                 (asm1 ?
                    (ctx1 ?
                        (res2 ?
                            (asm2 ?
                                (ctx2 ?
                                    `RHS (Arg) -> x0 -> push`
                                    `LHS (Func) -> x0 -> blr`
                                    (asm ? 
                                        cons asm (cons ctx2 0)
                                    ) (append asm2 
                                        (cons "str x0, [sp, #-16]!\n" 
                                        (append asm1 
                                            (cons "blr x0\n" 
                                            (emit "add sp, sp, #16\n")))))
                                ) (head (tail res2))
                            ) (head res2)
                        ) (compile_node lhs ctx1)
                    ) (head (tail res1))
                 ) (head res1)
             ) (compile_node rhs ctx)
        ) (head (tail (tail node)))
    ) (head (tail node))

#compile_infix : node ctx ?
    (op ? 
        (lhs ? 
            (rhs ?
                streq op ":" : compile_if lhs rhs ctx
                streq op ";" : compile_else lhs rhs ctx
                streq op "?" : compile_lambda lhs rhs ctx

                (res1 ? 
                    (asm1 ?
                        (ctx1 ?
                            (res2 ? 
                                (asm2 ? 
                                    (ctx2 ?
                                        `LHS in x0, push to stack`
                                        `RHS in x0, move to x1, pop LHS to x0`
                                        (op_asm ? 
                                            cons (append asm1 (cons "str x0, [sp, #-16]!\n" (append asm2 (cons "ldr x1, [sp], #16\n" (cons op_asm 0))))) (cons ctx2 0)
                                        ) (get_op_asm op)
                                    ) (head (tail res2))
                                ) (head res2)
                            ) (compile_node rhs ctx1)
                        ) (head (tail res1))
                    ) (head res1)
                ) (compile_node lhs ctx)
            ) (head (tail (tail (tail node))))
        ) (head (tail (tail node)))
    ) (head (tail node))

#compile_lambda : params body ctx ?
    `Auto-Currying: Check if params is Apply`
    (type ? 
        type = ast_apply : (
            `params = apply(p1, p2). Transform to p1 ? (p2 ? body)`
            (p1 ? 
                (p2 ?
                    compile_lambda p1 (make_infix "?" p2 body) ctx
                ) (head (tail (tail params)))
            ) (head (tail params))
        )
        
        type = ast_id : (
             `Single param -> Generate Func`
             (param_name ? 
                 (cnt ? 
                     (lbl ? 
                         (new_env ? 
                             (ctx_body ? 
                                 (res_body ? 
                                     (asm_body ? 
                                         (ctx_final ? 
                                            (func_asm ? 
                                                cons (append (emit (str_concat "b after_" (str_concat lbl "\n")))
                                                     (append func_asm
                                                     (emit (str_concat "after_" (str_concat lbl ":\nldr x0, ="))))) 
                                                     (cons lbl (cons "\n" 0)) (cons ctx_final 0)
                                            ) (append (emit (str_concat lbl ":\nstp x29, x30, [sp, #-16]!\nmov x29, sp\n"))
                                              (append asm_body
                                              (emit "ldp x29, x30, [sp], #16\nret\n")))
                                         ) (head (tail res_body))
                                     ) (head res_body)
                                 ) (compile_node body ctx_body)
                             ) (update_ctx_env (update_ctx_lbl ctx (cnt + 1)) new_env)
                         ) (cons (cons param_name (cons 16 0)) (get_env ctx))
                     ) (make_label "fn_" cnt)
                 ) (get_lbl_cnt ctx)
             ) (head (tail params))
        )
        
        `Unknown param type (e.g. pattern matching later)`
        cons (emit "mov x0, #0 // Invalid param\n") (cons ctx 0)
        
    ) (head params)

#compile_if : cond val ctx ?
    `Generate Labels`
    (cnt ? 
        (lbl_end ? 
             (ctx_lbl ? 
                 (res_cond ? 
                     (asm_cond ? 
                         (ctx_cond ? 
                             (res_val ? 
                                 (asm_val ? 
                                     (ctx_val ? 
                                         `Combine: Cond -> cmp 0 -> beq end -> Val -> end:`
                                         (asm ? 
                                             cons asm (cons ctx_val 0)
                                         ) (append asm_cond 
                                                (cons "cmp x0, #0\n" 
                                                (cons (str_concat "beq " (str_concat lbl_end "\n"))
                                                (append asm_val 
                                                (emit (str_concat lbl_end ":\n"))))))
                                     ) (head (tail res_val))
                                 ) (head res_val)
                             ) (compile_node val ctx_cond)
                         ) (head (tail res_cond))
                     ) (head res_cond)
                 ) (compile_node cond ctx_lbl)
             ) (update_ctx_lbl ctx (cnt + 1))
        ) (make_label "if_end_" cnt)
    ) (get_lbl_cnt ctx)

#compile_else : lhs rhs ctx ?
    `LHS (Choice) ; RHS (Fallback)`
    `Generate Labels`
    (cnt ? 
        (lbl_end ? 
             (ctx_lbl ? 
                 (res_lhs ? 
                     (asm_lhs ? 
                         (ctx_lhs ? 
                             (res_rhs ? 
                                 (asm_rhs ? 
                                     (ctx_rhs ? 
                                         `Combine: LHS -> cmp 0 -> bne end -> RHS -> end:`
                                         (asm ? 
                                             cons asm (cons ctx_rhs 0)
                                         ) (append asm_lhs 
                                                (cons "cmp x0, #0\n" 
                                                (cons (str_concat "bne " (str_concat lbl_end "\n"))
                                                (append asm_rhs 
                                                (emit (str_concat lbl_end ":\n"))))))
                                     ) (head (tail res_rhs))
                                 ) (head res_rhs)
                             ) (compile_node rhs ctx_lhs)
                         ) (head (tail res_lhs))
                     ) (head res_lhs)
                 ) (compile_node lhs ctx_lbl)
             ) (update_ctx_lbl ctx (cnt + 1))
        ) (make_label "else_end_" cnt)
    ) (get_lbl_cnt ctx)



#get_op_asm : op ?
    streq op "+" : "add x0, x0, x1\n"
    streq op "-" : "sub x0, x0, x1\n"
    streq op "*" : "mul x0, x0, x1\n"
    "nop\n"

`--- Utils ---`
#append : l1 l2 ?
    l1 = 0 : l2
    cons (head l1) (append (tail l1) l2)
`Test Driver for Self-Hosted Compiler`

#main : _ ?
    src : "x = 1 + 2 + 3"
    print_str "Source: "
    print_str_ln src
    
    tokens : tokenize src
    print_str_ln "--- Tokens ---"
    _print_tokens tokens
    
    ast_res : parse_program tokens
    ast : head ast_res
    print_str_ln "--- AST Parsed ---"
    
    asm_res : compile_program ast
    asm : head asm_res
    
    print_str_ln "--- Assembly ---"
    print_list_str asm
    print_str_ln "--- End ---"

#_print_tokens : toks ?
    toks = 0 : 0
    tok : head toks
    type : head tok
    
    type = -1 : (
        print_str_ln "EOF"
        0
    )
    
    val : head (tail tok)
    `If type is ID, Num, Str, Op - val is string/num`
    `If type is Punc - val is char code`
    
    print_str "Tok: "
    print_num type
    print_str " Val: "
    
    type = 5 : print_char val
    type != 5 : print_str val
    
    print_char 10
    _print_tokens (tail toks)
