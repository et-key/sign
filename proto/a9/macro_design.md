# Sign Macro System Design (Conceptual Draft)

## 概要 (Overview)
Sign言語において `"` (ダブルクォーテーション) を用いたマクロ (`def-macro` 相当) の設計案です。
マクロは、コンパイル時（正確にはパース直後〜コンパイル前の AST 変換時）に展開され、Signの基本構文や言語機能を拡張・上書きするために使用されます。LISPの強力なマクロのように、コードそのものをAST(木構造)データとして受け取り、新しいASTデータを返す関数として機能します。

## 構文規則のアイデア (Syntax Idea)

ダブルクォーテーション `"` を「ASTクォート（マクロ式）」または「マクロ展開」の演算子として定義します。

### 1. マクロ定義 (Macro Definition)
マクロ自体は通常の関数のように定義しますが、名前に `"` を前置するか、マクロ定義専用の演算子（例: `::` や `"?` など）を用いることが考えられます。
ここでは、関数名の前に `"` を付けることでマクロであることを明示する案とします。

```sign
"unless : cond body ?
	# unless マクロの定義
	# cond と body は評価される前の AST ノードとして渡される。
	# 返り値として新しい AST (if-not 相当) を構築して返す。
	
	"
		(! `,cond) : `,body
	"
```
※ `"` によるASTブロック表現の中で、`,x` などの記述を「アンクォート」と同義に扱うアプローチが可能です。

### 2. マクロの使用 (Macro Invocation)
マクロを呼び出すときは、通常の関数適用と同じように記述しますが、コンパイラが `"` 指定された識別子を見ると、引数を評価せず AST のままマクロ関数に渡します。

```sign
"unless (x = 0) (
	# x が 0 でない時の処理
	x + 1
)
```

### 3. " によるASTリテラル表現 (String as AST Literal)
LISPにおける `'(1 2 3)` のように、Signでは `"` で囲んだブロックを**直接パースされたASTノードリテラル**として扱うことができます。

```sign
my_ast : "x + y"
# my_ast は単なるデータとしての文字列ではなく、 { type: 'infix', op: '+', left: 'x', right: 'y' } というASTデータ表現として扱われる。
```

マクロ内で動的にASTを生成する際、この `"` 記法を活用して直感的に構文木を組み立てられます。

```sign
"times : n body ?
	# n回ループするマクロを展開
	"
		_loop : i ?
			(i < `,n) :
				`,body
				_loop (i + 1)
		_loop 0
	"
```
上記のように、 `"` で囲まれた複数行コードは、コンパイル時に展開されるテンプレートASTとして機能します。

## マクロ展開のフェーズ (Evaluation Phase)

1. **Lexing / Parsing**: 通常通りコードを字句解析・構文解析し、ASTを生成。
2. **Macro Expansion (マクロ展開器)**: 
   - ASTツリーを巡回し、マクロ呼び出し（例: `"unless`）を発見する。
   - コンパイル時環境（Compile-time Environment）で `"unless` マクロを展開実行する。
   - `cond` と `body` のASTを引数として渡し、返ってきた新しいASTで元のマクロ呼び出しノードを置換する。
3. **Compilation**: 完全に展開されたASTをAArch64アセンブリに変換する。

## まとめ (Conclusion)
- **`"` の役割**: 「文字列」ではなく、「構文（AST）そのもの」を表現するメタ演算子として予約する。
- **LISP との違い**: S式ではなく中置演算子やインデントを含む豊かな構文を持つため、`"` を使った**テンプレートASTリテラル**が非常に強力な武器になる。
- **利点**: ユーザーが独自の制御構文（`try-catch`, `for-each`, `match` の拡張など）をSign言語の文法内で自然に作れるようになる。
