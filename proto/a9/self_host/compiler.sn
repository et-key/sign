`
Sign Pure Functional Compiler (Code Generator)

Transforms AST from parser.sn into ARM64 Assembly.

Philosophy:
- Pure Functional: State (LabelCount, StringTable, Env) is threaded.
- Stack Machine: Context is passed as arguments.
- Output: List of assembly instruction strings.
`

`--- AST Constants (Match Parser) ---`
ast_unit : 0
ast_num : 1
ast_id : 2
ast_str : 3
ast_op : 4
ast_def : 5
ast_apply : 6
ast_block : 7
ast_infix : 8
ast_prefix : 9
ast_postfix : 10
ast_lambda : 11
ast_char : 12

`--- Context Management ---`
`Context : [LabelCount, StringList, Env, StackOffset]`

#make_context : label_count str_list env stack_offset ?
	label_count , str_list , env , stack_offset , 0

#ctx_label_count : ctx ? head ctx
#ctx_strings : ctx ? head (tail ctx)
#ctx_env : ctx ? head (tail (tail ctx))
#ctx_stack_offset : ctx ? head (tail (tail (tail ctx)))

`--- Environment Helpers ---`
#lookup_var : env name ?
	env = 0 : 0
	(entry ?
		(streq (head entry) name) : (tail entry)
		lookup_var (tail env) name
	) (head env)

#compile_str : node ctx ?
	(content ?
		(res_add ? 
			(lbl ? (new_ctx ?
				(emit (concat `    adr x0, ` (concat lbl `\n`)) 0) , new_ctx , 0
			) (ctx_from_res res_add) ) (head res_add)
		) (add_string ctx content)
	) (tok_val node)

#compile_apply : node ctx ?
	(func ? (arg ? 
		(func_is_spread ?
			func_is_spread : (
				`Spread Concat via Whitespace Apply`
				(target ?
					(res_target ?
						(asm_target ? (ctx_target ?
							(res_arg ?
								(asm_arg ? (ctx_arg ?
									(asm_target~ 
										(`    str x0, [sp, #-16]!\n` ,
											(asm_arg ~
												(`    mov x1, x0\n` ,
													`    ldr x0, [sp], #16\n` ,
													`    bl _concat\n` , 0
												)
											)
										)
									) , ctx_arg , 0
								) (ctx_from_res res_arg) ) (asm_from_res res_arg)
							) (compile_node arg ctx_target)
						) (ctx_from_res res_target) ) (asm_from_res res_target)
					) (compile_node target ctx)
				) (head (tail (tail func)))
			)
			`Standard Function Call`
			(res_func ? 
				(asm_func ? (ctx_func ?
					(res_arg ?
						(asm_arg ? (ctx_arg ?
							(asm_func~ 
								(`    str x0, [sp, #-16]!\n` ,
									(asm_arg ~
										(`    ldr x1, [sp], #16\n` ,
											`    ldr x2, [x1]\n` ,
											`    ldr x9, [x1, #8]\n` ,
											`    blr x2\n` , 0
										)
									)
								)
							) , ctx_arg , 0
						) (ctx_from_res res_arg) ) (asm_from_res res_arg)
					) (compile_node arg ctx_func)
				) (ctx_from_res res_func) ) (asm_from_res res_func)
			) (compile_node func ctx)
		) (is_spread_node func)
	) (head (tail (tail node))) ) (head (tail node))

#is_spread_node : node ?
	((head node) = ast_postfix) & (streq (tok_val (head (tail node))) \~)

#push_var : ctx name ?
	(offset ? 
		make_context 
			(ctx_label_count ctx) 
			(ctx_strings ctx) 
			((name , offset) , ctx_env ctx)
			offset
	) ((ctx_stack_offset ctx) - 8)

`--- String Table Helpers ---`
#add_string : ctx content ?
	`TODO: Check existence, return label. For now just add.`
	(count ? 
		(label ? 
			label ,
				make_context 
					(count + 1)
					((label , content , 0) , ctx_strings ctx)
					(ctx_env ctx)
					(ctx_stack_offset ctx)
		) (make_label `str_` count)
	) (ctx_label_count ctx)

`--- String Utils ---`
#strlen : s ?
	(c ? 
		c = 0 : 0
		1 + strlen (s + 1)
	) (@s)

#strcpy : dest src ?
	(c ?
		c = 0 : (
			dest # 0
			dest
		)
		dest # c
		strcpy (dest + 1) (src + 1)
	) (@src)

#strcat : dest src ?
	(len ? 
		strcpy (dest + len) src
		dest
	) (strlen dest)

#concat : s1 s2 ?
	(len1 ? 
		(len2 ?
			(new_s ? 
				strcpy new_s s1
				strcpy (new_s + len1) s2
				new_s
			) (alloc (len1 + len2 + 1))
		) (strlen s2)
	) (strlen s1)

#concat_list : list ?
	list = 0 : ``
	concat (head list) (concat_list (tail list))

`--- Number Conversion ---`
#int_to_str : n ?
	n = 0 : \0
	n < 0 : concat \- (int_to_str (0 - n))
	_int_to_str_rec n

#_int_to_str_rec : n ?
	n = 0 : ``
	(digit ? 
		concat (_int_to_str_rec (n / 10)) (char_to_str (digit + 48))
	) (n % 10)

#char_to_str : c ?
	(s ? 
		s # c
		(s + 1) # 0
		s
	) (alloc 2)

#emit_num : val rest ?
	concat (int_to_str val) rest

`--- Label Helpers ---`
#make_label : prefix count ?
	concat prefix (concat \_ (int_to_str count))

#new_label : ctx prefix ?
	(count ? 
		(lbl ? 
			lbl ,
				make_context 
					(count + 1)
					(ctx_strings ctx)
					(ctx_env ctx)
					(ctx_stack_offset ctx)
				, 0
		) (make_label prefix count)
	) (ctx_label_count ctx)

`--- Core Compiler ---`
`compile_program : ast -> assembly_string`
#compile_program : ast ?
	(res ? 
		(asm_list ? 
			concat_list asm_list
		) (head res)
	) (compile_node ast (make_context 0 0 0 0))

`compile_node : node ctx -> [asm_list, ctx]`
#compile_node : node ctx ?
	(type ?
		type = ast_num : compile_num node ctx
		type = ast_infix : compile_infix node ctx
		type = ast_prefix : compile_prefix node ctx
		type = ast_postfix : compile_postfix node ctx
		type = ast_block : compile_block node ctx
		type = ast_unit : compile_unit node ctx
		type = ast_str : compile_str node ctx
		type = ast_id : compile_id node ctx
		type = ast_apply : compile_apply node ctx
		
		`Default`
		((emit `    // Unknown Node Type\n` 0) , 0) , ctx , 0
	) (head node)

`--- Node Compilers ---`

#compile_num : node ctx ?
	(val ? 
		(emit `    mov x0, #` (emit_num val (emit `\n` 0))) , ctx , 0
	) (head (tail node))

#compile_unit : node ctx ?
	(emit `    adr x0, sign_id\n` 0) , ctx , 0

#compile_prefix : node ctx ?
	(op ? (expr ?
		(streq op \@) : (compile_prefix_at expr ctx)
		(streq op \!) : (compile_prefix_not expr ctx)
		(streq op `!!`) : (compile_prefix_bitwise_not expr ctx)
		
		`Fallback`
		compile_node expr ctx
	) (head (tail (tail node))) ) (tok_val (head (tail node)))

#compile_prefix_at : expr ctx ?
	(expr_is_zero_num expr) : (
		(emit `    bl _read_char\n` 0) , ctx , 0
	)
	
	(res ?
		(asm ? (ctx_new ?
			(asm~ (`    ldr x0, [x0] // @ load\n` , 0)) , ctx_new , 0
		) (ctx_from_res res) ) (asm_from_res res)
	) (compile_node expr ctx)

#expr_is_zero_num : expr ?
	((head expr) = ast_num) & ((head (tail expr)) = 0)

#compile_prefix_not : expr ctx ?
	(lbl_true ? (lbl_end ? (res_lbl_end ? 
		(ctx_new ?
			(res_expr ?
				(asm_expr ? (ctx_expr ?
					(asm_expr ~
						(`    adr x9, sign_id\n` ,
							`    cmp x0, x9\n` ,
								(concat `    b.eq ` (concat lbl_true `\n`)) ,
									`    adr x0, sign_id\n` ,
										(concat `    b ` (concat lbl_end `\n`)) ,
											(concat lbl_true `:\n`) ,
												`    mov x0, #0\n` ,
													(concat lbl_end `:\n`) , 0
					)) , ctx_expr , 0
				) (ctx_from_res res_expr) ) (asm_from_res res_expr)
			) (compile_node expr ctx_new)
		) (ctx_from_lbl res_lbl_end) ) (new_label (new_label ctx `not_true`) `not_end`) ) )

#compile_prefix_bitwise_not : expr ctx ?
	(res ?
		(asm ? (ctx_new ?
			(asm~ (`    mvn x0, x0\n` , 0)) , ctx_new , 0
		) (ctx_from_res res) ) (asm_from_res res)
	) (compile_node expr ctx)

#compile_postfix : node ctx ?
	(op ? (expr ?
		(streq op \!) : (
			(res ?
				(asm ? (ctx_new ?
					(asm~ (`    bl _factorial\n` , 0)) , ctx_new , 0
				) (ctx_from_res res) ) (asm_from_res res)
			) (compile_node expr ctx)
		)
		
		`Fallback`
		compile_node expr ctx
	) (head (tail (tail node))) ) (tok_val (head (tail node)))

#compile_infix : node ctx ?
	(op ?
		(streq op \+) : (compile_binop node ctx `    add x0, x0, x1\n`)
		(streq op \-) : (compile_binop node ctx `    sub x0, x0, x1\n`)
		(streq op \*) : (compile_binop node ctx `    mul x0, x0, x1\n`)
		(streq op \/) : (compile_binop node ctx `    sdiv x0, x0, x1\n`)
		
		(streq op \=) : (compile_cmp node ctx `eq`)
		(streq op `!=`) : (compile_cmp node ctx `ne`)
		(streq op \<) : (compile_cmp node ctx `lt`)
		(streq op \>) : (compile_cmp node ctx `gt`)
		(streq op `<=`) : (compile_cmp node ctx `le`)
		(streq op `>=`) : (compile_cmp node ctx `ge`)

		(streq op \|)  : (compile_logic_or node ctx)
		(streq op `||`) : (compile_binop node ctx `    orr x0, x1, x0\n`)
		(streq op \&) : (compile_logic_and node ctx)

		(streq op \,) : (compile_binop node ctx `    bl _cons\n`)
		(streq op \~) : (compile_binop node ctx `    bl _concat\n`)
		(streq op `~+`) : (compile_binop node ctx `    bl _range\n`)
		(streq op \') : (compile_binop node ctx `    bl _dict_get\n`)

		(streq op \:) : (compile_bind node ctx)
		(streq op \?) : (compile_lambda node ctx)

		`Default`
		((emit (concat `    // Unknown Infix: ` (concat op `\n`)) 0) , 0) , ctx , 0
		
	) (tok_val (head (tail node))) 

#compile_bind : node ctx ?
	(lhs ? (rhs ?
		(name ? 
			(res_rhs ?
				(asm_rhs ? (ctx_rhs ?
					(new_ctx ?
						(asm_rhs~ (`    str x0, [sp, #-16]!\n` , `    adr x0, sign_id\n` , 0)) , new_ctx , 0
					) (push_var ctx_rhs name)
				) (ctx_from_res res_rhs) ) (asm_from_res res_rhs)
			) (compile_node rhs ctx)
		) (tok_val lhs) `Expect lhs to be ID`
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_lambda : node ctx ?
	(params ? (body ?
		(lbl_func ? (res_lbl ? (ctx_lbl ?
			(lbl_after ? (res_after ? (ctx_after ?
				(param_name ?
					(ctx_with_arg ?
						(res_body ?
							(asm_body ? (ctx_body ? 
								(((concat `    b ` (concat lbl_after `\n`)) ,
									(concat lbl_func `:\n`) ,
										`    stp x29, x30, [sp, #-16]!\n` ,
											`    mov x29, sp\n` ,
												`    str x0, [sp, #-16]!\n\ Push Arg` , 0
								) ~
								(asm_body ~
									(`    mov sp, x29\n` ,
										`    ldp x29, x30, [sp], #16\n` ,
											`    ret\n` ,
												(concat lbl_after `:\n`) ,
													`    adr x0, sign_id\n` ,
														`    str x0, [sp, #-16]!\n` ,
															(concat `    adr x1, ` (concat lbl_func `\n`)) ,
																`    ldr x0, [sp], #16\n` ,
																	`    bl _cons\n` , 0
									)
								)) , ctx_body , 0
						) (ctx_from_res res_body) ) (asm_from_res res_body)
					) (compile_node body ctx_with_arg)
				) (push_var ctx_lbl param_name) ) (tok_val params) `Assume single param ID`
			) (ctx_from_res res_after) ) (new_label ctx_lbl `after_func`) )
		) (ctx_from_res res_lbl) ) (new_label ctx `func`) )
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_binop : node ctx instr ?
	(lhs ? (rhs ?
		(res_lhs ?
			(asm_lhs ? (ctx_lhs ?
				(res_rhs ?
					(asm_rhs ? (ctx_rhs ?
						(asm_lhs~ 
							(`    str x0, [sp, #-16]!\n` ,
								(asm_rhs ~
									(`    mov x1, x0\n` ,
										`    ldr x0, [sp], #16\n` ,
											instr , 0
									)
								)
							)
						) , ctx_rhs , 0
					) (ctx_from_res res_rhs) ) (asm_from_res res_rhs)
				) (compile_node rhs ctx_lhs)
			) (ctx_from_res res_lhs) ) (asm_from_res res_lhs)
		) (compile_node lhs ctx)
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_cmp : node ctx cond ?
	(lhs ? (rhs ?
		(res_lhs ?
			(asm_lhs ? (ctx_lhs ?
				(res_rhs ?
					(asm_rhs ? (ctx_rhs ?
						(lbl_true ? (lbl_end ? (res_lbl_end ?
							(ctx_final ? 
								(asm_lhs~ 
									(`    str x0, [sp, #-16]!\n` ,
										(asm_rhs ~
											(`    mov x1, x0\n` ,
												`    ldr x0, [sp], #16\n` ,
													`    cmp x0, x1\n` ,
														(concat `    b.` (concat cond (concat \  (concat lbl_true `\n`)))) ,
															`    mov x0, #0\n` ,
																(concat `    b ` (concat lbl_end `\n`)) ,
																	(concat lbl_true `:\n`) ,
																		(((is_literal_expr lhs) ? (`    mov x0, x1\n` , 0) | 0) ~
																			((concat lbl_end `:\n`) , 0)
																		)
											)
										)
									)
								) , ctx_final , 0
							) (ctx_from_res res_lbl_end)
						) (new_label (ctx_from_res res_rhs) `cmp_end`) ) ) (new_label ctx_rhs `cmp_true`) )
					) (ctx_from_res res_rhs) ) (asm_from_res res_rhs)
				) (compile_node rhs ctx_lhs)
			) (ctx_from_res res_lhs) ) (asm_from_res res_lhs)
		) (compile_node lhs ctx)
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_logic_or : node ctx ?
	(lhs ? (rhs ?
		(lbl_right ? (lbl_end ? (res_lbl_end ?
			(ctx_new ?
				(res_lhs ?
					(asm_lhs ? (ctx_lhs ?
						(res_rhs ?
							(asm_rhs ? (ctx_rhs ?
								(asm_lhs ~
									(`    adr x9, sign_id\n` ,
										`    cmp x0, x9\n` ,
											(concat `    b.eq ` (concat lbl_right `\n`)) ,
												(concat `    b ` (concat lbl_end `\n`)) ,
													(concat lbl_right `:\n`) ,
														(asm_rhs~ ((concat lbl_end `:\n`) , 0))
									)
								) , ctx_rhs , 0
							) (ctx_from_res res_rhs) ) (asm_from_res res_rhs)
						) (compile_node rhs ctx_lhs)
					) (ctx_from_res res_lhs) ) (asm_from_res res_lhs)
				) (compile_node lhs ctx_new)
			) (ctx_from_lbl res_lbl_end)
		) (new_label (new_label ctx `or_right`) `or_end`) ) )
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_logic_and : node ctx ?
	(lhs ? (rhs ?
		(lbl_fail ? (lbl_end ? (res_lbl_end ?
			(ctx_new ?
				(res_lhs ?
					(asm_lhs ? (ctx_lhs ?
						(res_rhs ?
							(asm_rhs ? (ctx_rhs ?
								(asm_lhs ~
									(`    adr x9, sign_id\n` ,
										`    cmp x0, x9\n` ,
											(concat `    b.eq ` (concat lbl_fail `\n`)) ,
												(asm_rhs ~
													((concat `    b ` (concat lbl_end `\n`)) ,
														(concat lbl_fail `:\n`) ,
															`    adr x0, sign_id\n` ,
																(concat lbl_end `:\n`) , 0
													)
												)
									)
								) , ctx_rhs , 0
							) (ctx_from_res res_rhs) ) (asm_from_res res_rhs)
						) (compile_node rhs ctx_lhs)
					) (ctx_from_res res_lhs) ) (asm_from_res res_lhs)
				) (compile_node lhs ctx_new)
			) (ctx_from_lbl res_lbl_end)
		) (new_label (new_label ctx `and_fail`) `and_end`) ) )
	) (head (tail (tail (tail node)))) ) (head (tail (tail node)))

#compile_block : node ctx ?
	(stmts ?
		stmts = 0 : (
			(emit `    adr x0, sign_id\n` 0) , ctx , 0
		)
		
		(lbl_end ? 
			(res_stmts ? 
				(asm_stmts ? (ctx_stmts ?
					(asm_stmts~ ((concat lbl_end `:\n`) , 0)) , ctx_stmts , 0
				) (ctx_from_res res_stmts) ) (asm_from_res res_stmts)
			) (compile_stmts stmts lbl_end (ctx_from_lbl res_lbl_end))
		) (new_label ctx `blk_end`)
	) (head (tail node))

#compile_stmts : stmts lbl_end ctx ?
	(head_stmt ? 
		(tail_stmts ?
			tail_stmts = 0 : (
				`Last Statement`
				compile_node head_stmt ctx
			)
			
			`Not Last Statement`
			(res_head ? 
				(asm_head ? (ctx_head ?
					(res_tail ?
						(asm_tail ? (ctx_tail ?
							(asm_head ~
								(`    adr x9, sign_id\n` ,
									`    cmp x0, x9\n` ,
										(concat `    b.ne ` (concat lbl_end `\n`)) ,
											asm_tail
								)
							) , ctx_tail , 0
						) (ctx_from_res res_tail) ) (asm_from_res res_tail)
					) (compile_stmts tail_stmts lbl_end ctx_head)
				) (ctx_from_res res_head) ) (asm_from_res res_head)
			) (compile_node head_stmt ctx)
			
		) (tail stmts)
	) (head stmts)

#asm_from_res : res ? head res
#ctx_from_res : res ? head (tail res)
#res_lbl_end : res ? res `Typo fix context usage above`
#ctx_from_lbl : res ? head (tail res)

#is_literal_expr : node ?
	(type ? type = ast_num | type = ast_str | type = ast_char) (head node)
