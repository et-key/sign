`
Sign Self-Hosting Lexer
Ported from prepare_lexer.js / parser.js
`

`--- Token Constants ---`
tok_eof : -1
tok_id : 1
tok_num : 2
tok_str : 3
tok_op : 4
tok_punc : 5
tok_sep : 6

`--- Global State (Scanner) ---`
$src # 0
$src_len # 0
$pos # 0
$ch # 0

#init_lexer : source ?
	$src # source
	$src_len # len source
	$pos # 0
	read_char 0

#read_char : _ ?
	$p # @pos
	p >= @src_len : (
		$ch # -1
		0
	)
	$c # nth @src p
	$ch # c
	$pos # p + 1
	c

`--- Predicates ---`
#is_space : c ? c = 32 | c = \	 | c = 13
#is_digit : c ? c >= 48 & c <= 57
#is_alpha : c ? (c >= 65 & c <= 90) | (c >= 97 & c <= 122) | c = 95
#is_op_char : c ? c = 61 | c = 43 | c = 45 | c = 42 | c = 47 | c = 37 | c = 94 | c = 38 | c = 124 | c = 33 | c = 60 | c = 62 | c = 63 | c = 58 | c = 59 | c = 126

`--- Functional Helpers ---`
#length : list ?
	list = 0 : 0
	1 + length (tail list)

#list_to_string : list ?
	len : length list
	str : alloc (len + 1)
	_write_list list str 0
	(str + len) # 0
	str

#_write_list : list buf idx ?
	list = 0 : 0
	(buf + idx) # head list
	_write_list (tail list) buf (idx + 1)

`--- Scanners ---`
#tokenize : _ ?
	tok : scan 0
	type : @tok
	type = tok_eof : cons tok 0
	cons tok (tokenize 0)

#scan : _ ?
	skip_space 0
	c : @ch
	c = -1 : cons tok_eof 0
	
	is_digit c : scan_num c
	is_alpha c : scan_id c
	is_op_char c : scan_op 0
	
	c = \` : scan_str 0
	
	c = \ : (
		read_char 0
		cons tok_sep 0
	)
	
	read_char 0
	cons tok_punc c

#skip_space : _ ?
	is_space (@ch) : (
		read_char 0
		skip_space 0
	)
	0

#scan_id : c ?
	chars : _scan_id_rec c
	str : list_to_string chars
	cons tok_id str

#_scan_id_rec : c ?
	is_alpha c | is_digit c : (
		cons c (_scan_id_rec (read_char 0))
	)
	0

#scan_num : c ?
	cons tok_num (_scan_num_rec c 0)

#_scan_num_rec : c acc ?
	is_digit c : (
		val : acc * 10 + (c - 48)
		_scan_num_rec (read_char 0) val
	)
	acc

#scan_op : _ ?
	chars : _scan_op_rec (@ch)
	str : list_to_string chars
	cons tok_op str

#_scan_op_rec : c ?
	is_op_char c : (
		cons c (_scan_op_rec (read_char 0))
	)
	0

#scan_str : _ ?
	read_char 0
	chars : _scan_str_rec (read_char 0)
	cons tok_str (list_to_string chars)

#_scan_str_rec : c ?
	c = \` | c = -1 : (
		read_char 0
		0
	)
	cons c (_scan_str_rec (read_char 0))
`Test Driver for Lexer (Functional)`

#main : _ ?
	src : `x = 123 + `foo``
	
	print_str `Source: `
	print_str src
	print_char 10

	init_lexer src
	tokens : tokenize 0
	_process_list tokens

#_process_list : list ?
	list = 0 : (
		print_str `End of List`
		print_char 10
		0
	)
	tok : @list
	_print_token tok
	_process_list (tail list)

#_print_token : tok ?
	type : @tok
	type = tok_eof : (
		print_str `EOF`
		print_char 10
		0
	)
	
	val : @(tok + 8)
	
	type = tok_id : (
		print_str `ID: `
		print_str val
	)
	type = tok_num : (
		print_str `NUM: `
		print_num val
	)
	type = tok_str : (
		print_str `STR: `
		print_str val
	)
	type = tok_op : (
		print_str `OP: `
		print_str val
	)
	type = tok_punc : (
		print_str `PUNC: `
		print_char val
	)
	type = tok_sep : (
		print_str `SEP`
	)
	
	print_char 10
