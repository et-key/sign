`===========================================
` Sign言語演算子テストコード（最小版）
` 特に仕様と実装の違いが疑われる演算子に焦点
`===========================================

`-------------------------------------------
` 1. Output演算子 (#) の2つの用途
`-------------------------------------------
` 1-1. 前置Export
#public_x : 100

` 1-2. 中置Output（本来はアドレス/バッファへの関連付け）
x : 42
x # _

`-------------------------------------------
` 2. Define演算子 (:) の変換
`-------------------------------------------
` defparameterで正しいか？ defvarやsetfではないか？
a : 10
b : 20

`-------------------------------------------
` 3. ポイントフリー記法の展開
`-------------------------------------------
` 3-1. DirectFold [+]
sum_fold : [+]

` 3-2. 右部分適用 [+ 5]
add_five : [+ 5]

` 3-3. 左部分適用 [10 -]
sub_from_ten : [10 -]

` 3-4. map用 [* 2,]
double_map : [* 2,]

`-------------------------------------------
` 4. Lambda の引数と本体
`-------------------------------------------
` カリー化されるべきか？
add : x y ? x + y
triple : n ? n * 3

`-------------------------------------------
` 5. Product (,) とList構築
`-------------------------------------------
` (list ...) で正しいか？
tuple : 1, 2, 3
pair : x, y

`-------------------------------------------
` 6. Range (~) 演算子
`-------------------------------------------
` loopで正しいか？別の方法はないか？
num_range : 1 ~ 10
step_range : 0 ~ 2 ~ 20

`-------------------------------------------
` 7. 比較演算子の連鎖
`-------------------------------------------
` Sign言語は連鎖比較をサポート
` Common Lispへの変換で正しく処理されるか？
in_range : 0 < x < 100

`-------------------------------------------
` 8. 論理演算の短絡評価
`-------------------------------------------
` Common Lispのandとorは短絡評価だが、
` Sign言語の仕様と一致するか？
lazy_and : x & y
lazy_or : a | b

`-------------------------------------------
` 9. Get演算子 (')
`-------------------------------------------
` 構造アクセスの変換

`-------------------------------------------
` 10. Address ($) と Input (@)
`-------------------------------------------
` メモリ操作の変換
