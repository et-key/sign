# Sign言語のコメント規則

## 基本原則

Sign言語では、「評価されない、または結果が使用されないリテラルはすべてコメント」という独自の原則が採用されています。

## コメントになる構文パターン

### 1. 行頭から始まる文字列リテラル
```sign
`これは有効なコメントです`

`複数行にわたる
`コメントは各行の先頭に`が必要

`行末の`は省略可能
```

### 2. 孤立したリテラル（文内で使用されないもの）
```sign
`数値リテラルが孤立している場合
42

`定義済みでも使われなければコメント
変数名

`未使用の関数定義もコメント
[x ? x * 2]

`計算結果が使われない式もコメント
x + y
```

### 3. IOされない式
```sign
`定義されているが、#でエクスポートされていない
calc : x * 2

`計算されているが出力されていない
result : some_function arg
`上記は実際には定義文なので、resultという識別子で後から参照可能
`しかし#でエクスポートされない限り、外部からは見えない
```

## コメントにならない構文パターン

### 1. 定義文（:演算子を含む）
```sign
`これは定義文（コメントではない）
x : 42

`これも定義文
func : x ? x * 2
```

### 2. エクスポート文（#演算子を含む）
```sign
`エクスポートされるため実行される
#result : calculation

`出力されるため実行される
output_port # data
```

### 3. インデントされた文字列リテラル
```sign
func : x ?
	`これはコメントではない（インデントがあるためエラー）`
	`これはエラー（文字列が閉じられていない）
```

## 判定基準の明確化

| 構文パターン | 位置 | 判定 | 理由 |
|-------------|-----|------|------|
| `文字列` | 行頭 | コメント | 文字列リテラルが孤立 |
| `文字列` | インデント内 | エラー | ブロック内の孤立リテラル |
| `文字列 | 行頭（未閉） | コメント | 行末まで文字列として扱う |
| `文字列 | インデント内（未閉） | エラー | 構文エラー |
| 数値/識別子 | 行頭（孤立） | コメント | 使用されないリテラル |
| x : 式 | 行頭 | 定義文 | 後で参照可能な定義 |
| #x : 式 | 行頭 | エクスポート | 外部から参照可能 |

## IO決定論の詳細

「IOされないコードはコメント」という原則は、以下の階層で判定されます：

1. **即座にIO**: `#`演算子による出力・エクスポート
2. **間接的にIO**: IOされる関数から呼び出される
3. **定義のみ**: 定義されているが使用されない
4. **孤立**: 定義もされず、使用もされない → **コメント**

この仕組みにより、自己文書化コードと最適なリソース利用が自然に実現します。