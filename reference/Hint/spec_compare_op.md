# Sign言語 型および演算仕様

## 1. 比較演算の値返却特性

Sign言語の比較演算は、単なるブール値ではなく具体的な値を返すという特性を持ちます。

### 1.1 基本原則

- 比較条件が `true` と評価される場合、比較演算は **変数項の値** を返します
  - 通常は右辺の値（特に変数）が返されます
  - 右辺が定数リテラルの場合は左辺の変数値が返されます
  - 実質的に、比較に関わる「値として意味のある方」の変数を返します
- 比較条件が `false` と評価される場合、比較演算は **Unit (`_`)** を返します
- この仕組みにより、条件分岐をブール値変換なしに直接値として扱えます

### 1.2 多項式比較の評価順序と変数値の返却

比較演算を含む多項式は、左から右へ順次評価され、各比較の結果は次の比較の入力となります：

```
3 < x = y < 20
```

この式は以下と等価です：

```
[[3 < x & x] = y & y] < 20 & y
```

評価プロセス：
1. `3 < x` が `true` なら **変数 x の値** が返され、それが次の比較の左辺になります
2. `x = y` が `true` なら **変数 y の値** が返され、それが次の比較の左辺になります
3. `y < 20` が `true` なら最終的な結果は **変数 y の値** になります
4. いずれかの条件が `false` なら、その時点で `_` (Unit) が返され、短絡評価により以降は評価されません

比較演算が常に変数値を返すことで、値として意味のある結果が得られ、それを直接使用できるという利点があります。

### 1.3 実用例

この特性により、条件分岐が簡潔かつ表現力豊かに記述できます：

```
getValue : x ?
    x < 0 : -x       // x < 0 が true なら x 自身の値が返され、それが -x の計算に使われる
    x > 100 : 100    // x > 100 が true なら x 自身の値が返され、それが無視されて100が返される
    x                // デフォルトは x 自身を返す
```

変数値の返却は連鎖比較でより明確になります：

```
inRange : x ?
    0 <= x <= 100 & x    // 0 <= x かつ x <= 100 なら x 自身を返す
                         // そうでなければ Unit (_) を返す
```

この例では、`0 <= x` が true の場合に x の値が返され、それが `<= 100` の左辺として使われます。結果が true なら最終的に x の値が返されます。

## 2. 型変換の左辺優先規則

Sign言語は二項演算において型が異なる場合、常に **左辺の型** に合わせて右辺を変換します。

### 2.1 基本原則

- 二項演算の左辺と右辺の型が異なる場合、右辺が左辺の型に変換されます
- 変換できない場合はコンパイルエラーとなります
- 型の一致は「見えない強い静的型付け」の一部として、コンパイル時に検証されます

### 2.2 型変換の例

```
"123" + 456      // 結果: "123456" (文字列結合として評価)
123 + "456"      // 結果: 579 (数値加算として評価、"456"が数値456に変換)
[1, 2] + 3       // 結果: [1, 2, 3] (リスト結合として評価)
3 + [1, 2]       // 結果: 6 (数値加算として評価、[1, 2]が3に変換)
```

### 2.3 リテラルの型表現

Sign言語における数値リテラルは、単なる値ではなく、ハードウェア操作に対応する型として機能します：

- **0x**（16進数）：アーキテクチャのアドレス型、メモリアクセス専用
- **0o**（8進数）：メインフレーム互換のための特殊型
- **0b**（2進数）：レジスタ直接操作型
- **通常の数値**：FPU、SIMD等に最適委譲可能な数値型

これらの区別は、型宣言なしに低レベルハードウェア操作を安全かつ直感的に表現することを可能にします。

## 3. 型とリスト基盤の統一データモデル

Sign言語の型システムは、リストという統一概念を中心に構築されています：

- **文字列** = 文字のリスト（「文字のリストは文字列として扱う」）
- **ブーリアン評価** = 値のパターンマッチング（「空のリストと未実行なラムダ項はfalse」）
- **関数** = 操作のリスト、または演算子の関数化
- **コレクション** = 値のリスト、またはキー・値ペアのリスト

この一貫したアプローチにより、特殊ケース処理が最小化され、言語の学習と理解が容易になります。
