# データスタックとコールスタックの分離: パフォーマンス分析

Sign言語の二重スタック構造（データスタックとコールスタックの分離）がCの標準的な実行モデルと比較して高速かどうか、詳細に分析します。

## 両方のモデルの比較

### 通常のCの実行モデル
- **単一スタック**: 関数呼び出し情報とローカル変数が同じスタック上に混在
- **レジスタ使用**: 呼び出し規約に従った汎用的使用
- **メモリアクセス**: ローカル変数へのアクセスはスタックメモリを経由

### Sign言語の二重スタック構造
- **データスタック**: 値を専用レジスタセット(X8-X15)に保持
- **コールスタック**: 関数呼び出し情報のみをSPベースのスタックで管理
- **明確なレジスタ割り当て**: 用途別の専用レジスタ

## パフォーマンス優位点

1. **メモリアクセス削減**
   ```asm
   # C方式 (スタックフレーム使用)
   LDR X0, [SP, #16]    // 変数aロード
   LDR X1, [SP, #24]    // 変数bロード
   ADD X0, X0, X1       // 計算
   STR X0, [SP, #32]    // 結果保存
   
   # Sign方式 (データスタックレジスタ使用)
   ADD X9, X8, X10      // X8=a, X10=b, 結果はX9に
   ```
   
   Sign方式では、値がレジスタに留まるため、メモリアクセス命令が大幅に削減されます。

2. **キャッシュ効率の向上**
   - データスタックがレジスタ内にあることで、キャッシュミスが減少
   - レジスタは実質的に「L0キャッシュ」として機能

3. **パイプライン効率の向上**
   - 予測可能なレジスタ使用パターンによりCPUパイプラインの効率が上昇
   - メモリアクセス待ちによるストールが減少

4. **SIMD命令との相性**
   - データスタックモデルは、リスト操作の自然なSIMD化に適合
   - 例: `[* 2,] 1 2 3 4` のような操作をNEON命令で効率的に実行可能

## 具体的な速度比較例

### 例1: 単純な数値計算 `(a+b)*(c+d)`

```asm
# C方式
LDR X0, [X29, #a_offset]
LDR X1, [X29, #b_offset]
ADD X0, X0, X1
LDR X1, [X29, #c_offset]
LDR X2, [X29, #d_offset]
ADD X1, X1, X2
MUL X0, X0, X1

# Sign方式 (X8=a, X9=b, X10=c, X11=d)
ADD X12, X8, X9      // a+b
ADD X13, X10, X11    // c+d
MUL X0, X12, X13     // (a+b)*(c+d)
```

**結果**: Sign方式はメモリアクセス命令が4回少なく、理論的には約40%高速

### 例2: リスト処理 `map (* 2) [1,2,3,4]`

```asm
# C方式 (単純ループ実装)
loop:
    LDR W0, [X0], #4    // リスト要素をロード&ポインタ更新
    LSL W0, W0, #1      // 2倍
    STR W0, [X1], #4    // 結果に保存&ポインタ更新
    SUBS X2, X2, #1     // カウンタ減少
    B.NE loop           // 繰り返し

# Sign方式 (データスタックレジスタ使用)
LSL X8, X8, #1        // X8 = X8 * 2 (要素1)
LSL X9, X9, #1        // X9 = X9 * 2 (要素2)
LSL X10, X10, #1      // X10 = X10 * 2 (要素3)
LSL X11, X11, #1      // X11 = X11 * 2 (要素4)
```

**結果**: Sign方式はループオーバーヘッドなしで、ブランチミス予測も発生せず、理論的には3倍以上高速

### 例3: SIMD最適化との組み合わせ

```asm
# Sign方式 (NEON SIMD使用)
LD4 {v0.4s}, [x0]          // 4つの要素をロード
MUL v0.4s, v0.4s, v1.4s    // すべてを一度に乗算
ST4 {v0.4s}, [x0]          // 結果を保存
```

Sign言語のリストベースの統一データモデルは、このようなSIMD最適化と自然に調和します。

## 潜在的な欠点

1. **大きなデータセット**
   - レジスタ数を超えるとスピル発生（パフォーマンス低下）
   - この場合でもインテリジェントなスピル戦略で緩和可能

2. **C ABIとの互換性**
   - 外部C関数呼び出し時に変換オーバーヘッド発生
   - ただし内部コードでは一貫して高速

3. **コンテキスト切り替えコスト**
   - より多くのレジスタの保存/復元が必要

## 結論

**Sign言語の二重スタック構造は、以下の条件下で通常のC方式より高速**:

1. **式の評価**: 特に四則演算などの連続した演算処理
2. **小〜中規模のリスト操作**: レジスタ内で完結する場合
3. **関数型プログラミングパターン**: MAP、FOLD、FILTERなどの高階関数

**理論的な速度向上:**
- 単純な算術演算: 約20-40%の速度向上
- リスト操作: 条件によっては数倍の速度向上
- SIMD最適化との組み合わせ: 最大10倍以上の速度向上も可能

二重スタック構造は特に埋め込みシステムやシステムプログラミングなど、低レベルの最適化が重要な環境で大きな利点をもたらします。データスタックレジスタの一貫した使用は、キャッシュ効率とCPUパイプラインの最適化にも寄与し、全体的なパフォーマンスを向上させる可能性が高いと言えます。