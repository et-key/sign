# Sign Language Reference 

# はじめに []({#はじめに})

プログラミング言語 Sign に興味を持っていただき、ありがとうございます。
元来、数学は言語であるが、万人が理解するわけではない。よって、万人が理解しやすい形で表現できる方法を考えた。という一言につきます。

数学には数多くの記号があります。もちろん、プログラミング言語にも。
しかしそれ以前に、自然言語はどうでしょう？
これら自然言語の記号を、数学的に再定義可能なのでは？

その発想からSignは生まれました。

元来、プログラミングはアートです。だから楽しくなければなりません。
エンジニアが日陰で苦しむ時代を、一緒に終わらせませんか？

より良く考え、より良く作用する言語、Signについて、ともに成長していただければ幸いです。

コンパクトで表現力の高い、挙動が予測できて読めるプログラミング言語、Signを、末永くよろしくお願いします。

岡崎　登

# 前提知識 []({#前提知識})

* 単位元	ある数と演算しても元の数が変わらない値のこと
* 左単位元	左から計算した値を正しいとすること
* 右単位元	右から計算した値を正しいとすること
* 積		いくつかの値を積んでおくこと（リストを構築すること）
* 余積		統合すること、適用すること
* 双対		\+と-など、逆の計算や操作を表すこと、積と余積も双対
* リテラル	対象とすることが出来る値の集まりのこと
* 関数		変化を記述するためのもの（動詞と同じ意味）
* 前置演算子	リテラルの前に置かれる演算子のこと
  （例）	\!5
* 中置演算子	リテラルとリテラルの間に置かれる演算子のこと
  （例）	1 \+ 2
* 後置演算子	リテラルの後ろに置かれる演算子のこと
  （例）	5\!
* 多項式	複数の演算子が使われている式のこと
  （例）	1 \+ 2 \* 3
* 二項演算	中置演算子一つだけで表される式のこと
  （例）	1 \+ 2
* 演算の組	特に、例のような二項演算の組といった説明がされる
  （例）	(1 \+ 2\) \* (3 \+ 4\)
* スコープ	演算時の状態変化を階層化し、お互いに干渉しないために必要
  		特にセキュリティのためにある

# 言語の特徴 []({#言語の特徴})

Signは、既存の言語とは慣習が違う言語である。
以下に特徴をまとめる。

* カッコの種類を問わず、カッコの意味は同じ
* 制御のために使われる単語（予約語）が存在しない
* 制御のための文（ステートメント）はなく、全ての計算は必ず答えを返す
* ブロック構文は、タブ文字によるインデントによって行われる
* 空白は演算子として考察するが、処理系の実装としては演算子とする必要はなく、リテラルの区切りとして扱って良い
* 中置演算子は原則として、前後に空白を必要とするが、中置演算子と解釈できる場合は自動で空白が挿入されるものとする
* 前置演算子、及び後置演算子は対象となるリテラルとの間に空白を入れてはならない
* リテラルだけで意味のない行が実行されることはない
* コードファイル単位でローカルスコープを持ち、importやexportをしない限り、スコープが汚染されることはない
* 空のリストと未実行なラムダ項はfalseである。他はtrueであるため、ブーリアンという型が明示されることはない
* 論理演算は全て短絡評価である
* ビット演算は最適化のためにある。よってビット演算を直接表す演算子や関数は存在しない
* 関数に渡された引数のリストは、リストである
* 計算すべき対象は、全てリストである
* Signのソースコードそのものも、リストである

# コメント []({#コメント})

Signは意味のないリテラルだけの行を実行することはない。
つまり、行頭から始まる文字列リテラルがコメントとなる。
行頭から始まる\`であることが自明であるため、文字列を閉じなくてもコメントとして扱われる。

（例）
```javascript
`これはコメント`
`これはコメント

	`これはコメントではない`
	`これはエラー
```

# リテラル []({#リテラル})

リテラルは、以下の通り。

* 数値
  * 符号なし整数
  * 符号あり整数
  * 浮動小数
  * 分数
  * 16進数
  * 8進数
  * 2進数
* 文字
* 文字列
* リスト
* 関数
* 辞書型
* 識別子
* Unit

## 数値 []({#数値})

数値については、他の言語とほぼ同様。ただし、算術は浮動小数点演算として捉えられたほうが良いという思想はある。
その他の整数値やn進数については、システムを扱う場合にのみ限定されたほうが良いというねらい。
各書式は、以下の通り。

* 符号なし整数
  57

* 符号あり整数
  \-57
  57

* 浮動小数
  3537.45468
  0.357
  187.0235
  \-0.00357
  \-187.0235

* 16進数
  0xAF8534

* 8進数
  0o3574

* 2進数
  0b00101001

## 文字 []({#文字})

文字については、Signは独特のアプローチを取る。

* `\` の直後の任意の1文字は必ず文字として扱います。あらゆる記号（改行など）もそのルールに従う
* 文字列リテラルの中に `\` が存在する場合は、`\` はそのまま文字列の中の1文字としての `\` となる

## 文字列 []({#文字列})

文字列についてのSignの振る舞いは以下のとおり。

* \` で挟まれた文字列が文字列

  （例）
  ```javascript
  `Hello World`
  ```
* 中に改行を含むことは出来ない
* 中に \\ を含めることが出来る

  （例）
  ```javascript
  `sign文字列は\を含めることが出来る`
  ```

## リスト []({#リスト})

リストは原則、リテラルを , で区切ったものである。

* 関数以外のリテラルであれば、空白（スペース）で区切ることも出来る
* リストは原則、タプルリストになる
* 文字のリストは文字列として扱う
* `_` は空のリストと同じ
* 区切りに使われる , は、積を作る演算子である。

## 関数 []({#関数})

関数の表現方法は以下の通り。（関数の使用例については、別項参照）

* 関数は原則、? 演算子（ラムダ構築子）で定義する
  その際、 左辺は引数リストであり、右辺に命令群が入る
  （例）
    ```javascript
    x y ? x + y
    ```
* 全ての演算子は関数であるため、カッコで囲むことで関数として使える
  （例）
  ```javascript
  [+]
  ```
* 関数を部分適用したものも、関数である
  （例）
  ```javascript
  [+ 1]
  ```

## 辞書型 []({#辞書型})

連想配列の振る舞いは、通常のデータ構造をまとめただけのものである。詳細は以下の通り。

* 「key : value」の形式で記載する
* タブ文字によって階層化される
* keyは識別子か文字か文字列となる
* valueは、リテラルであれば何でも値とすることが出来る。

## 識別子 []({#識別子})

この言語には予約語が存在しないため、あらゆる言葉を識別子として使用可能である。詳細は以下の通り。

* `_` 一文字だけを識別子には出来ない
* 記号全般は識別子に出来ない
* 数字から始めることは出来ない
* `_`から開始することは出来る
* 全ての英数字を含めることは出来る
* Asciiコード以外の範囲での文字はすべて使える

## Unit []({#unit})

リストおよび関数の単位元。
普段はNullの意味で使われ、falseの意味でも使われることとなる。詳細は以下の通り。

* `_`一文字だけで表される。
* `_` だけが評価された場合、当然`_`を返す。
* `_` は 単位律の象徴記号として成り立つため、第１引数を返す。

# 演算子 []({#演算子})

演算子は以下の通りの種類になっており、優先度の低い順のほうが基本機能による由来を語ると考えるため、優先順位の低い領域から順に説明する。
ただし、**箇条書きの孫レベルは演算子の優先順位が同じである**。
中置演算子は左単位元を原則とし、両端に空白を置く必要がある。（右単位元であることを留意してほしいものは、後ろに※印をつけておく）
ただし、入力補完機能により大部分の演算子の前後には適切に空白が挿入可能である。（入力補完による空白挿入が効かない物は、後ろに✕マークをつける。）

* export領域
  * `#`	（export　前置演算子）

* 定義、output域
  * `:`	（define　中置演算子　※）　
  * `#`	（output　中置演算子　※）
  

* 構築域
  * ` `	（余積　中置演算子）
  * `?`	（ラムダ構築　中置演算子　※）
  * `,`	（積　中置演算子　※）
  * `~`	（範囲リスト構築　中置演算子）
  * `~`	（連続リスト構築　前置演算子）

* 論理域
  * 論理和
    * `;`	（xor　中置演算子）
    * `|`	（or　中置演算子　✕）
  * 論理積
    * `&`	（and　中置演算子）
  * 否定
    * `!`	（not　前置演算子）

* 比較演算域
  * 比較演算子同士の優先順位はなく、左単位元である
    * `<`	（less　中置演算子）
    * `<=`	（less equal　中置演算子）
    * `=`	（equal　中置演算子）
    * `>=`	（more equal　中置演算子）
    * `>`	（more　中置演算子）
    * `!=`	（not equal　中置演算子）

* 算術演算域
  * 絶対値	(絶対値演算の記述について)
  * 加減
    * `+`	（加法　中置演算子）
    * `-`	（減法　中置演算子　✕）

  * 乗除
    * `*`	（乗法　中置演算子）
    * `/`	（除法　中置演算子）
    * `%`	（剰余　中置演算子）

  * 指数
    * `^`	（冪乗　中置演算子　※）

  * 階乗
    * `!`	（階乗　後置演算子）

* 解決評価域
  * `~`	（展開　後置演算子）
  * `$`	（アドレス取得　前置演算子）
  * `'`	（get　中置演算子）
  * `@`	（get　中置演算子　※）
  * `
  `	（評価　後置演算子）

* import領域
  * `@`	（import　後置演算子）

* input領域
  * `@`	（input　前置演算子）

* ブロック制御
  * インデントブロック
    * `	`	（ブロック構築　前置演算子）
  * インラインブロック構築
    * （インラインブロック開始　前置演算子）
      * `[`
      * `{`
      * `(`
    * （インラインブロック終了　後置演算子）
      * `]`
      * `}`
      * `)`


## `#`	（export　前置演算子） []({#　-#（export　前置演算子）})

（例　defineと一緒に記述）
```javascript
#hello : `hello`
```

## `:`	（define　中置演算子　※） []({#　:-（define　中置演算子　※）})

defineがこの言語で最も優先順位が低い理由は、他の関数や演算を別の名前で定義するために使われるからである。
構文として入れ子が可能で、その場合は辞書型となる。
defineは、常に以下の型となるため、通常の言語では代入演算子と同様のように捉えても良い。

`【識別子】 : 【式】`

（例）
```javascript
nop : _
yep : !_

calc :
	additive :
		add : \+
		sub : \-
	multiply :
		mul : \*
		div : /
		mod : %
```

## `#`	（output 中置演算子） []({#　#-（output中置演算子）})

具体的なIOアドレスやメモリアドレスを取ることも出来る。型としては以下の通り。

`【識別子 or 16進数】 # 【式】`

演算の結果は、Output成功時にはアドレス、失敗時にはUnitを返す。
これは、Inputの双対として整合するための仕様である。

（例）
```javascript
#stream : s ~t ?
	0xFF00 # s
	output t~
```

## ` `	（余積　中置演算子） []({#　-（余積　中置演算子）})
本言語における余積とは**リストへ追加**、**リストの結合**、**関数合成**、**関数適用**に定まる。
空白でトークンを区切るという行為が、演算を表しているという仕様である。
ただし、余積は単なるトークンの区切りという理解で処理系のほうが合理的。
余積と積がキレイに対になる記述として覚えることが、この言語では大事。
複数の半角スペースは単一の半角スペースと同じ意味になる。
演算子は以下の型を取り、それぞれの挙動をその下に列挙する。

`【関数以外】 【式】`

`【識別子 → 関数以外】 【式】`

* 関数以外であれば何でもリスト化する。
* 文字列やタプルリストを結合する。
* 辞書型の結合も可能だが、値の上書きに注意
* 関数適用の余積のほうが演算子の優先順位が高い事に注意（カリー化による関数評価の解決を仕様とするため）

（例）
```javascript
[1 2 3] = 1,2,3
1,2,3 4,5,6 = 1,2,3,4,5,6 = [1 2 3 4 5 6]

`hello` \  `world!` = `hello world!`

sign : `Sign!`
hello : `Hello ` 
hello sign = `Hello Sign!`
```

`【関数】 【式】`

`【識別子 → 関数】 【式】`

* 関数適用を表す。
* そのままの順番で関数合成される。（左単位元である）
* 引数リストに渡す引数の羅列について明示する必要がある場合 , 中置演算子を用いる

（例）
```javascript
[+ 2] [* 5] 4 = 30
[+] [* 2] 1 2 3 4 = 20
[* 2,] [+] 1 2 3 4 = 20
```

## `?`	（ラムダ構築　中置演算子　※） []({#　?-（ラムダ構築　中置演算子　※）})

? はラムダ（無名関数）の定義を行う。
この機能は、Signの中核的な機能であるため、豊富な具体例を以って説明したい。
理由としては、ループと条件分岐はラムダを使うことによって実装されるため。

1. ### ? マークを使う関数定義方法    この方法は、以下に示す型で表される。

   ### 【引数リスト】 ? 【式】 

   * （例１　名前をつけて定義する場合）
     ```javascript
     exp2fn : x y ? (x + y) ^ 2
     ```

   * （例２　名前なしの場合はカッコで囲む必要がある。）
     ```javascript
     [x y ? (x + y) ^ 2]
     ```

   * （例３　条件分岐をする関数を定義したい場合）
     ```javascript
     ABS : x ?
     	x >= 0 : x
     	x < 0 : -x
     ```

   * （例４　条件分岐でも名前なしで定義可能）
     ```javascript
     [x ?
     	x >= 0 : x
     	x < 0 : -x
     ]
     ```

   * （例５　再帰の例、リストを逆にする関数を再帰で記述する場合）
     ```javascript
     reverse : x ~y ? reverse y~, x
     ```

   * （例６　再帰と条件分岐を同時に使う例）
     ```javascript
     collatz : x ?
     	x = 1 : `OK`
     	x % 2 = 0 : collatz x / 2
     	x % 2 = 1 : collatz 3 * x + 1
     ```

2. ### ポイントフリースタイルによる記述    この方法は、演算子を直接関数として扱う方法を提供するが、関数適用を挟むことになるため、演算子の優先順位がなくなることに注意！    型は以下の通り

   `[【演算子】] 【式】`

   * 後置演算子のポイントフリー化は、演算子の前に`_`をつけて表現する
     （例）
     ```javascript
     [!] 5 = !5
     [_!] 5 = 5!
     ```

   * 部分適用をした演算子も、こうした記法に対応する
     型は以下の通り

     
     `[【中置演算子】 【関数以外】] 【式】`

     `[【関数以外】【中置演算子】] 【式】`

   * （例１　部分適用した演算子の例、答えは20）
     ```javascript
     [7 -] [* 5] 3
     ```

   * （例２　ブロック構文によって、カッコを省略した場合の例）
     ```javascript
     [
     	7 -
     	* 5
     ] 3
     ```

3. ### ラムダはリストに対する自然変換を提供する
    この方法は、積演算子である`,`を、カッコの中のラムダ式でテキスト置換するという大まかなイメージを考えると成立する 

   * （例１　左畳み込み　答えは10）
     ```javascript
     [+] 1 2 3 4
     ```

   * （例２　mapは後ろに,演算子をつける　答えは 2 4 6 8）
     ```javascript
     [* 2,] 1 2 3 4
     ```

4. ### 高階関数は参照渡しを使用する
    この方法は、ラムダに対しての現実的な解決策を提供する。

    ```javascript
    map : f x ~y ? @f x, map f y~
    map $[+ 2] 1 2 3 4
    ```

## `,`	（積　中置演算子　※） []({#　,-（積　中置演算子　※）})

`,`は積を表す演算子であり、リストの定義を行うために使われる。
関数以外を空白で区切った場合、積と余積が一意に対応する。
よって、評価結果がリストの構築になる。
積演算子は以下の型を取る。

`【リテラル】 , 【式】`

よって関数も即時で使わないのであれば , で区切ることで引数リストに直接加えることが出来る。

（例）
```javascript
1 , 2 , 3
F [* 2] , 1 , 2 , 3
```

## `~`	（範囲リスト構築　中置演算子） []({#　~-（範囲リスト構築　中置演算子）})

`~`は、前置、後置、中置で意味が異なる点に注意！

`~`中置演算子は、範囲指定など、範囲を抽象的に取り扱うことが出来る。型は以下の通り。

`【文字】 ~ 【文字】`
`【数値】 ~ 【数値】`

範囲リスト構築の演算子は、優先順位が低いので要注意。
リストから特定の範囲を取得する場合にも使いやすい。

（例）
```javascript
[1 ~ 10]
[* 2,] [1 ~ 10] ‘ [3 ~ 5] = 8 , 10 , 12
[\a ~ \z]
```

## `~`	（連続リスト構築　前置演算子） []({#　~　（連続リスト構築　前置演算子）})

`~`は、前置、後置、中置で意味が異なる点に注意！

`~`前置演算子は、「引数リストの残りを、一つ上のスコープのリストに閉じ込める。」と考えると良い。

型は以下の通り。

`~【識別子】 ? 【式】`

（例１　冒頭以外の残りをリストとして返す関数）
```javascript
tail : x ~y ? y
```
（例２　リストの長さを返す関数を、\~ 後置演算子と一緒に使って書く）
```javascript
length : [x y ~z ?
y = _ : x
	length x + 1, z~
] 0
```

## `;`	（xor　中置演算子） []({#　;　（xor　中置演算子）})

ここからは、具体的な演算操作についての演算子を解説する。

`;`は、排他的論理和のための中置演算子である。
Signでは、空のリストがfalseとなっているため、明示的なブーリアンが無い。
この演算子は、あくまで論理演算である。
論理演算は、全て短絡評価となる。

## `|`	（ or　中置演算子） []({#　|　（or　中置演算子）})

`|`は、論理和のための中置演算子である。
この演算子は、あくまで論理演算である。
論理演算は、全て短絡評価となる。

## `&`	（and　中置演算子） []({#　&　（and　中置演算子）})

`&`は、論理積のための中置演算子である。
この演算子は、あくまで論理演算である。
論理演算は、全て短絡評価となる。

## `!`	（not　前置演算子） []({#　!　（not　前置演算子）})

`!` は、否定のための前置演算子である。
`!` の後置演算子は階乗となるので、区別してほしい。
この演算子は、あくまで論理演算である。
論理演算は、全て短絡評価となる。

## `<`	（less　中置演算子） []({#　<-（less　中置演算子）})

ここからは、比較演算子の説明となる。
Signでは、全ての比較演算子の多項式を記述できる。
理由は、各項の比較演算が、Unitか解となる明示的な値を返すからである
次項からはラムダ項を返すことになるがラムダ項自体がfalseと定義されている。
もし、ラムダ項が有効な関数であるか否かを問いたいならば、\$前置演算子による有効アドレスを獲得することになる。
\$の詳細は現仕様上非公開である。

less は、左のほうが小さければ真になる。

（例　上と下は同じ意味）
```javascript
[x y ? 3 < x = y < 20]
[x y ? [[[3 < x & x] = y & y] < 20 & y]]
```

## `<=`	（less equal　中置演算子） []({#　<=　（less-equal　中置演算子）})

less equal は、左が右以下なら真になる。

## `=`	（equal　中置演算子） []({#　=　（equal　中置演算子）})

equal は、左と右が等しいなら真になる。
equal は、リストや文字列の比較も可能である。

## `>=`	（more equal　中置演算子） []({#　>=　（more-equal　中置演算子）})

more equal は、左が右以上なら真になる。

## `>`	（more　中置演算子） []({#　>　（more　中置演算子）})

more は、左のほうが大きければ真になる。

## `!=`	（not equal　中置演算子） []({#　!=　（not-equal　中置演算子）})

not equal は、左と右が等しくないなら真になる
not equal は、リストや文字列の比較も可能である。

## 絶対値	(絶対値演算の記述について) []({#　絶対値演算の記述について})

ここからは、算術演算子の解説をする。
Signでは、絶対値は `|` で囲んだ式で表され、絶対値ブロックとしての演算ルールを持つ。
この際or演算子との区別は記号の両脇に空白が存在するときはor演算子として区分する。
（例）
```
||x + y| - 5|
```

## `+`	（加法　中置演算子） []({#　+-（加法　中置演算子）})

加法…つまり、一般的な足し算を行う演算子である。

## `-`	（減法　中置演算子） []({#　--（減法　中置演算子）})

減法…つまり、一般的な引き算を行う演算子である。

## `*`	（乗法　中置演算子） []({#　*-（乗法　中置演算子）})

乗法…つまり、一般的な掛け算を行う演算子である。

## `/`	（除法　中置演算子） []({#　/-（除法　中置演算子）})

除法…つまり、一般的な割り算を行う演算子である。

## `%`	（剰余　中置演算子） []({#　%-（剰余　中置演算子）})

剰余…つまり、余りだけを算出する演算子である。

## `^`	（冪乗　中置演算子　※） []({#　^-（冪乗　中置演算子　※）})

冪乗…つまり、指数計算をする演算子である。
右辺を除法で記載した場合は、累乗根の計算が可能。
右辺が負の数になる場合は、割り算の連続になる。

## `!`	（階乗　後置演算子） []({#　!-（階乗　後置演算子）})

階乗は後置演算子となっている。
単純にシンタックスシュガーで実現する。

（例　答えはいずれも120）
```javascript
5!
[*] [1 ~ 5]
1 * 2 * 3 * 4 * 5
```
## `~`	（展開　後置演算子） []({#　~-（展開　後置演算子）})

`~` は、前置、後置、中置で意味が異なる点に注意！

`~` 後置演算子は、「対象のリストを、一つ下のスコープに展開する。」と考えると良い。型は以下の通り。

【リスト or 辞書型 or 文字列】\~
【識別子 → リスト or 辞書型 or 文字列】\~

（例１　引数を渡すときに使う場合）
```javascript
a : 1 2 3 4 5
f : x y z ? z

f a~
```

（例２　残余引数リストの展開）
```javascript
a : 1 2 3 4 5
reverse : x ~y ? reverse y~, x

reverse a~
```

（例３　インポートと一緒に使う）
```javascript
IO@~
say `hello!`
```

## `$`	（アドレス取得　前置演算子） []({#　$　（アドレス取得　前置演算子）})
ある識別子の値の保持を行っているアドレスを返す。
型は、以下の通り。

`$【識別子】`

「`@`前置演算子」や「`#`中置演算子」と組み合わせることで、ポインタ（レジスタ関節アドレッシング）を可能にする。
例
```
i : `hello`
@$i = i
@$i = `hello`

`つまり@$はID（何もしないのと同意だが、@$は内包値に対する自己関手とも言える）
@$ = _

`危険な上書き（メモリ解放）
$i # _

`安全なメモリ解放
i : _

`逆向きの演算はiがhexでないため、解なし
@i = _
$@i = _
```
```
a : 0x8000
a # 0xF000

`ダブルポインタが成立
@a # `hello`

`演算の確認
$@a = 0xF000
@$a = 0x8000
@$a  = a

`ダブルポインタ成立の確認（演算子の順番について、随伴関手定理に従っている）
@@$a = @a
@$@a = @a
```

## `'`	（get　中置演算子） []({#　’-（get　中置演算子）})

`'`中置演算子は、対象から特定の値を得る。該当する値がなければUnitを返す。
なお、後ろに : 中置演算子をつけることで、対象の値を書き換える事が可能。
型は以下の通り。

`【辞書型 or リスト or 文字列】 ' 【識別子 or 文字列 or 数値】`
`【識別子 → 辞書型 or リスト or 文字列】 ' 【識別子 or 文字列 or 数値】`

（例１　変えない場合）
```javascript
car :
	brand : `Foo`, `Bar`, `Baz`

car ' brand ' 0
```
（例２　変える場合）
```javascript
car :
	brand : `foo`, `Bar`, `Baz`

car ' brand ' 0 : `Foo`
```

## `@`	（get　中置演算子　※） []({#　@（get　中置演算子　※）})

`@`中置演算子は、特定の値を対象から得るので、`'`の右単位元バージョンである。
なぜ、右単位元と左単位元がそれぞれ存在するかは、import時の記述が統一されるため。
該当する値がなければUnitを返す。
型は以下の通り。

`【識別子 or 文字列 or 数値】 @ 【辞書型 orリスト or 文字列】`
`【識別子 or 文字列 or 数値】 @ 【識別子 → 辞書型 or リスト or 文字列】`

（例）
```javascript
car :
	brand : `Foo`, `Bar`, `Baz`

0 @ brand @ car
```

## `↵`	（評価　後置演算子） []({#（評価　後置演算子）})

評価演算子は、処理系としてはトークンのまとまりを行として区切るものと同じ意味。よって改行を用いる。
改行とはつまり、その行を評価して良いという演算子に他ならないという見方も可能なだけである。

## `@`	（import　後置演算子） []({#　@　（import　前置演算子）})

`@`後置演算子は、ファイルやライブラリをインポートする際に使われる。型は以下の通り。

`【識別子 or 文字列】@`

（例１　標準ライブラリのインポート）
```javascript
IO@ ' say `hello`
```

（例２　自分のプロジェクトから読み込み　myObjectの中に\#myFuncの記述があるなら、これで読み取り可）
```javascript
myFunc : myFunc @ `myObject`@
```

## `@`	（input　前置演算子） []({#　@　（input　前置演算子）})

`@前置演算子は、アドレス値に対する参照…つまりinputを取り扱う
型は以下の通り。

`@【16進数】`
`@【識別子 → 16進数】`

演算の結果である返り値は、生のストリームとなるため、他の演算や関数と組み合わせて使う。

（例）
```
getStream : ~@0x8000
```

## ブロック構築について []({#　ブロック構築について})

ブロック構築　前置演算子は、インデントによるブロックの構築となる。

（例　タブのあとの改行がカッコで括られた中の式と同じになる）
```javascript
[x y ?
	x = y = _ & `Nothing` |
	x + y
]

[x y ? [[x = y = _ & `Nothing`] | [x + y]]]
```
以下、カッコによるインラインブロックの構築も同じ意味であるため省略する。

# 型の記述

`"`で囲んだ部分は、型の定義及び取得として扱われる。
```
"f" : "Number" "Number" "Number"
f : x y ? x + y
```

型による分岐
```
typeCase : x ?
  "x" = "Number" : x * 2
  "x" = "String" : x
```

任意の型定義は、基本として非推奨機能
型よりもリストの範囲指定や直接、対象値に対する振る舞いを記述するのが良い
理由：過度な抽象化の遠因となるため（抽象を構造として担保するのは言語側の責任であると解釈される）
