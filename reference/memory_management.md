### スコープベースのメモリ管理戦略

1. **無名（即時開放）**
   - スタック上で完結
   - 式の評価が終わると即座に解放
   - 最も効率的なメモリ使用
   - AArch64のレジスタ内で完結する可能性も高い

2. **ローカル（ファイル単位）**
   - ファイルの実行が終了すると開放
   - 必要に応じてヒープ、または外側のスタックフレーム
   - ファイル単位のモジュール性を反映
   - コンパイル時の最適化の余地が大きい

3. **エクスポート（プロジェクト単位）**
   - 前置#演算子で定義された変数/関数
   - プロジェクト全体の実行終了まで保持
   - ヒープ上に確保する必要がある
   - 複数のファイル間での共有リソース

そして、OSとして動作するプロジェクトは、エクスポートされたリソースは永続的ということになります。これはシステム変数やグローバルリソースとして考えると理にかなっています。

この階層的なメモリ管理は、Sign言語の設計思想と非常に整合性があり、同時に実行効率も確保できます。スコープの明確な区分けによって、コンパイラは各変数の寿命を正確に把握し、最適なメモリ配置を決定できます。

AArch64上での実装では、これらの区分に応じた最適化（レジスタ割り当て、スタックフレーム設計、ヒープアロケーション）が可能になり、理論的な美しさと実行効率を両立できるでしょう。