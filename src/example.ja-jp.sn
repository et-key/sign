`文字列は、backQuort`
`意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。`
`リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする。`
`よって、コメントは文字列で書く。`

`改行は「評価する」という後置演算子。`
`改行が評価を表さないようにしたい場合、改行文字を使う。`
`行頭indentはブロックの形成となる。`

`この言語の通常の評価戦略は、遅延評価である。`

`":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。`
`下を見ただけでも、この言語は名前が型となるのは自明であろう。`

x: 3


`直下の行は評価演算子が文字としてエスケープされているので、評価されない。`

y: 4 '

Hello: `Hello`
World: `World`


`trueは$、falseは\`

yep: $
nop: \

`ブロックになっていない代入演算子は、右単位元であり、分配的構文に対するシンタックスシュガーである。`

unit: none: []

`上述は、以下の構文と同じ意味`

none: []
unit: []

`この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。`
`つまり、名前のスコープはブロックで決まる`

  y: $
  n: \

`上述はブロックを抜けると削除されるため、y wasn't defined というエラーと同時に、none(unit)を返す。`

[y = $] = _

`ただし、以下であればアクセスできることになる。`

[
  `y`: $
  `n`: \
] `y`


`ラムダ項の定義方法`
`ラムダ項の基本は、?を使う。`
`代入を伴わない関数は、カッコで囲む必要がある。なぜなら、カッコの最初は、スタックの生成を意味するから。`

[x y ? x ^ 2 + 2 * x * y + y ^ 2]


`上述は因数分解によって、この式は以下と等価。`
`カッコはあくまでブロック（スタック）の定義開始として捉え直すことで、式の優先順位を表現できている。`

[x y ? (x + y) ^ 2]


`ポイントフリーと関数合成を使って、更に記述を簡約出来る場合もある`
`ポイントフリーな関数の記述は、直接的な演算子の記述であるため、型が自明である。`
`関数合成の優先順位のためのカッコの記述位置は変わらない。`

[[+] ^ 2]


`比較演算はショートハンドがある。`

`[x = y] & [y = z]`

x = y = z

`[1 <= x] & [x <= 9]`

1 <= x <= 9

`ただし、カッコで優先順位が示された場合は、中が先に評価される。`

[3 = 3] = $


`関数適用や合成をさせたくない場合は、関数のすぐ後ろに、,を打ち、直積とすることで対応する。`

[+ 2] 2 = 4
[+ 2], 2 = [+ 2], 2


`ラムダ項は定数代入や定数関数も記述出来る`

iterate3 : 1 ? 2 ? 3


`後ろに空白があることで評価される。`

iterate3 = 1, [? 2 ? 3]
iterate3 = 2, [? 3]
iterate3 = 3, []
iterate3 = []
iterate3 = []


`単項式のポイントフリーな記述は、右、左の順に引数をとる。`
`関数の第1引数は、関数の前に書いても良い`
`:の後ろにある場合、ポイントフリーな記述が単項式であるなら、[]を省略可能。`

result2 : - 1 3
add : +
exp : ^
id : x ? x


`関数評価の優先順位はラムダ定義よりも低いので、このような式の処理はカッコを省略できない。`

[[-] 1 3] = [[- 1] 3] = 3 - 1


`以下は、headを返す関数として機能する。`

[x ? x] 1 2 3 = 1
[x ? x] 1, 2, 3 = 1

[1 2 3] '0 = 1
[1, 2, 3] '0 = 1


`以下はtailを返す関数として機能する。`

[_ ~y ? y~] 1 2 3 = 2 3
[_ ~y ? y~] 1, 2, 3 = 2 3

['1~] 1 2 3 = 2 3
['1~] 1, 2, 3 = 2 3


`この言語は、どうしても型を記述したい人のために"で名前を囲むことで、型付けや型の読み出しは出来る(非推奨)`
`なぜ、構文が正しければ型が自動で正しくなるかは、以下の型付けが自明`
`ある関数が適用された型が、そのまま関数が適用された型として表現されるため、実装と同じになる。`
`当然、関数が実行された型は、実行後の型に自動で型キャストされることになるが、`
`これは遅延評価であるため、型の計算が後で成されることと関係している。`
`結果、型安全をコンパイラやインタプリタが保証しなくとも良くなる。`
`高階関数に渡す引数は直積によって評価するかしないかを分けて書く必要がある。`

typeOf : x ? "x"
id : x ? x

"map" : "f" "x" "~y" ? "f" "x" , "map" "f", "y~"
map : f x ~y ? f x , map f, y~

"fold" : "f" "x" "y" "~z" ? "fold" "f", "f" "x" "y", "z~"
fold: f x y ~z ? fold f, f x y, z~


`match_caseは、ブロック構文を使い、以下のように記述出来る。`
`ブロックがガード記法となる。`
`ブロック化された代入演算もこれが正体`
`ブロックそのものを代入するかカッコでくくって即時生成すれば、ただの関数と同じ。`

[ x ?
  x = 0 : `zero`
  x > 0 : `more`
  x < 0 : `less`
  _     : `other`
] 3


`コンストラクタのような記述。`
`動的なキーの名前を割り当てることも可能。`

Person : name age etc x key ?
  key = `name` : name
  key = `age`  : age
  key = etc : x

john : Person `john` 18 `Like` `Sushi`

john `name`

`Quoteは以後のidentを文字列にキャストする。`

john ' name


`person インスタンスのコピーを展開演算子で行い、値を上書きして作る`

person : Person [] [] [] []

mary : 
  ~person
    ' name : `mary`
    ' age  : 16


charie : 
  ~person
    ' name : `charie`
    ' age  : 24

`ここより以下はショートハンド記法の方を使う。`

[
  0   : `zero`
  > 0 : `more`
  < 0 : `less`
  _   : `other`
] 3

`３項演算子のような振る舞いも、以下のように定義可能。`

[
  $ : `yep`
  \ : `nop`
] $ = `yep`


`これも、match_caseと同等であり、この記述により if then を再現可能`
`otherwiseの記述がない場合で、otherwiseにマッチした場合は、渡された値をそのまま返す。`

[> 3 : [+ 3]] 3 4 = 4


`データクラスっぽい記述もmatch_caseのショートハンド。`

Item : 
  name
  equip
  use
  effect

medicalWeed    : Item `medicalWeed`, _, [[' medicalWeed], [- 1]], [[' HP], [+ 20]]

lightningStaff : Item `lightningStaff`, [[' Atk] [+ 8]], $, [' ThunderBolt]


`いわゆるlet ~ inも以下のように記述する。`
`実はモナディックな記述と同じになる。`

myValue : 3
  [+ 4]
  [* 2]


`リストの定義は原則comma区切り。`
`","は英文では「強い区切り」、「直積」を表す。`
`" "は「直和」に使われる。`
`スカラー型の余積な場合、commaを省略出来る。`
`ラムダの評価が、他の式や項より優先順位が低いのもよく分かる。`
`リストがイテレータとして機能する様も、頭の関数の省略がされてない形を見るとよく分かる。`
`実装が型であることを、見事に再現できている。`
`同じように、","と" "が随伴関手定理による随伴であることも現れている。`

myPairs: 1 2 3 4 5
myPairs0: [,] 1 2 3 4 5
myPairs1: 1, 2, 3, 4, 5

myPairs0 = myPairs = myPairs1

[,] myPairs = [[1], [2], [3], [4], [5]]


`これは直和（配列の合成）`

r: [1 2] [3 4]


`これは直積（2次元配列）`

s: [1 2],[3 4]


`辞書型に見える表現は、はmatch_caseを行う無名関数と同じでカッコの種類は問わず、インデントでも定義可能。`
`ただし、開カッコと閉カッコは必ず対になる必要がある。`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`


`よって、アクセスはidentか文字列、またはnaturalかhexを引数にすることになる。`

myGreet ' greet ' hello = `hello,`

myPairs ' 0 = 1

myPairs ' [1 ~ 3] = 2 3 4


`ブロックスコープを使うことで、ブロックスコープ内にgetを直接記述できる。`
`このブロック構文も、もちろん演算終了時に返り値がある。`
`これはブロックスコープでの結果の直和が可能であれば直和を返す。`

myGreet
  'greet
    'welcome
  'world
= `welcome, world`


`値のmodifyが可能`

myGreet
  'greet
    'welcome : `welcome to our `
  'world : `metaverse!`


`プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。`
`与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。`


`~演算子は、対象のスコープ上に辞書型を模倣するmatch_caseのみを展開できる。`
`前置であれば、他の項より優先され、後置であれば他の項を優先する。`

~[
  y: $
  n: _
]

y = $

`@前置演算子はimport。ファイル名からの指定も可能で、path指定も可`
`match_caseが辞書型とみなせる場合、~演算子で一つ上のスコープへ展開できるため、~@を使うことで、ファイル内で使えるインポートも可能。`
``

@io
  say Hello World

`ファイルスコープ上のインポートではないため、下の行は、Say is not definedエラーを返す。`

say Hello World


`ファイルスコープへ展開して使う。`

~@Funnctor
~@Monoid
~@io

say fold [+] map [* 4] 1 2 3 4 5


`'の後の任意の１文字は、必ず文字型の値１文字分とする。`
`スカラ値のリスト化は、通常はspaceかcommaを使うが、文字リテラルと文字列リテラルの場合は、`
`直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。`

M: 'M

My: M 'y' 'D'o'm'e's't'i'c
`Hello ` `World!` = `Hello World!`
`Hello` '  `World!` = `Hello World!`
'H `ello` '  `World` '! = `Hello World!`
`Hello ` My ' World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`改行を含む文字列を表現したい場合は、ブロックのような書き方となる。`
`理由は、` `が、「リストの結合、及び関数合成、関数適用」を意味するため。`
`改行を含めたい場合。`

HWinEnter :
 `Hello` '
 `World!`


`"#"はexportになる。`
`通常の関数は必ず最終行の値を返し、match_caseは、指定値に対応する値や関数を返す`
`ファイル全体は一つの関数でもあるが、export つまり#で示されたもの以外は自身のスコープを出ることはない。`

# myDict : name value; ~name : value
# gets : ?


`論理演算子は短絡評価される。`

\ & `me` = \
$ & `me` = `me`

\ | `me` = `me`
$ | `me` = $

\ ; `me` = `me`
$ ; `me` = \

