`文字列は、backQuort`
`意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。`
`リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする。`
`この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。`

`改行は「評価する」という後置演算子。`
`行頭indentはブロックの形成となる。`

`この言語の通常の評価戦略は、遅延評価である。`

`":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。`
`下を見ただけでも、この言語は名前が型となるのは自明であろう。`

x: 3
y: 4

Hello: `Hello`
World: `World`


`trueは$、falseは_`

yep: $
nop: _

`ブロックになっていない代入演算子は、右単位元であり、分配的構文に対するシンタックスシュガーである。`

unit: none: []

`上述は、以下の構文と同じ意味`

none: []
unit: []

`この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。`
`つまり、名前のスコープはブロックで決まる`

  y: $
  n: _

`上述はブロックを抜けると削除されるため、y wasn't defined というエラーと同時に、none(unit)を返す。`

(y = 1) = []

ただし、以下であればアクセスできることになる。

[
  y: $
  n: _
] ' y


`ラムダ項の定義方法`
`ラムダ項の基本は、?を使う。`
`代入を伴わない関数は、カッコで囲む必要がある。なぜなら、カッコの最初は、スタックの生成を意味するから。`

[x y ? x ^ 2 + 2 * x * y + y ^ 2] 3 4


`上述をプレースホルダ記号@を使って記述し直す。`
`関数であることを明示するため、頭に?を付けておいても良い。`

[@1 ^ 2 + 2 * @1 * @2 + @2 ^ 2] 3 4

[? @1 ^ 2 + 2 * @1 * @2 + @2 ^ 2] 3 4


`上述は因数分解によって、この式は以下と等価。`
`カッコはあくまでブロックの定義開始として捉え直すことで、式の優先順位を表現できている。`

[(@0 + @1) ^ 2] 3 4

[? (@0 + @1) ^ 2] 3 4


`インクリメンタルな引数呼び出しは、プレースホルダの添字を省略可能。`
`カッコは同種でも問題が無い。`

[[@ + @] ^ 2] 3 4

[? (@ + @) ^ 2] 3 4

`ポイントフリーと関数合成を使って、更に記述を簡約出来る場合もある`
`ポイントフリーな関数の記述は、直接的な演算子の記述であるため、型が自明である。`

 [^ 2] [+ 3] 4


`第１引数を頭に書いた場合の関数合成は、左単位元となる。`

4 [+ 3] [^ 2]

`関数適用や合成をさせたくない場合は、関数のすぐ後ろに、,を打ち、直積とすることで対応する。`

result8 : [@0 @0 @1] [+ 2], 4


`単項式のポイントフリーな記述は、右、左の順に引数をとる。`
`関数の第1引数は、関数の前に書いても良い`
`:の後ろにある場合、ポイントフリーな記述が単項式であるなら、[]を省略可能。`

result2: - 1 3
add : +

[-] 1 3 = [- 1] 3
[-] 1 3 = 3 - 1
[-] 1 3 = [@1 - @0] 1 3


`以下はid射と同じで、命名せずに記号のみでid射の即時生成、即時適用、即時削除を可能にしている。`
`最後のプレースホルダはrest parameterとなる事により、引数は必ずリストとして機能する。`
`よって、リストを渡すことと、多引数を渡すことは、この言語では自明に等しくなる。`
`理由は、この言語の背景にあるnatural equivalence（自然同値、自然同型）が、随伴関手としてみなされるためである。`
`そのため、空白とカンマが随伴関手によって説明できる。`
`?もこのnatural equivalenceの系で説明できる。`
`これは、この言語の究極系の一つである。`
`なぜなら、id:と命名しても良いが、あえて命名しないことによって、型の記述が無用となる。`

[? @] 1 2
[? @] 1,2
[@] 1 2
[@] 1,2


`以下は、headを返す関数としてうまく機能する。`

[@0] 1 2 3 = 1


`以下はtailを返す関数として、うまく機能する。添字の省略がなされていないので、rest parameterを明示している。`

[@1~] 1 2 3 = 2 3


`ラムダに代入演算子で命名する場合、添字省略型プレースホルダのみで記述された関数は、? またはカッコを省略できない。`

add : +
exp : ^

id : ? @
id_0 : [@]
id_1 : @0~

eval : ? @ @
eval_0 : [@ @]
eval_1 : @0 @1~

`余談だが、rest_parameterを引数とする場合の記述として以下も可能ではある。`
`これはすぐ下のプレースホルダと等価である。`
`@'はcalleeを指すため、不動点が容易に再現できる`
`この言語は、どうしても型を記述したい人のために"で名前を囲むことで、型付けや型の読み出しは出来る(非推奨)`
`なぜ、構文が正しければ型が自動で正しくなるかは、以下の型付けが自明`
`ある関数が適用された型が、そのまま関数が適用された型として表現されるため、実装と同じになる。`
`当然、関数が実行された型は、実行後の型に自動で型キャストされることになるが、`
`これは遅延評価であるため、型の計算が後で成されることと関係している。`
`結果、型安全をコンパイラやインタプリタが保証しなくとも良くなる。`

typeOf : "@"
id : [@]

"map" : "f" "x" "~y" ? "f" "x" , "map" "f", "y~"
map : f x ~y ? f x , map f, y~

"map" : "@0" "@1" , "@'" "@0" "@2~"
map : @0 @1, @' @0, @2~

"fold" : "@'" "@0", "@0" "@1" "@2" , "@3~"
fold : @' @0, @0 @1 @2, @3~


`map、foldを無名のままで適用していく。`

result30 : [@' @0, @0 @1 @2, @3~] [+] [@0 @1, @' @0, @2~] [* 2] 1 2 3 4 5


`match_caseは、ブロック構文を使い、以下のように記述出来る。`
`ブロックがガード記法となる。`
`ブロック化された代入演算もこれが正体`
`ブロックそのものを代入するかカッコでくくって即時生成すれば、ただの関数と同じ。`
`よってこれは辞書型と等価である。`
`よってid射がotherwiseとなるのは自明`

[
  0 : `zero`
  > 0 : `more`
  < 0 : `less`
  @ : `other`
] 3


`３項演算子のような振る舞いも、以下のように定義可能。`

myTest0 :
  $ : `yep`
  _ : `nop`

myTest0 $ = `yep`


`代入する場合。`

myTest1 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  _ : `false`
  [] : `none or unit or otherwise`


myTest1 4 = `more`


`代入演算子の頭がラムダの場合は、つまりif thenと同義となる。if then はelseがunitを返すだけ。`
`しかしこれも、match_caseと同等である。`

[[@0 > 3] : @1 + 3] 3 4


`いわゆるlet ~ inも以下のように記述する。`
`実はモナディックな記述と同じになる。`

myValue : 3
  [+ 4]
  [* 2]


`リストの定義は原則comma区切り。`
`","は英文では「強い区切り」、「直積」を表す。`
`" "は「直和」に使われる。`
`要素に任意に要素を追加出来る。`
`スカラー型の余積がリストを形成するので、commaを省略出来ることもある。`
`[@] は、id射の実装をプレースホルダで示したもの`
`ラムダの評価が、他の式や項より優先順位が低いのもよく分かる。`
`リストがイテレータとして機能する様も、頭の関数の省略がされてない形を見るとよく分かる。`
`実装が型であることを、見事に再現できている。`
`@ と , が、随伴関手定理による随伴であることも、キレイに現れる。`
`同じように、,とspaceが随伴関手定理による随伴であることも、現れている。`

myPairs: 1 2 3 4 5

myPairs00: 1 2 3 4 5
myPairs01: [@] 1 2 3 4 5
myPairs02: [@, @] 1 2 3 4 5
myPairs03: [@0, @1~] 1 2 3 4 5
myPairs05: [,] 1 2 3 4 5

myPairs10: 1, 2, 3, 4, 5
myPairs11: [@] 1, 2, 3, 4, 5
myPairs12: [@, @] 1, 2, 3, 4, 5
myPairs13: [@0, @1~] 1, 2, 3, 4, 5
myPairs14: [,] 1, 2, 3, 4, 5


`これは直和（配列の合成）`

r: [1 2] [3 4]


`これは直積（2次元配列）`

s: [1 2],[3 4]


`辞書型に見える表現は、はmatch_caseを行う無名関数と同じでカッコの種類は問わず、インデントでも定義可能。`
`ただし、開カッコと閉カッコは必ず対になる必要がある。`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`


`よって、アクセスはidentか文字列、またはnaturalかhexを引数にすることになるが、getという評価関数が必要となる。`
`つまり、lensやprismとして作用するコモナドが暗示されることになる。`

myGreet ' greet ' hello = `hello,`

myPairs ' 0 = 1

myPairs ' [1 ~ 3] = 2 3 4


`ブロックスコープを使うことで、ブロックスコープ内に添え字に対するgetを直接記述できる。`
`これはファイルの内外関係なくimport演算子で統一する。`
`このブロック構文も、もちろん演算終了時に返り値がある。`
`これはブロックスコープでの結果の直和が可能であれば直和を返す。`

@myGreet
  greet ' welcome
  world
= `welcome, world`


`値のmodifyが可能`

@myGreet
  greet ' welcome : `welcome to our `
  world : `metaverse!`


`,を使うことで、わざわざブロック化しなくて良い長さの定義の略記が可能。`

point: x: 0, y: 3, z: 2


`プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。`
`与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。`


`~演算子は、対象のスコープ上に辞書型を模倣するmatch_caseのみを展開できる。`
`前置であれば、他の項より優先され、後置であれば他の項を優先する。`

~[
  y: $
  n: _
]

y = $

`@前置演算子はトップレベルで使う時はimportの役も負う。ファイル名からの指定も可能で、path指定も可`
`match_caseが辞書型とみなせる場合、~演算子で一つ上のスコープへ展開できるため、~@を使うことで、ファイル内で使えるインポートも可能。`
``

@io
  say Hello World

`ファイルスコープ上のインポートではないため、下の行は、Say is not definedエラーを返す。`

say Hello World


`ファイルスコープへ展開して使う。`

~@Funnctor
~@Monoid
~@io

say fold [+] map [* 4] 1 2 3 4 5


`\の後の任意の１文字は、必ず文字型の値１文字分とする。`
`スカラ値のリスト化は、通常はspaceかcommaを使うが、文字リテラルと文字列リテラルの場合は、`
`直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。`

M: \M

My: M \y\ \D\o\m\e\s\t\i\c
`Hello ` `World!` = `Hello World!`
`Hello` \  `World!` = `Hello World!`
'H `ello` \  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`改行を含む文字列を表現したい場合は、ブロックのような書き方となる。`
`理由は、` `が、「リストの結合、及び関数合成、関数適用」を意味するため。`
`改行を含めたい場合。`

HWinEnter :
 `Hello` \
 `World!`


`"#"はexportになる。`
`通常の関数は必ず最終行の値を返し、match_caseは、指定値に対応する値や関数を返す`
`ファイル全体は一つの関数でもあるが、export つまり#で示されたもの以外は自身のスコープを出ることはない。`

# myDict : name value; ~name : value
# gets : ?


`論理演算子は短絡評価される。`

_ & `me` = _
$ & `me` = `me`

_ | `me` = `me`
$ | `me` = $

_ ; `me` = `me`
$ ; `me` = _


`構文木に対するアプローチは自然変換と考えられる。`
`以下はそうした自然変換に対する考察。`
`畳み込みと積が随伴関手に該当するとは、,となんらかの中置演算子を置換することと同義である。`
`そのような表現ができる構文を考えておきたい。`

