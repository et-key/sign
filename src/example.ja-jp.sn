`文字列は、backQuort`
`意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。`
`リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする`
`この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。`

`改行は「評価する」という後置演算子。`
`行頭indentはブロックの形成となる。`

`この言語の通常の評価戦略は、遅延評価である。`

`":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。`
`下を見ただけでも、この言語は名前が型となるのは自明であろう。`

x: 3
y: 4

Hello: `Hello`
World: `World`

yep : $
nop : _

`ブロックになっていない代入演算子は、右単位元であり、分配的構文に対するシンタックスシュガーである。`

unit: otherwise: none: @

`上述は、以下の構文と同じ意味`

otherwise: @
none: @
unit: @

`この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。`
`つまり、名前のスコープはブロックで決まる`

  y: $
  n: _

`未定義であるため、y wasn't defined というエラーと同時に、none(unit)を返す。`

(y = $) = @

ただし、以下であればアクセスできることになる。

[
  y: $
  n: \
] ' y


`ラムダ項の定義方法`
`ラムダ項の基本は、?を使う。`
`代入を伴わない関数は、カッコで囲む必要がある。なぜなら、カッコの最初は、スタックの生成を意味するから。`

[x y ? x ^ 2 + 2 * x * y + y ^ 2] 3 4


`上述をプレースホルダ記号@を使って記述し直す。`
`関数であることを明示するため、頭に?を付けておいても良い。`

[@0 ^ 2 + 2 * @0 * @1 + @1 ^ 2] 3 4

[? @0 ^ 2 + 2 * @0 * @1 + @1 ^ 2] 3 4



`上述は因数分解によって、この式は以下と等価。`

[(@0 + @1) ^ 2] 3 4

[? (@0 + @1) ^ 2] 3 4


`インクリメンタルな引数呼び出しは、プレースホルダの添字を省略可能。`

[(@ + @) ^ 2] 3 4

[? (@ + @) ^ 2] 3 4


`ポイントフリーと関数合成を使って、更に記述を簡約する。`
`ポイントフリーな関数の記述は、直接的な演算子の記述であるため、型が自明である。`
`この言語では、関数合成は左単位元である。空白は抽象的に"合成する演算子"である。`

[+] [^ 2] 3 4


`関数の第1引数は、関数の前に書いても良い`

 3 [+] [^ 2] 4

[+] 3 [^ 2] 4

[+ 3] [^ 2] 4

4 [+ 3] [^ 2]


`高階関数に対する、関数の適用について。`
`関数の引数に関数を渡す場合は、関数合成よりも関数適用のほうが優先されるため、空白記号で出来る。`
`これにより、以下のように、関数を評価する関数を記述できている。`

[@ @] [+ 2] [* 3] 4


`最後に来る添字が省略されたプレースホルダは、暗黙に"rest parameter"となる。`

[@ @] [*] [+ 5] 2 3
[@0 @1~] [*] [+ 5] 2 3


`以下はid射と同じで、命名せずに記号のみでid射の即時生成、即時適用、即時削除を可能にしている。`
`これは、この言語の究極系である。`
`なぜなら、id:と命名しても良いが、あえて命名しないことによって、型などの振る舞いも省略可能。`

[@] 1 2


`以下は、headを返す関数としてうまく機能する。`

[@0] 1 2 3 = 1


`以下はtailを返す関数として、うまく機能する。添字の省略がなされていないので、rest parameterを明示している。`

[@1~] 1 2 3 = 2 3


`ラムダに代入演算子で命名する場合、添字省略型プレースホルダのみで記述された関数は、? またはカッコを省略できない。`

add : +
exp : ^

id : ? @
id_0 : [@]
id_1 : @0~

eval : ? @ @
eval_0 : [@ @]
eval_1 : @0 @1~

`余談だが、rest_parameterを引数とする場合の記述として以下も可能ではある。`
`これはすぐ下のプレースホルダと等価である。`

map : [f x ~y ? map f x y~ ]
map : [map @ @ @]

`~演算子は奥深い。match_caseに対する~演算子がスコープをプロモートする根拠は、`
`~が不動点であるから。`
`故に、map関数の無名化に関しては、愚直に不動点をラムダで定義する方法もある。`

[~ @ @ @] [* 2] 1 2 3 4 5


`match_caseは、ブロック構文を使い、以下のように記述出来る。`
`ブロックがガード記法となる。`
`ブロック化された代入演算もこれが正体`
`ブロックそのものを代入するかカッコでくくって即時生成すれば、ただの関数と同じ。`
`よってこれは辞書型と等価である。`
`よってid射がotherwiseとなるのは自明`

[
  0 : `zero`
  > 0 : `more`
  < 0 : `less`
  @ : `other`
] 3


`３項演算子のような振る舞いも、以下のように定義可能。`

myTest0 :
  $ : `yep`
  \ : `nop`

myTest0 \ = `yep`


`代入する場合。`

myTest1 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  \ : `false`
  @ : `none or unit or otherwise`


myTest1 4 = `more`



`代入演算子の頭がラムダの場合は、つまりif thenと同義となる。if then はelseがunitを返すだけ。`
`しかしこれも、match_caseと同等である。`

[[> 3] : + 3] 3 4


`関数は必ず値を返す。`


`リストの定義は原則comma区切り。`
`","は英文では「強い区切り」、「直積」を表す。`
`" "は「直和」に使われる。`
`要素に任意に要素を追加出来る。`
`スカラー型の余積がリストを形成するので、commaを省略出来ることもある。`
`[@] は、id射の実装をプレースホルダで示したもの`
`ラムダの評価が、他の式や項より優先順位が低いのもよく分かる。`
`リストがイテレータとして機能する様も、頭の関数の省略がされてない形を見るとよく分かる。`
`実装が型であることを、見事に再現できている。`
`@ と , が、随伴関手定理による随伴であることも、キレイに現れる。`
`同じように、,とspaceが随伴関手定理による随伴であることも、現れている。`

myPairs: 1 2 3 4 5

myPairs00: 1 2 3 4 5
myPairs01: [@] 1 2 3 4 5
myPairs02: [@, @] 1 2 3 4 5
myPairs03: [@0, @1~] 1 2 3 4 5
myPairs04: [,] 1 2 3 4 5

myPairs10: 1, 2, 3, 4, 5
myPairs11: [@] 1, 2, 3, 4, 5
myPairs12: [@, @] 1, 2, 3, 4, 5
myPairs13: [@0, @1~] 1, 2, 3, 4, 5
myPairs14: [,] 1, 2, 3, 4, 5


`これは直和（配列の合成）`

r: [1 2] [3 4]


`これは直積（2次元配列）`

s: [1 2],[3 4]


`辞書型に見える表現は、はmatch_caseを行う無名関数と同じでカッコの種類は問わず、インデントでも定義可能。`
`ただし、開カッコと閉カッコは必ず対になる必要がある。`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`


`よって、アクセスはidentか文字列、またはnaturalかhexを引数にすることになるが、getという評価関数が必要となる。`
`つまり、lensやprismとして作用するコモナドが暗示されることになる。`

myGreet ' greet ' hello = `hello,`

myPairs ' 0 = 1

myPairs ' [1 ~ 3] = 2 3 4


`ブロックスコープを使うことで、ブロックスコープ内に添え字に対するgetを直接記述できる。`
`これはファイルの内外関係なくimport演算子で統一する。`
`このブロック構文も、もちろん演算終了時に返り値がある。`
`これはブロックスコープでの結果の直和が可能であれば直和を返す。`

myGreet
  ' greet ' welcome
  ' world
= `welcome, world`


`値のmodifyが可能`

myGreet~
  ' greet ' welcome : `welcome`
  ' world : `univese`


`,を使うことで、わざわざブロック化しなくて良い長さの定義の略記が可能。`

point: x: 0, y: 3, z: 2


`プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。`
`与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。`


`~演算子は、対象のスコープ上に辞書型を模倣するmatch_caseのみを展開できる。`
`前置であれば、他の項より優先され、後置であれば他の項を優先する。`

~[
  y: $
  n: \
]

  y = $

`@前置演算子はトップレベルで使う時はimportの役も負う。ファイル名からの指定も可能で、path指定も可`
`辞書型の名前を上のスコープに展開したい場合は、~演算子を使う。`

~@io
~@iterator


`\の後の任意の１文字は、必ず文字型の値１文字分とする。`
`スカラ値のリスト化は、通常はspaceかcommaを使うが、文字リテラルと文字列リテラルの場合は、`
`直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。`

M: \M

My: M \y\ \D\o\m\e\s\t\i\c
`Hello ` `World!` = `Hello World!`
`Hello` \  `World!` = `Hello World!`
'H `ello` \  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`改行を含む文字列を表現したい場合は、ブロックのような書き方となる。`
`理由は、` `が、「リストの結合、及び関数合成、関数適用」を意味するため。`
`ただし、文字列の合成はtabの後ろの` `を省略可能。`
`改行を含めたい場合。`

HWinEnter :
 `Hello` \
 `World!`


`"#"はexportになる。`

# myDict : name value; ~name : value
# gets : ?

