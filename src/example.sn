"文字列は、dobleQuoteで始まり、dobleQuote Enter か dobleQuote Tabで終わる"
"意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。"
"リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする"
"この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。"
"改行は「評価する」という後置演算子。"

"":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。"

x: 3
y: 4

Hello: "Hello"
World: "World"

true : _T_
false: _F_


"この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。"
"辞書型も表現可能で、カッコの種類は問わず、インデントでも定義可能。"
"ただし、開カッコと閉カッコは必ず対になる必要がある。"

point: 
	x: 0
	y: 3
	z: 2


"プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。"
"与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。"

""@"は他のファイルをインポートしてくる。返り値は辞書型"
"辞書型の名前を上のスコープに展開したい場合は、展開演算子を使う"

io: @io
~@iterator

""`"の後の任意の１文字は必ず文字型の値１文字分とする。例外はない！"
"スカラ値のリスト化は、通常は"[\s,]"を使うが、文字リテラルと文字列リテラルの場合は、"
"直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。"

My: `M`y` `D`o`m`e`s`t`i`c
"Hello "	"World!"	= "Hello World!"
"Hello"	`  "World!"	= "Hello World!"
`H "ello"	`  "World"	`!  = "Hello World!"
"Hello "	My " World!"	= "Hello My Domestic World!"
Hello `  My `  "World"	`! = "Hello My Domestic World!"
"Hello"	`!`  My World `! = "Hello! My Domestic World!"

says : "You say "Good Bye..." "I say "Hello""


"改行を含む文字列を表現したい場合は、ブロックのような書き方となる。"
"理由は、" "が、「リストの結合、及び関数合成」を意味するため。"
"改行を含めたい場合。"

HW_in_enter:
	"Hello"	`
	"World!"


""'"は英文の"'s"「所有」を由来とし、アクセッサー演算子である。"
"キー名を文字列指定もできる。変数に代入された文字列の場合、展開演算子"~"で中の文字列を取り出して使う"
"アクセッサー演算子は、必ず非同期処理となる。"

point ' x
point ' x : 2

my_name: "mike"

point ' ~my_name

""?"は、' の左右を逆にしたもの。"

x ? point

condition ? [3 , 2]


myTest : caseValue ;
	~caseValue ? 
		mike : "Hi mike!"
		kate : "Hi Mom!"
		1 : "first"
		2 : "second"

myTest 1 = "first"

"","は英文では「強い区切り」、「直積」を表す。"
"" "は「直和」に使われる。"
"要素に任意に要素を追加出来る。"

"ここから単一の値の型では同じ意味。"

p0: x, y
p1: x y
p2: (x, y)
p3: (x y)
p4: {x, y}
p5: {x y}
p6: [x, y]
p7: [x y]

"ここまでスカラー型では同じ意味。"

q: 
	r: 1 2
	s: 2 4


"これは直和（配列の合成）"

r: [1 2] [3 4]

"これは直積（2次元配列）"

s: [1 2],[3 4]

"この言語では、あくまでラムダとしての関数定義のみ行える。"
"よって名前を付けたければ、「即ち」を使う"

id: x; x
dup: x; x, x

"関数に対する「直和」とは、「関数合成、及び関数の評価」となる、よって関数をリストにしたければ「直積」のみが表記として可能"

f, g

""\t"（字下げ）によって、関数を複数行に分けることも可能。"

x; x ?
	AM: "Good Morining Sur."
	PM: "Good Afternoon Sur."


"演算子は全て関数として扱えるため、ポイントフリーな記述が可能。"

"ラムダを定義する場合（ポイントな記述）。"

(x ; x * 2) 3
{x ; x * 2} 3
[x ; x * 2] 3

(x ; 3 * x) 2
{x ; 3 * x} 2
[x ; 3 * x] 2

"対象の引数が確定していない記法(under_bar記法)を利用する。"

(_ * 2) 3
{_ * 2} 3
[_ * 2] 3

(3 * _) 2
{3 * _} 2
[3 * _] 2

"演算のカリー化（高階化）による、ポイントフリーな記述。"

(* 2) 3
{* 2} 3
[* 2] 3

(3 *) 2
{3 *} 2
[3 *] 2


"ポイントフリースタイル"

* 2 3
3 * 2
- 2 3
3 - 2

f: * 2
g: + 3
fop: / 2
gop: - 3

"ポイントフリーな記述も、字下げなどのブロック構文で複数行定義可能"

?
	AM: "Good Morining Sur."
	PM: "Good Afternoon Sur."

"前置演算子はそのまま関数名としても問題ない。"
"後置演算子は、 "_"を使う。"
"前置演算子及び後置演算子は間に空白を置いてはならない。"

not: !
factrial: _!


not false = !false
factrial 8 = 8!

"関数合成はカッコで優先を指定しない場合、左単位元とする。以下のように書く。"

h: f g
h 3 = g (f 3)
g (f 3) = g(f(3))


"第１引数を前に置く記法がある。"

3 f g = g f 3


"_ を使って引数の入る場所を自明にする。"

[_ + 2 * _ + 3] 5 4 = 5 + 2 * 4 + 3

greet : "Hello "	_ `
greet "johnny!"

"配列をスプレッドオペレータで分割代入する。"

[_ + 2 * _ + 3] ~[5 4] = 5 + 2 * 4 + 3


"多引数関数のパイプを、配列とスプレッドオペレータでやる。"

~[5 4] [_ + 2 * _ + 3] = 5 + 2 * 4 + 3

"分割代入は引数に後置で展開演算子。"

[a~ ; a] 1 2 3 4 5

"展開演算子による配列の定義"

[0 ~ 10]

"後置展開演算子による、文字列のkey化"

"myPrime"~ : 57

"true"~

"定義された関数は必ず最後の結果を返す。(この場合は5を返す)"

returnTest: x y z;
	x
	z
	y

returnTest 4 5 6


"getのブロック記法は、with構文の代わりとして使える。"

point '
	x : x + 3
	y : y * 2


""#"はexportになる。"

# myDict : name value; ~name : value
# gets : ?

