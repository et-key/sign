`Strings are enclosed in backquotes`
`Meaningless literal-only lines at the start or middle are not executed. Therefore, the line above is not executed.`
`Even if a line contains only a literal, if it's the last line of a function, it becomes the return value.`
`This string characteristic has the advantage of making regular expression objects easier to handle.`

`A newline is a postfix operator meaning "evaluate".`
`Leading indentation forms a block.`

`The normal evaluation strategy in this language is lazy evaluation.`

`":" in English means "namely", so it's used as the assignment operator, while = is strictly a comparison operator.`
`Just by looking below, it should be obvious that in this language, names become types.`

x: 3
y: 4

Hello: `Hello`
World: `World`

`true is $, false is _`

yep: $
nop: _

`Assignment operators that are not in a block are right identity elements and are syntactic sugar for distributive syntax.`

unit: none: []

`The above means the same as the following syntax`

none: []
unit: []

`In this language, both parentheses and indentation represent blocks, have local scope, and are recognized as being processed with priority.`
`In other words, the scope of names is determined by blocks`

  y: $
  n: _

`The above is deleted when leaving the block, so it returns an error "y wasn't defined" along with none (unit).`

(y = 1) = []

However, it can be accessed as follows:

[
  y: $
  n: _
] ' y

`How to define lambda terms`
`The basic lambda term uses ?.`
`Functions without assignment need to be enclosed in parentheses. This is because the start of parentheses means the creation of a stack.`

[x y ? x ^ 2 + 2 * x * y + y ^ 2] 3 4

`Rewrite the above using the placeholder symbol @.`
`You can add ? at the beginning to explicitly show it's a function.`

[@1 ^ 2 + 2 * @1 * @2 + @2 ^ 2] 3 4

[? @1 ^ 2 + 2 * @1 * @2 + @2 ^ 2] 3 4

`The above is equivalent to the following expression by factorization.`
`Parentheses are still perceived as the start of a block definition, allowing expression of operation priority.`

[(@0 + @1) ^ 2] 3 4

[? (@0 + @1) ^ 2] 3 4

`For incremental argument calls, the subscript of placeholders can be omitted.`
`Parentheses can be of the same type without problems.`

[[@ + @] ^ 2] 3 4

[? (@ + @) ^ 2] 3 4

`Using point-free style and function composition can further simplify the description in some cases`
`The description of point-free functions is a direct description of operators, so the type is obvious.`

 [^ 2] [+ 3] 4

`Function composition with the first argument written at the head becomes a left identity.`

4 [+ 3] [^ 2]

`To prevent function application or composition, you can respond by putting a , immediately after the function to make it a direct product.`

result8 : [@0 @0 @1] [+ 2], 4

`Point-free descriptions of monomials take arguments in right, left order.`
`The first argument of a function can be written before the function`
`If it's after :, [] can be omitted if the point-free description is a monomial.`

result2: - 1 3
add : +

[-] 1 3 = [- 1] 3
[-] 1 3 = 3 - 1
[-] 1 3 = [@1 - @0] 1 3

`The following is the same as the id morphism, enabling immediate generation, immediate application, and immediate deletion of the id morphism without naming.`
`The last placeholder becoming a rest parameter means arguments always function as a list.`
`Therefore, passing a list and passing multiple arguments are inherently equivalent in this language.`
`The reason is that the natural equivalence (natural isomorphism) in the background of this language is regarded as an adjoint functor.`
`As a result, spaces and commas can be explained by adjoint functors.`
`? can also be explained by this natural equivalence system.`
`This is one of the ultimate forms of this language.`
`Because even though we could name it id:, by deliberately not naming it, the type description becomes unnecessary.`

[? @] 1 2
[? @] 1,2
[@] 1 2
[@] 1,2

`The following functions well as a function that returns the head.`

[@0] 1 2 3 = 1

`The following functions well as a function that returns the tail. The subscript is not omitted, so it explicitly shows the rest parameter.`

[@1~] 1 2 3 = 2 3

`When naming a lambda with an assignment operator, functions described only with subscript-omitted placeholders cannot omit ? or parentheses.`

add : +
exp : ^

id : ? @
id_0 : [@]
id_1 : @0~

eval : ? @ @
eval_0 : [@ @]
eval_1 : @0 @1~

`As a side note, it's also possible to write as follows when taking a rest_parameter as an argument.`
`This is equivalent to the placeholder just below.`
`@' refers to the callee, so fixed points can be easily reproduced`
`This language allows type annotation or type reading by enclosing names in " for those who really want to write types (not recommended)`
`Why correct syntax automatically results in correct types is self-evident from the following type annotation`
`Because the type to which a function is applied is expressed as is, it becomes the same as the implementation.`
`Of course, the type of an executed function is automatically type-cast to the post-execution type, but`
`this is related to the fact that type calculation is done later due to lazy evaluation.`
`As a result, the compiler or interpreter doesn't need to guarantee type safety.`

typeOf : "@"
id : [@]

"map" : "f" "x" "~y" ? "f" "x" , "map" "f", "y~"
map : f x ~y ? f x , map f, y~

"map" : "@0" "@1" , "@'" "@0" "@2~"
map : @0 @1, @' @0, @2~

"fold" : "@'" "@0", "@0" "@1" "@2" , "@3~"
fold : @' @0, @0 @1 @2, @3~

`Applying map and fold without naming them.`

result30 : [@' @0, @0 @1 @2, @3~] [+] [@0 @1, @' @0, @2~] [* 2] 1 2 3 4 5

`match_case can be written using block syntax as follows.`
`The block becomes guard notation.`
`Block-ified assignment operators are also this in essence`
`If you assign the block itself or enclose it in parentheses for immediate generation, it's the same as just a function.`
`Therefore, this is equivalent to a dictionary type.`
`Therefore, it's obvious that the id morphism becomes otherwise`

[
  0 : `zero`
  > 0 : `more`
  < 0 : `less`
  @ : `other`
] 3

`Behavior like a ternary operator can also be defined as follows.`

myTest0 :
  $ : `yep`
  _ : `nop`

myTest0 $ = `yep`

`In case of assignment.`

myTest1 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  _ : `false`
  [] : `none or unit or otherwise`

myTest1 4 = `more`

`If the head of the assignment operator is lambda, it becomes equivalent to if then. if then just returns unit for else.`
`However, this is also equivalent to match_case.`

[[@0 > 3] : @1 + 3] 3 4

`The so-called let ~ in is written as follows.`
`In fact, it becomes the same as a monadic description.`

myValue : 3
  [+ 4]
  [* 2]

`List definitions are primarily comma-separated.`
`"," in English represents a "strong separation" or "direct product".`
`" " is used for "coproduct".`
`Elements can be arbitrarily added to elements.`
`Since the coproduct of scalar types forms a list, commas can sometimes be omitted.`
`[@] shows the implementation of the id morphism with placeholders`
`It's also clear that the evaluation of lambda has lower priority than other expressions or terms.`
`The way lists function as iterators is also clear when you look at the form where the head function is not omitted.`
`It beautifully reproduces that implementation is type.`
`It's beautifully shown that @ and , are adjoint by the adjoint functor theorem.`
`Similarly, it's shown that , and space are adjoint by the adjoint functor theorem.`

myPairs: 1 2 3 4 5

myPairs00: 1 2 3 4 5
myPairs01: [@] 1 2 3 4 5
myPairs02: [@, @] 1 2 3 4 5
myPairs03: [@0, @1~] 1 2 3 4 5
myPairs05: [,] 1 2 3 4 5

myPairs10: 1, 2, 3, 4, 5
myPairs11: [@] 1, 2, 3, 4, 5
myPairs12: [@, @] 1, 2, 3, 4, 5
myPairs13: [@0, @1~] 1, 2, 3, 4, 5
myPairs14: [,] 1, 2, 3, 4, 5

`This is coproduct (array composition)`

r: [1 2] [3 4]

`This is product (2D array)`

s: [1 2],[3 4]

`Expressions that look like dictionary types are the same as anonymous functions performing match_case, and the type of parentheses doesn't matter; they can also be defined with indentation.`
`However, opening and closing parentheses must always be in pairs.`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`

`Therefore, access will be with ident or string, or natural or hex as arguments, but a get evaluation function becomes necessary.`
`In other words, it implies a comonad that acts as a lens or prism.`

myGreet ' greet ' hello = `hello,`

myPairs ' 0 = 1

myPairs ' [1 ~ 3] = 2 3 4

`By using block scope, you can directly write get for subscripts within the block scope.`
`This is unified with the import operator regardless of inside or outside files.`
`Of course, this block syntax also has a return value at the end of the operation.`
`This returns a coproduct if a coproduct of results is possible in the block scope.`

@myGreet
  greet ' welcome
  world
= `welcome, world`

`Value modification is possible`

@myGreet
  greet ' welcome : `welcome to our `
  world : `metaverse!`

`Using , allows for abbreviated notation of definitions that are not long enough to require blocking.`

point: x: 0, y: 3, z: 2

`By inferring only primitive types, the design is such that actual type problems can be solved.`
`All given names are definitions, and because they are also obvious types, names are types.`

`The ~ operator can only expand match_case mimicking dictionary types on the target scope.`
`If it's a prefix, it takes precedence over other terms, and if it's a postfix, other terms take precedence.`

~[
  y: $
  n: _
]

y = $

`The @ prefix operator also plays the role of import when used at the top level. Specification from file names is possible, and path specification is also possible`
`When match_case can be viewed as a dictionary type, it can be expanded to one scope up using the ~ operator, so using ~@ allows for imports that can be used within the file.`

@io
  say Hello World

`Because it's not an import at the file scope, the line below returns a "Say is not defined" error.`

say Hello World

`Expand to file scope and use.`

~@Funnctor
~@Monoid
~@io

say fold [+] map [* 4] 1 2 3 4 5

`Any single character after \ is always one character value of character type.`
`Scalar value list creation usually uses space or comma, but in the case of character literals and string literals,`
`there are cases where concatenation can be represented by direct description, so write that pattern.`

M: \M

My: M \y\ \D\o\m\e\s\t\i\c
`Hello ` `World!` = `Hello World!`
`Hello` \  `World!` = `Hello World!`
'H `ello` \  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`

`If you want to express a string containing newlines, it becomes a block-like writing.`
`The reason is that ` ` means "list concatenation, function composition, and function application".`
`If you want to include newlines.`

HWinEnter :
 `Hello` \
 `World!`

`"#" becomes export.`
`Normal functions always return the value of the last line, and match_case returns the value or function corresponding to the specified value`
`The entire file is also a function, but anything not indicated by export, i.e., #, does not leave its own scope.`

# myDict : name value; ~name : value
# gets : ?

`Logical operators are short-circuit evaluated.`

_ & `me` = _
$ & `me` = `me`

_ | `me` = `me`
$ | `me` = $

_ ; `me` = `me`
$ ; `me` = _

`The approach to syntax trees can be considered as natural transformations.`
`The following is a consideration of such natural transformations.`
`The fact that folding and product correspond to adjoint functors is equivalent to replacing , with some infix operator.`
`We want to consider syntax that can express such expressions.`