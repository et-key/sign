`Strings are enclosed in backquotes`
`Meaningless literal-only lines at the beginning or middle are not executed. Therefore, the line above is not executed.`
`Even if it's a line with only a literal, if it's the final line of a function, it becomes the return value`
`This string characteristic has the advantage of making regular expression objects easier to handle.`

`A newline is a postfix operator meaning "evaluate".`
`Leading indentation forms a block.`

`The normal evaluation strategy in this language is lazy evaluation.`

`":" in English means "namely", so it's used as the assignment operator, while = is strictly a comparison operator.`
`Just by looking below, it should be obvious that in this language, names become types.`

x: 3
y: 4

Hello: `Hello`
World: `World`

yep : $
nop : _

`Assignment operators that are not in a block are right identity elements and are syntactic sugar for distributive syntax.`

unit: otherwise: none: @

`The above means the same as the following syntax`

otherwise: @
none: @
unit: @

`In this language, both parentheses and indentation represent blocks, have local scope, and are recognized as being processed with priority.`
`In other words, the scope of names is determined by blocks`

  y: $
  n: _

`Because it's undefined, it returns an error "y wasn't defined" along with none (unit).`

(y = $) = @

However, it can be accessed as follows:

[
  y: $
  n: _
] ' y


`How to define lambda terms`
`The basic lambda term uses ?.`
`Functions without assignment need to be enclosed in parentheses. This is because the start of parentheses means the creation of a stack.`

[x y ? x ^ 2 + 2 * x * y + y ^ 2] 3 4


`Rewrite the above using the placeholder symbol @.`
`You can add ? at the beginning to explicitly show it's a function.`

[@0 ^ 2 + 2 * @0 * @1 + @1 ^ 2] 3 4

[? @0 ^ 2 + 2 * @0 * @1 + @1 ^ 2] 3 4



`The above is equivalent to the following expression by factorization.`

[(@0 + @1) ^ 2] 3 4

[? (@0 + @1) ^ 2] 3 4


`For incremental argument calls, the subscript of placeholders can be omitted.`

[(@ + @) ^ 2] 3 4

[? (@ + @) ^ 2] 3 4


`Using point-free style and function composition to further simplify the description.`
`The description of point-free functions is a direct description of operators, so the type is obvious.`
`In this language, function composition is a left identity. Space is abstractly an "operator for composition".`

[+] [^ 2] 3 4


`The first argument of a function can be written before the function`

 3 [+] [^ 2] 4

[+] 3 [^ 2] 4

[+ 3] [^ 2] 4

4 [+ 3] [^ 2]


`Regarding function application to higher-order functions.`
`When passing a function as an argument to a function, function application takes precedence over function composition, so it can be done with a space symbol.`
`This allows us to write functions that evaluate functions as follows.`

[@ @] [+ 2] [* 3] 4


`The placeholder with the last subscript omitted implicitly becomes a "rest parameter".`

[@ @] [*] [+ 5] 2 3
[@0 @1~] [*] [+ 5] 2 3


`The following is the same as the id morphism, enabling immediate generation, immediate application, and immediate deletion of the id morphism without naming.`
`This is the ultimate form of this language.`
`Because even though we could name it id:, by deliberately not naming it, we can omit behaviors like types.`

[@] 1 2


`The following functions well as a function that returns the head.`

[@0] 1 2 3 = 1


`The following functions well as a function that returns the tail. Since the subscript is not omitted, it explicitly shows the rest parameter.`

[@1~] 1 2 3 = 2 3


`When naming a lambda with an assignment operator, functions described only with subscript-omitted placeholders cannot omit ? or parentheses.`

add : +
exp : ^

id : ? @
id_0 : [@]
id_1 : @0~

eval : ? @ @
eval_0 : [@ @]
eval_1 : @0 @1~

`As a side note, it's also possible to write as follows when taking a rest_parameter as an argument.`
`This is equivalent to the placeholder just below.`

map : [f x ~y ? map f x y~ ]
map : [map @ @ @]

`The ~ operator is profound. The reason why the ~ operator promotes scope for match_case is that`
`~ is a fixed point.`
`Therefore, for the anonymization of the map function, there's also a method to naively define a fixed point with lambda.`

[~ @ @ @] [* 2] 1 2 3 4 5


`match_case can be written using block syntax as follows.`
`The block becomes guard notation.`
`Block-ified assignment operators are also this in essence`
`If you assign the block itself or enclose it in parentheses for immediate generation, it's the same as just a function.`
`Therefore, this is equivalent to a dictionary type.`
`Therefore, it's obvious that the id morphism becomes otherwise`

[
  0 : `zero`
  > 0 : `more`
  < 0 : `less`
  @ : `other`
] 3


`Behavior like a ternary operator can also be defined as follows.`

myTest0 :
  $ : `yep`
  _ : `nop`

myTest0 $ = `yep`


`In case of assignment.`

myTest1 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  _ : `false`
  @ : `none or unit or otherwise`


myTest1 4 = `more`



`If the head of the assignment operator is lambda, it becomes equivalent to if then. if then just returns unit for else.`
`However, this is also equivalent to match_case.`

[[> 3] : + 3] 3 4


`Functions always return a value.`


`List definitions are primarily comma-separated.`
`"," in English represents a "strong separation" or "direct product".`
`" " is used for "coproduct".`
`Elements can be arbitrarily added to elements.`
`Since the coproduct of scalar types forms a list, commas can sometimes be omitted.`
`[@] shows the implementation of the id morphism with placeholders`
`It's also clear that the evaluation of lambda has lower priority than other expressions or terms.`
`The way lists function as iterators is also clear when you look at the form where the head function is not omitted.`
`It beautifully reproduces that implementation is type.`
`It's beautifully shown that @ and , are adjoint by the adjoint functor theorem.`
`Similarly, it's shown that , and space are adjoint by the adjoint functor theorem.`

myPairs: 1 2 3 4 5

myPairs00: 1 2 3 4 5
myPairs01: [@] 1 2 3 4 5
myPairs02: [@, @] 1 2 3 4 5
myPairs03: [@0, @1~] 1 2 3 4 5
myPairs04: [,] 1 2 3 4 5

myPairs10: 1, 2, 3, 4, 5
myPairs11: [@] 1, 2, 3, 4, 5
myPairs12: [@, @] 1, 2, 3, 4, 5
myPairs13: [@0, @1~] 1, 2, 3, 4, 5
myPairs14: [,] 1, 2, 3, 4, 5


`This is coproduct (array composition)`

r: [1 2] [3 4]


`This is product (2D array)`

s: [1 2],[3 4]


`Expressions that look like dictionary types are the same as anonymous functions performing match_case, and the type of parentheses doesn't matter; they can also be defined with indentation.`
`However, opening and closing parentheses must always be in pairs.`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`


`Therefore, access will be with ident or string, or natural or hex as arguments, but a get evaluation function becomes necessary.`
`In other words, it implies a comonad that acts as a lens or prism.`

myGreet ' greet ' hello = `hello,`

myPairs ' 0 = 1

myPairs ' [1 ~ 3] = 2 3 4


`By using block scope, you can directly write get for subscripts within the block scope.`
`This is unified with the import operator regardless of inside or outside files.`
`Of course, this block syntax also has a return value at the end of the operation.`
`This returns a coproduct if a coproduct of results is possible in the block scope.`

myGreet
  ' greet ' welcome
  ' world
= `welcome, world`


`Value modification is possible`

myGreet~
  ' greet ' welcome : `welcome`
  ' world : `univese`


`Using , allows for abbreviated notation of definitions that are not long enough to require blocking.`

point: x: 0, y: 3, z: 2


`By inferring only primitive types, the design is such that actual type problems can be solved.`
`All given names are definitions, and because they are also obvious types, names are types.`


`The ~ operator can only expand match_case mimicking dictionary types on the target scope.`
`If it's a prefix, it takes precedence over other terms, and if it's a postfix, other terms take precedence.`

~[
  y: $
  n: _
]

  y = $

`The @ prefix operator also plays the role of import when used at the top level. Specification from file names is possible, and path specification is also possible`
`If you want to expand the name of a dictionary type to the upper scope, use the ~ operator.`

~@io
~@iterator


`Any single character after \ is always one character value of character type.`
`Scalar value list creation usually uses space or comma, but in the case of character literals and string literals,`
`there are cases where concatenation can be represented by direct description, so write that pattern.`

M: \M

My: M \y\ \D\o\m\e\s\t\i\c
`Hello ` `World!` = `Hello World!`
`Hello` \  `World!` = `Hello World!`
'H `ello` \  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`If you want to express a string containing newlines, it becomes a block-like writing.`
`The reason is that ` ` means "list concatenation, function composition, and function application".`
`However, ` ` after tab can be omitted for string composition.`
`If you want to include newlines.`

HWinEnter :
 `Hello` \
 `World!`


`"#" becomes export.`

# myDict : name value; ~name : value
# gets : ?

