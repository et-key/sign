`文字列は、backQuort`
`意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。`
`リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする`
`この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。`
`改行は「評価する」という後置演算子。`
`行頭tabはブロックの形成となる。`
`":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。`
`下を見ただけでも、この言語は名前が型となるのは自明であろう。`

x: 3
y: 4

Hello: `Hello`
World: `World`

true : \

`ブロックになっていない代入演算子は、右単位元であり、分配的構文に対するシンタックスシュガーである。`

unit: otherwise: none: false: _

`上述は、以下の構文と同じ意味`

otherwise: _
none:_
false: _
unit: _


`リストの定義は原則comma区切り。`
`スカラー型の余積がリストを形成するので、commaを省略出来ることもある。`
`上から順に、糖衣構文が変換される様となる。（予定でありあくまで考え方の一つ）`

myPairs: 1 2 3 4 5


`この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。`
`辞書型に見える表現は、はmatch caseを行う無名関数と同じでカッコの種類は問わず、インデントでも定義可能。`
`ただし、開カッコと閉カッコは必ず対になる必要がある。`
`上から順に、糖衣構文が変換される様となる。`

myGreet:
  greet: 
    hello: `hello,`
    welcome: `welcome,`
  world: ` world`


`at_markの前置演算子によって、アクセッサを提供する。`

myGreet @greet @hello = `hello,`

myPairs @0



`import演算子@を用いることで、スコープ内でオブジェクトを扱える。`
`これはファイルの内外関係なくimport演算子で統一する。`

  @ myGreet
    @greet @welcome
    @world
  = `welcome, world`


`値のmodifyが可能`

  @ myPairs
    @1 : @0 + 2
    @2 : @1 * 3


`,を使うことで、わざわざブロック化しなくて良い長さの定義の略記が可能。`

point: x: 0, y: 3, z: 2


`プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。`
`与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。`

`"@"はファイル名からの指定も可能で、path指定も可`
`辞書型の名前を上のスコープに展開したい場合は、展開演算子を使う。`

io: @io
~@iterator


`quoteの後の任意の１文字は、必ず文字型の値１文字分とする。`
`スカラ値のリスト化は、通常は`[\s,]`を使うが、文字リテラルと文字列リテラルの場合は、`
`直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。`

My: 'M'y' 'D'o'm'e's't'i'c
`Hello ` `World!` = `Hello World!`
`Hello` '  `World!` = `Hello World!`
'H `ello` '  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`改行を含む文字列を表現したい場合は、ブロックのような書き方となる。`
`理由は、` `が、「リストの結合、及び関数合成」を意味するため。`
`ただし、文字列の合成はtabの後ろの` `を省略可能。`
`改行を含めたい場合。`

HW_in_enter :
 `Hello` '
 `World!`


`match_caseの正体は単純なラムダ定義。３項演算子のような振る舞いも、以下のように定義可能。`


myTest0_0 :
  \ : `yep`
  _ : `nop`

myTest0_0 \ = `yep`


myTest1_0 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  _ : `none`

myTest1_0 4 = `more`


`","は英文では「強い区切り」、「直積」を表す。`
`" "は「直和」に使われる。`
`要素に任意に要素を追加出来る。`

`ここから単一の値の型では同じ意味。`

p0: x, y
p1: x y
p2: (x, y)
p3: (x y)
p4: {x, y}
p5: {x y}
p6: [x, y]
p7: [x y]


`ここまでスカラー型では同じ意味。`

q: 
  r: 1 2
  s: 2 4


`これは直和（配列の合成）`

r: [1 2] [3 4]


`これは直積（2次元配列）`

s: [1 2],[3 4]


`この言語では、あくまでラムダとしての関数定義のみ行える。`
`よって名前を付けたければ、「即ち」を使う`

id: ? @
dup: ? @0 @0


`関数に対する「直和」とは、「関数合成、及び関数の評価」となる、よって関数をリストにしたければ「直積」のみが表記として可能`

f, g


`ラムダを定義する場合（ポイントな記述）。`

(x ? x * 2) 3
{x ? x * 2} 3
[x ? x * 2] 3

(x ? 3 * x) 2
{x ? 3 * x} 2
[x ? 3 * x] 2


`ポイントなラムダは、正確には以下のmatch caseと同じ。`
x ?
  \ : x * 2


`引数の位置を順に指定する方法(under_bar記法)を利用する。`

(@ * 2) 3
{@ * 2} 3
[@ * 2] 3

(3 * @) 2
{3 * @} 2
[3 * @] 2


`引数リストを利用する。`

(@1 * @0) 2 3
{@1 * @0} 2 3
[@1 * @0] 2 3


`n番目の引数だけを返す関数を作る場合、key やidentとの区分のため、?を省略できない`

[? @4] myPairs = 5


`演算のカリー化（高階化）による、ポイントフリーな記述。`

(* 2) 3
{* 2} 3
[* 2] 3

(3 *) 2
{3 *} 2
[3 *] 2


`ポイントフリーな記述のカッコは省略可能。`

* 2 3 = 3 * 2
- 2 3 = 3 - 2

f: * 2
g: + 3
fop: / 2
gop: - 3


`ポイントフリーな記述も、字下げなどのブロック構文で複数行定義可能`

greetTime: ?
  AM: `Good Morining Sur.`
  PM: `Good Afternoon Sur.`

greetTime `AM`


`引数リストを使った表現との一致`

myTest1_1 : ?
  @0 = `mike` : `Hi mike!`
  @0 = `kate` : `Hi Mom!`
  @0 = 1 : `first`
  @0 = 2 : `second`
  @0 > 3 : `more`
  @0 < 1 : `less`
  _ : `none`


`前置演算子はそのまま関数名としても問題ない。`
`後置演算子は、 `@`を使う。`
`前置演算子及び後置演算子は間に空白を置いてはならない。`

not: !
factrial: @!

not false = !false
factrial 8 = 8!


`関数合成はカッコで優先を指定しない場合、左単位元とする。以下のように書く。`

h: f g
h 3 = g (f 3)
g (f 3) = g(f(3))


`第１引数を前に置く記法があり、その場合は原則、左単位元として扱う`

3 f g = f g 3


`@ を使って引数の入る場所を自明にする。複文の式化と文字列合成の時は必須`

[@ + 2 * @ + 3] 5 4 = 5 + 2 * 4 + 3

greet : `Hello ` @ '
greet `johnny!`


`多引数関数のパイプは中置記法で！`

5 [@ + 2 * @ + 3] f g 4 = 16 f g


`展開演算子による配列の定義`

myList: 0 ~ 10


`展開演算子による、文字列のkey化`

~`myPrime` : 57

~`true` = \


`展開演算子による、先頭と後述へのアクセス`

map : f x ~xs ?
  f x , map f xs


`at_mark記法は、引数リストの順番にもアクセスする。`
`そのため、展開演算子を用いて残りをlistとしてアクセスできる。`

sum : @ + sum @~


`引数リスト記法にも、"@n~" で、n以降を同様に処理できる。`

product : @0 * product @1~


`引数リストの残りへのアクセスの場合、"~"を許容する。`

exp : @0 ^ exp @~


`引数リストの残りへのアクセスは常に推論可能と考えるので、最後の@ は、自動でrest_parameterとできる。`

exp : @ ^ exp @


`定義された関数は必ず最後の結果を返す。(この場合は5を返す)`

returnTest: x y z ? x; z; y

returnTest 4 5 6


`"#"はexportになる。`

# myDict : name value; ~name : value
# gets : ?

