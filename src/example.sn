`文字列は、backQuort`
`意味をなさないリテラルだけの開始行や中間行は実行されない。よって、上の行も実行されない。`
`リテラルだけの行であっても、それが関数の最終行であれば、それを返値とする`
`この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。`
`改行は「評価する」という後置演算子。`
`行頭tabはブロックの形成となる。`
`":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。`
`下を見ただけでも、この言語は名前が型となるのは自明であろう。`

x: 3
y: 4

Hello: `Hello`
World: `World`

true : $

`ブロックになっていない代入演算子は、右単位元であり、分配的構文に対するシンタックスシュガーである。`

unit: otherwise: none: false: \

`上述は、以下の構文と同じ意味`

otherwise: \
none: \
false: \
unit: \


`リストの定義は,区切り。`
`上から順に、糖衣構文が変換される様となる。（予定でありあくまで考え方の一つ）`

myPairs_2: 1, 2, 3, 4, 5

myPairs_1: ? 1, 2, 3, 4, 5

myPairs_0: ?
  0 : 1
  1 : 2
  2 : 3
  3 : 4
  4 : 5

myPairs: ?
  _0 = 0 : 1
  _0 = 1 : 2
  _0 = 2 : 3
  _0 = 3 : 4
  _0 = 4 : 5


`この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。`
`辞書型に見える表現は、はmatch caseを行う無名関数と同じでカッコの種類は問わず、インデントでも定義可能。`
`ただし、開カッコと閉カッコは必ず対になる必要がある。`
`上から順に、糖衣構文が変換される様となる。`

myGreet_3:
  greet: 
    hello: `hello`
    welcome: `welcome`
  world: `world`

myGreet_2: ?
  greet: ?
    hello: `hello`
    welcome: `welcome`
  world: `world`

myGreet_1: ?
  _0 = greet : ?
    _1 = hello : `hello`
    _1 = welcome : `welcome`
  _0 = world : `world`

myGreet: ?
  _0 = `greet` : ?
    _1 = `hello` : `hello`
    _1 = `welcome` : `welcome`
  _0 = `world` : `world`


`,を使うことで、わざわざブロック化しなくて良い長さの定義の略記が可能。`

point: x: 0, y: 3, z: 2


`プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。`
`与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。`

`"@"は他のファイルをインポートしてくる。返り値は辞書型`
`辞書型の名前を上のスコープに展開したい場合は、展開演算子を使う`

io: @io
~@iterator


`quoteの後の任意の１文字は、必ず文字型の値１文字分とする。`
`スカラ値のリスト化は、通常は`[\s,]`を使うが、文字リテラルと文字列リテラルの場合は、`
`直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。`

My: 'M'y' 'D'o'm'e's't'i'c
`Hello ` `World!` = `Hello World!`
`Hello` '  `World!` = `Hello World!`
'H `ello` '  `World` '! = `Hello World!`
`Hello ` My ` World!` = `Hello My Domestic World!`
Hello '  My '  `World` '! = `Hello My Domestic World!`
`Hello` '!' My World '! = `Hello! My Domestic World!`


`改行を含む文字列を表現したい場合は、ブロックのような書き方となる。`
`理由は、` `が、「リストの結合、及び関数合成」を意味するため。`
`ただし、文字列の合成はtabの後ろの` `を省略可能。`
`改行を含めたい場合。`

HW_in_enter :
 `Hello` '
 `World!`


`match caseに対するアクセスには、ブロックを用いることでwith構文のような働きを持つ。`
`ブロック終了時に、文字列やリストであれば結合する。`
`先頭のidが、ブロック内で定義済みである場合、" "はcoproductを優先する`

myGreet
  greet hello
  world


`文字列指定も可能、単純な文字列結合との構文の混乱を避けるため、ブロックの深さに従った記述が必要。`

myGreet
  `greet` 
    `welcome`
  `world`


`多段も可能`

myGreet
  greet
    hello
  world


`多段かつ文字列指定の場合は、引数渡しはブロックだけで表現できる。`

myGreet
  `greet`
    `hello`
  `world`


`match_caseの正体は単純なラムダ定義。３項演算子のような振る舞いも、以下のように定義可能。`


myTest0_0 :
  $ : `yep`
  \ : `nop`

myTest0_0 $ = myTest0_1 $

myTest0_0 $ = myTest0_2 $

myTest1_0 :
  mike : `Hi mike!`
  kate : `Hi Mom!`
  1 : `first`
  2 : `second`
  > 3 : `more`
  < 1 : `less`
  \ : `none`

myTest1_0 4 = `more`


`","は英文では「強い区切り」、「直積」を表す。`
`" "は「直和」に使われる。`
`要素に任意に要素を追加出来る。`

`ここから単一の値の型では同じ意味。`

p0: x, y
p1: x y
p2: (x, y)
p3: (x y)
p4: {x, y}
p5: {x y}
p6: [x, y]
p7: [x y]


`ここまでスカラー型では同じ意味。`

q: 
  r: 1 2
  s: 2 4


`これは直和（配列の合成）`

r: [1 2] [3 4]


`これは直積（2次元配列）`

s: [1 2],[3 4]


`この言語では、あくまでラムダとしての関数定義のみ行える。`
`よって名前を付けたければ、「即ち」を使う`

id: ? _
dup: ? _0 _0


`関数に対する「直和」とは、「関数合成、及び関数の評価」となる、よって関数をリストにしたければ「直積」のみが表記として可能`

f, g


`ラムダを定義する場合（ポイントな記述）。`

(x ? x * 2) 3
{x ? x * 2} 3
[x ? x * 2] 3

(x ? 3 * x) 2
{x ? 3 * x} 2
[x ? 3 * x] 2


`ポイントなラムダは、正確には以下のmatch caseと同じ。`
x ?
  \ : x * 2


`引数の位置を順に指定する方法(under_bar記法)を利用する。`

(_ * 2) 3
{_ * 2} 3
[_ * 2] 3

(3 * _) 2
{3 * _} 2
[3 * _] 2


`引数リストを利用する。`

(_1 * _0) 2 3
{_1 * _0} 2 3
[_1 * _0] 2 3


`n番目の引数だけを返す関数を作る場合、key やidentとの区分のため、?を省略できない`

? _0


`演算のカリー化（高階化）による、ポイントフリーな記述。`

(* 2) 3
{* 2} 3
[* 2] 3

(3 *) 2
{3 *} 2
[3 *] 2


`ポイントフリーな記述のカッコは省略可能。`

* 2 3 = 3 * 2
- 2 3 = 3 - 2

f: * 2
g: + 3
fop: / 2
gop: - 3


`ポイントフリーな記述も、字下げなどのブロック構文で複数行定義可能`

greetTime: ?
  AM: `Good Morining Sur.`
  PM: `Good Afternoon Sur.`

greetTime `AM`


`引数リストを使った表現との一致`

myTest1_1 : ?
  _0 = `mike` : `Hi mike!`
  _0 = `kate` : `Hi Mom!`
  _0 = 1 : `first`
  _0 = 2 : `second`
  _0 > 3 : `more`
  _0 < 1 : `less`
  \ : `none`


`前置演算子はそのまま関数名としても問題ない。`
`後置演算子は、 `_`を使う。`
`前置演算子及び後置演算子は間に空白を置いてはならない。`

not: !
factrial: _!

not false = !false
factrial 8 = 8!


`関数合成はカッコで優先を指定しない場合、左単位元とする。以下のように書く。`

h: f g
h 3 = g (f 3)
g (f 3) = g(f(3))


`第１引数を前に置く記法があり、その場合は原則、左単位元として扱う`

3 f g = g f 3


`_ を使って引数の入る場所を自明にする。複文の式化と文字列合成の時は必須`

[_ + 2 * _ + 3] 5 4 = 5 + 2 * 4 + 3

greet : `Hello ` _ '
greet `johnny!`


`多引数関数のパイプは中置記法で！`

5 [_ + 2 * _ + 3] 4 = 5 + 2 * 4 + 3


`適用順序`


`展開演算子による配列の定義`

myList: 0 ~ 10


`展開演算子による、文字列のkey化`

~`myPrime` : 57

~`true`


`展開演算子による、先頭と後述へのアクセス`

map : f x ~xs ?
  f x , map f xs


`under_bar記法は、慣習的に引数リストの順番にアクセスする。`
`そのため、展開演算子を用いて残りをlistとしてアクセスできる。`

sum : _ + sum _~


`引数リスト記法にも、"_n~" で、n以降を同様に処理できる。`

product : ? _0 * product _1~


`引数リストの残りへのアクセスの場合、"_~"を許容する。`

exp : _0 ^ exp _~


`引数リストの残りへのアクセスは常に推論可能と考えるので、最後の_ は、自動でrest_parameterとできる。`

exp : _ ^ exp _


`定義された関数は必ず最後の結果を返す。(この場合は5を返す)`

returnTest: x y z ? x; z; y

returnTest 4 5 6


`"#"はexportになる。`

# myDict : name value; ~name : value
# gets : ?

