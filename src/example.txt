"文字列だけの行は実行されない。"
"文字列は、"で始まり、"[\t\n\r] で終わる。"
"":"は英文では「即ち」、「代入」を表す。"
"この言語ではカッコはブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。"
"辞書型のような型も表現可能で、カッコの種類は問わない。"

x: 3
y: 4
point: [
	x: 0
	y: 3
	z: 2
]

""'"は英文の"'s"「所有」を由来とし、アクセッサー演算子である。"
"キー名を文字列指定もできる。変数に代入された文字列の場合、~で中の文字列を取り出して使う"

point ' x
point ' x : 2

temp_z: "z"

point ' ~temp_z


"","は英文では「強い区切り」、「直積」を表す。"
"" "は「直和」に使われる。"

"ここからスカラー型では同じ意味"
	p0: x, y
	p1: x y
	p2: (x, y)
	p3: (x y)
	p4: {x, y}
	p5: {x y}
	p6: [x, y]
	p7: [x y]
"ここまでスカラー型では同じ意味"

q: [
	r: [1 2]
	s: [2 4]
]

"これは直和（配列の合成）"
r: [1 2] [3 4]

"これは直積（2次元配列）"
s: [1 2],[3 4]


"";"は英文では関連ある弱い区切り、「ラムダ項」を表す。"
"右や左、左右両方を省略された演算子をカッコで囲んでも「ラムダ項」とする"
"ラムダ項を即時で利用する場合は、カッコで囲む。カッコの種類は問わない。"
"この言語では、あくまでラムダとしての関数定義のみ行える。"
"よって名前を付けたければ、「即ち」を使う"
"関数に対する「直和」とは、「関数の評価」となる、よって関数をリストにしたければ「直積」のみが表記として可能"
""  "（字下げ）によって、関数を複数行に分けることも可能"

(x ; x * 2) 3
{x ; x * 2} 3
[x ; x * 2] 3
(* 2) 3
{* 2} 3
[* 2] 3
(*) 2 3
{*} 2 3
[*] 2 3

(3 *) 2
{3 *} 2
[3 *] 2

id: x; x
dup: x; x, x
f: [* 2]
g: [+ 3]
eval: f x; f x

"関数合成"
f g
g f

fg : f g
gf : g f

"Functorは関数評価を高階にすることで記述"

mapped0: [* 2] $ [1 2 3 4 5]



"Applicativeは、型が同一である保証となる。"

Apply: 


``Import and Spread variables``
~ @ ``basic``

``Assign Lambda``
# myFunc : name ; ``This is my "`` name ``".`` `


myStrResult : myFunc ``Pen``

mappedArray : map (* 2) {1 2 3 4 5 6}

foldedValue : fold (+) {1 2 3 4 5 6}

filteredArray : filter (% 2) {1 2 3 4 5 6}

infixResults : {
    MappedArray :   {1 2 3 4 5 6} map (* 2)
    FoldedValue :   {1 2 3 4 5 6} fold (+)
    FilteredArray : {1 2 3 4 5 6} filter (% 2)
}

myHex : {
    0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
    `a | `b | `c | `d | `e | `f |
    `A | `B | `C | `D | `E | `F
}

case myHex (x ; {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 11 12 13 14 15} ' x)

mySumResult : {
    (1 2 3) (4 5 6) = (1 2 3 4 5 6)
    (1 2 3) (4 5 6) = (1,2,3,4,5,6)
    (1,2,3) (4,5,6) = (1 2 3 4 5 6)
    (1,2,3) (4,5,6) = (1,2,3,4,5,6)
}

myPrdResult : {
    (1 2 3),(4 5 6) = {(1 2 3), (4 5 6)}
    (1 2 3),(4 5 6) = {(1,2,3), (4,5,6)}
    (1,2,3),(4,5,6) = {(1 2 3), (4 5 6)}
    (1,2,3),(4,5,6) = {(1,2,3), (4,5,6)}
}

myIf : (
    ? (+ 4), (* 2)
)

(= 20) {(* 2 + 4) 8}

(myIf _T_ 3) (= 7)
(myIf _F_ 3) (= 6)

myFunc "Pen" =  ``This is a "Pen".``


_T_ , _F_ & _T_ , _F_


