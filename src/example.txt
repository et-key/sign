"　文字列は、'"'で始まり、'"[\n\t]{1}'で終わる。"
"　意味をなさないリテラルだけの行は実行されない。よって、上の行も実行されない。"
"　この文字列の特性により、正規表現オブジェクトを扱いやすくなるメリットが有る。"
"　改行は「評価する」という後置演算子。"
"　この言語はファイルごとのローカルスコープを持つ。"
"　":"は英文では「即ち」なので代入演算子とし、=は飽くまで比較演算子である。"

x: 3
y: 4

Hello: "Hello"
World: "World"

true : _T_
false: _F_


"　この言語ではカッコ、インデントの双方はブロックを表し、ローカルスコープを持ち、優先に処理されるものと認識される。"
"　辞書型も表現可能で、カッコの種類は問わず、インデントでも定義可能。"
"　ただし、開カッコと閉カッコは必ず対になる必要がある。"

point: 
	x: 0
	y: 3
	z: 2


"　プリミティブな型のみを推論することで、実際の型の問題が解決できるような設計となる。"
"　与えられた名前は全て定義であり、それが自明な型でもあるため、名前が型である。"

"　"@"は他のファイルをインポートしてくる。返り値は辞書型"
"　辞書型の名前を上のスコープに展開したい場合は、展開演算子を使う"

~@iterator


"　"`"の後の任意の１文字は必ず文字型の値１文字分とする。例外はない！"
"　スカラ値のリスト化は、通常は"[\s,]"を使うが、文字リテラルと文字列リテラルの場合は、"
"　直結した記述で連結を表わせる場合があるので、そのパターン記述しておく。"

My: `M`y` `D`o`m`e`s`t`i`c
"Hello "	"World!"	= "Hello World!"
"Hello"	`  "World!"	= "Hello World!"
`H "ello"	`  "World"	`!  = "Hello World!"
"Hello "	My " World!"	= "Hello My Domestic World!"
Hello `  My `  "World"	`! = "Hello My Domestic World!"
"Hello"	`!`  My World `! = "Hello! My Domestic World!"

says : "You say "Good Bye..." "I say "Hello""


"　改行を含む文字列を結合したい場合は、ブロックのような書き方となる。"
"　理由は、" "が、「リストの結合、及び関数合成」を意味するため。"
"　改行を含めたい場合。"

HW_in_enter:
	"Hello"	`
	"World!"


"　"'"は英文の"'s"「所有」を由来とし、アクセッサー演算子である。"
"　キー名を文字列指定もできる。変数に代入された文字列の場合、展開演算子"~"で中の文字列を取り出して使う"
"　アクセッサー演算子は、必ず非同期処理となる。"

point ' x
point ' x : 2

my_name: "mike"

point ' ~my_name

"　"?"は、' の左右を逆にしたもの。"

x ? point

condition ? [3 , 2]

caseValue ? 
	mike : "Hi mike!"
	kate : "Hi Mom!"
	1 : "first"
	2 : "second"

"　","は英文では「強い区切り」、「直積」を表す。"
"　" "は「直和」に使われる。"
"　要素に任意に要素を追加出来る。"

"　ここから単一の値の型では同じ意味。"

p0: x, y
p1: x y
p2: (x, y)
p3: (x y)
p4: {x, y}
p5: {x y}
p6: [x, y]
p7: [x y]

"　ここまでスカラー型では同じ意味。"

q: 
	r: 1 2
	s: 2 4


"　これは直和（配列の合成）"

r: [1 2] [3 4]

"これは直積（2次元配列）"

s: [1 2],[3 4]


"この言語では、あくまでラムダとしての関数定義のみ行える。"
"よって名前を付けたければ、「即ち」を使う"

id: x; x
dup: x; x, x

"　関数に対する「直和」とは、「関数合成、及び関数の評価」となる、よって関数をリストにしたければ「直積」のみが表記として可能"

f, g

"　"\t"（字下げ）によって、関数を複数行に分けることも可能。"

x;
	x ?

		AM: "Good Morining Sur."
		PM: "Good Afternoon Sur."


"　演算子は全て関数として扱えるため、ポイントフリーな記述が可能。"

"　ラムダを定義する場合（ポイントな記述）。"

(x ; x * 2) 3
{x ; x * 2} 3
[x ; x * 2] 3

(x ; 3 * x) 2
{x ; 3 * x} 2
[x ; 3 * x] 2

"　対象の引数が確定していない記法を利用する。"

(_ * 2) 3
{_ * 2} 3
[_ * 2] 3

(3 * _) 2
{3 * _} 2
[3 * _] 2

"　演算のカリー化（高階化）。"

(* 2) 3
{* 2} 3
[* 2] 3

(3 *) 2
{3 *} 2
[3 *] 2


"　ポイントフリースタイルの場合、は、記号と対象値の間に空白を置かない。"
"ポイントフリースタイルは、後方に必ず空白を挿入する（負の数との区分のため）"

*2 3
3* 2
-2 3
3- 2

f: *2 
g: +3 
fop: /2 
gop: -3 

"　ポイントフリーな記述も、字下げで複数行定義可能"

?
	AM: "Good Morining Sur."
	PM: "Good Afternoon Sur."

"　前置演算子はそのまま関数名としても問題ない。"
"　後置演算子は、 "_" 使う。"
"　前置演算子及び後置演算子は間に空白を置いてはならない。"

not: !
factrial: _!


not fasle = !false
factrial 8 = 8!

"　関数合成はカッコで優先を指定しない場合、左単位元とする。以下のように書く。"

h: f g
h 3 = g (f 3)
g (f 3) = g(f(3))


"　第１引数を前に置く記法があり、これはモナドと似た手続きの記述となる。"

3 f g = g f 3


"　途中の引数の変化に対して対応する。"

+2 * +3 5 4 = (5 + 2) * 4 + 3


"　配列をスプレッドオペレータで分割代入する。"

+2 * +3 ~[5 4] = (5 + 2) * 4 + 3


"　多引数関数の前置記法で、配列とスプレッドオペレータでやる。"

~[5 4] +2 * +3 = (5 + 3) * 4 + 2


"　分割代入は引数に後置で展開演算子。"

[a~ ; a] 1 2 3 4 5


"　展開演算子による配列の定義"

[0 ~ 10]


"展開演算子による、文字列のkey化"

~"myPrime" : 57

~"true"


"　定義された関数は必ず最後の結果を返す。(この場合は5を返す)"

returnTest: x y z;
	x
	z
	y

returnTest 4 5 6

"　"#"はexportになる。"

# myDict : name value; ~name : value
# gets : ?

