start       = { SOI ~ expression* ~ EOI }

expression  = {
  export
  | assign
  | lambda
  | list
  | or_xor
  | and
  | not
  | compare
  | add_sub
  | mul_div
  | power
  | factrial
  | coproduct
  | get
  | import
  | literal
  | block
}

NewBlock = _{
  PEEK_ALL ~ PUSH(indent+) ~ expression ~ (PEEK_ALL ~ expression)* ~ DROP
}

block = _{
  NEWLINE ~ NewBlock
  | "[" ~ expression+ ~ "]"
  | "{" ~ expression+ ~ "}"
  | "(" ~ expression+ ~ ")"
}

indent_line = {
  NEWLINE ~ indent
}

indent      = { "\t" | "  " | "    " }

prefix      = {
  f_export
  | f_not
  | f_get
  | f_spread
  | f_p_a
  | f_f_a
}

infix_L     = {
  f_product
  | f_coproduct
  | f_or
  | f_xor
  | f_and
  | f_add
  | f_sub
  | f_mul
  | f_div
  | f_mod
  | f_spread
  | f_get
  | f_p_a
  | f_f_a
}

compare_op  = {
  f_less
  | f_less_eq
  | f_eq
  | f_neq
  | f_more_eq
  | f_more
}

infix_R     = {
  f_assign
  | f_power
}

postfix     = { f_factrial }

f_export    = { "#" }
f_assign    = { ":" }
f_lambda    = { "?" }
f_product   = { "," }
f_coproduct = { " " }
f_or        = { "|" }
f_xor       = { ";" }
f_and       = { "&" }
f_not       = { "!" } //prefix
f_less      = { "<" }
f_less_eq   = { "<=" }
f_eq        = { "=" | "==" }
f_neq       = { "!=" }
f_more_eq   = { ">=" }
f_more      = { ">" }
f_add       = { "+" }
f_sub       = { "-" }
f_mul       = { "*" }
f_div       = { "/" }
f_mod       = { "%" }
f_power     = { "^" }
f_factrial  = { "!" } //postfix
f_spread    = { "~" }
f_get       = { "'" }
f_p_a       = { ",~" }
f_f_a       = { "?~" }
rest_param  = { "~" }
otherwise   = { unit }

export      = { f_export ~ expression+ }

assign      = {
    as_logic
  | as_number
  | as_char
  | as_string
  | as_list
  | as_lambda
  | as_none
}

as_logic    = {
  id_logic ~ f_assign ~ (logic | not)
}

as_number   = {
    as_natural
  | as_integer
  | as_real
  | as_hex
}

as_natural  = {
  id_natural ~ f_assign ~ (natural | factrial)
}

as_integer  = {
  id_integer ~ f_assign ~ (integer | factrial)
}

as_real     = {
  id_real ~ f_assign ~ (real | factrial)
}

as_hex      = {
  id_hex ~ f_assign ~ (hex | factrial)
}

as_char     = {
  id_char ~ f_assign ~ charactor
}

as_string   = {
  id_string ~ f_assign ~ string
}

as_lambda   = {
  id_lambda ~ f_assign ~ lambda
}

as_list     = {
  id_list ~ f_assign ~ list
}

as_none     = {
  id_none ~ f_assign ~ none
}

id_logic    = { ident }
id_natural  = { ident }
id_integer  = { ident }
id_real     = { ident }
id_hex      = { ident }
id_char     = { ident }
id_string   = { ident }
id_list     = { ident }
id_lambda   = { ident }
id_none     = { ident }

lambda      = {
  ident ~ (ident | f_spread ~ ident)* ~ f_lambda ~ expression+
  | arg_list
  | point_free
  | match_case
  | unit
}

arg_list    = {
  args? ~ (infix_L | compare_op | infix_R | id_lambda ) ~ (args | expression)*
  | (args | expression)* ~ (compare_op | infix_L | infix_R) ~ args
  | prefix ~ args
  | args ~ postfix
  | f_lambda ~ args+
  | "[" ~ args+ ~ "]"
  | "{" ~ args+ ~ "}"
  | "(" ~ args+ ~ ")"
}

args        = @{ "@" ~ (ASCII_DIGIT)* ~ rest_param? }

point_free  = {
  (id_lambda | infix_L | compare_op | infix_R) ~ literal
  | (logic | number | charactor | string) ~ (infix_L | compare_op | infix_R)
  | (infix_L | compare_op | infix_R) ~ ((NEWLINE ~ "\t" ~ expression+)+ | expression+) ~ NEWLINE
  | prefix
}

match_case = {
  (indent_line ~ ((literal | otherwise) ~ f_assign ~ expression+))+
}

l_product   = _{
  lambda
  | or_xor
  | and
  | not
  | compare
  | add_sub
  | mul_div
  | power
  | factrial
  | logic
  | number
  | string
  | dictionary
  | literal
  | block
}

dictionary  = {
  match_case
}

list     = {
  l_product ~ (f_product ~ expression)+
  | (indent ~ (expression ~ f_product))+ ~ NEWLINE
  | "[" ~ (expression ~ f_product)* ~ expression ~ "]"
  | "{" ~ (expression ~ f_product)* ~ expression ~  "}"
  | "(" ~ (expression ~ f_product)* ~ expression ~  ")"
  | (id_integer | id_char | charactor | integer | args) ~ f_spread ~ (id_integer | id_char | charactor | integer | args)
}

unit        = { "[]" }

or_xor      = {
  and ~ f_or ~ or_xor
  | and ~ f_xor ~ or_xor
  | and
}

and         = {
  not ~ f_and ~ and
  | not
}

not        = {
  f_not ~ (compare | logic | ident)
  | compare
  | logic
  | ident
}

compare     = {
    add_sub ~ f_less ~ add_sub
  | add_sub ~ f_less_eq ~ add_sub
  | add_sub ~ f_eq ~ add_sub
  | add_sub ~ f_neq ~ add_sub
  | add_sub ~ f_more_eq ~ add_sub
  | add_sub ~ f_more ~ add_sub
  | add_sub
}

add_sub     = {
  mul_div ~ f_add ~ add_sub
  | mul_div ~ f_sub ~ add_sub
  | mul_div
}

mul_div     = {
  power ~ f_mul ~ mul_div
  | power ~ f_div ~ mul_div
  | power ~ f_mod ~ mul_div
  | power
}

power       = {
  factrial ~ f_power ~ power
  | factrial
}

factrial    = {
  (number | ident) ~ f_factrial
  | number
  | ident
}

coproduct   = {
  compose
  | concat
}

compose   = {
  (lambda | id_lambda) ~ (f_coproduct ~ compose)+ 
}

concat      = {
  charactor+ ~ (f_coproduct ~ ident | concat+)*
  | string+ ~ concat*
}

get         = {
  f_get ~ ident ~ block*
  | (ident ~ f_get)+ ~ ident
}

import      = {
  f_get ~ (ident | string)
}

literal     = @{
  logic
  | number
  | charactor
  | string
  | lambda
  | none
  | id_logic
  | id_natural
  | id_integer
  | id_real
  | id_hex
  | id_char
  | id_string
  | id_list
  | id_lambda
  | id_none
}

logic       = {
  true
  | false
}

true        = @{ "$" }
false       = @{ "_" }

number = {
  natural
  | integer
  | real
  | hex
}

natural     = @{ ASCII_DIGIT+ }

integer     = @{ "-"? ~ natural }

real        = @{ integer ~ "." ~ natural }

hex         = @{ "0x"~ ASCII_HEX_DIGIT+ }

charactor   = @{ "\\" ~ ANY }

string      = { "`" ~ (!NEWLINE ~ ANY)* ~ "`" }

ident       = {
  (ASCII_ALPHANUMERIC | "_")+ ~ (ASCII_ALPHA | "_")
  | f_spread ~ string
}

none        = { unit }