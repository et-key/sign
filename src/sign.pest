grammar;

expression = {
    (expression+ ~ suffix)
    | (literal ~ " " ~ (infix_l | infix_r) ~ " " ~ expression+)
    | (prefix ~ expression+)
    | (literal ~ (" " ~ expression)*)
    | "(" ~ expression ~ ")"
    | "{" ~ expression ~ "}"
    | "[" ~ expression ~  "]"
}

// 基本的な構文規則
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

// リテラルの定義
literal = { boolean | number | charactor | string | list | table | function | identifier }

boolean = { true | false }

true = @{ "_" ~ "T" ~ "_" }
false = @{ "_" ~ "F" ~ "_" }

// 数値
number = { integer | float | hex | bit }
integer = @{ "-"? ~ ("0".."9")+ }
float = @{ "-"? ~ ("0".."9")+ ~ "." ~ ("0".."9")* }
hex = @{ "#" ~ (("0".."9") | ("a".."f") | ("A" ~ "F")) ~ (("0".."9") | ("a".."f") | ("A" ~ "F"))+ }
bit = @{ "#" ~ "b" ~ ("0" | "1")+ }

// 識別子の定義
identifier = @{ ("a".."z" | "A".."Z" | "_") ~ ("a".."z" | "A".."Z" | "0".."9" | "_")* }

// 文字列
content = { (!("\"" ~ WHITESPACE) ~ ANY)* }
string = { "\"" ~ content ~ "\"" ~ WHITESPACE }

// 文字
charactor = { "`" ~ ANY }

// 積
list = { expression ~ (product_op ~ expression)* }

// 関数
lambda = { (identifier ~ ((coproduct_op | product_op) ~ identifier)* ~ lambda_op ~ expression) | op_fn }
op_fn = { prefix | (binary_op | (expression ~ (infix_l | infix_r)) | ((infix_l | infix_r) ~ expression)) | (suffix ~ "_" ) }

prefix = { not_op | icmt_op | dcmt_op | spread_op }

suffix = { factrial_op | spread_op | icmt_op | dcmt_op }

binary_op = { infix_l | infix_r }

infix_l = { define_op | lambda_op | product_op | condition_op | or_op | xor_op | and_op | compare_op | add_op | mul_op }

infix_r = { pow_op | coproduct_op }

define_op = { ":" }

lambda_op = { ";" }

product_op = { "," }

condition_op = { "?" }

or_op = { "|" }

xor_op = { "^" }

and_op = { "&" }

not_op = { "!" }

compare_op = { "<" | ">" | "=" }

add_op = { "+" | "-" }

mul_op = { "*" | "/" | "%" }

factrial_op = { "!" }

coproduct_op = { " " }

spread_op = { "~" }
