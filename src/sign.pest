start       = { SOI ~ expression* ~ EOI }

expression  = {
  export
  | assign
  | lambda
  | product
  | select
  | or_xor
  | and
  | not
  | compare
  | add_sub
  | mul_div
  | power
  | factrial
  | pre_spread
  | get
  | coproduct
  | evaluate
  | literal
  | import
  | block
}

block = {
  (indent_line ~ expression+)+ ~ NEWLINE
  | "[" ~ expression+ ~ "]"
  | "{" ~ expression+ ~ "}"
  | "(" ~ expression+ ~ ")"
  | "[" ~ (NEWLINE ~ "\t" ~ expression+)+ "]"
  | "{" ~ (NEWLINE ~ "\t" ~ expression+)+ "}"
  | "(" ~ (NEWLINE ~ "\t" ~ expression+)+ ")"
}

indent_line = {
  NEWLINE ~ indent+
}

indent      = { "\t" }

operator    = { prefix | infix_L | compare_op | infix_R | postfix }
prefix      = { f_export | f_not | f_spread | f_import }
infix_L     = { f_product | f_coproduct | f_or | f_xor | f_and | f_add | f_sub | f_mul | f_div | f_mod | f_get }
compare_op  = { f_less | f_less_eq | f_eq | f_neq | f_more_eq | f_more }
infix_R     = { f_assign | f_select | f_power }
postfix     = { f_spread | f_factrial }

f_export    = { "#" }
f_assign    = { ":" }
f_lambda    = { ";" }
f_product   = { "," }
f_coproduct = { " " }
f_spread    = { "~" }
f_select    = { "?" }
f_or        = { "|" }
f_xor       = { "^" }
f_and       = { "&" }
f_not       = { "!" }
f_less      = { "<" }
f_less_eq   = { "<=" }
f_eq        = { "=" | "==" }
f_neq       = { "!=" }
f_more_eq   = { ">=" }
f_more      = { ">" }
f_add       = { "+" }
f_sub       = { "-" }
f_mul       = { "*" }
f_div       = { "/" }
f_mod       = { "%" }
f_power     = { "**" }
f_factrial  = { "!" }
f_get       = { "'" }
f_evaluate  = { NEWLINE }
f_import    = { "@" }

export      = { f_export ~ expression* }

assign      = { ident ~ f_assgin ~ expression+ }

lambda      = {
  (ident | ident ~ "~")+ ~ f_lambda ~ ((NEWLINE ~ "\t" ~ expression+)+ ~ NEWLINE | expression+)
  | under_bar
  | point_free
}

under_bar   = {
  "_" ~ (infix_L | compare_op | infix_R) ~ ("_" | expression)*
  | ("_" | expression)* ~ (compare_op | infix_L | infix_R) ~ "_"
  | prefix ~ "_"
  | "_" ~ postfix
  | (ident | lambda) ~ ("_" | expression)* ~ "_" ~ ("_" | expression)* 
}

point_free  = {
  (infix_L | infix_R) ~ ((NEWLINE ~ "\t" ~ expression+)+ ~ NEWLINE | expression+  ~ " ")
  | expression+ ~ (infix_L | infix_R) ~" "
  | prefix ~ " "
  | "_" ~ postfix ~ " "
}

product     = { expression+ ~ (f_product ~ expression)+ }

select      = {
  (string | ident | number | or_xor) ~ f_select ~ (dictionary | list | ident)
  | or_xor
}

or_xor      = {
  and ~ f_or ~ or_xor
  | and ~ f_xor ~ or_xor
  | and
}

and         = {
  not ~ f_and ~ and
  | not
}

not        = {
  f_not ~ (compare | logic | ident)
  | compare
  | logic
  | idnet
}

compare     = {
    add_sub ~ f_less ~ add_sub
  | add_sub ~ f_less_eq ~ add_sub
  | add_sub ~ f_eq ~ add_sub
  | add_sub ~ f_neq ~ add_sub
  | add_sub ~ f_more_eq ~ add_sub
  | add_sub ~ f_more ~ add_sub
  | add_sub
}

add_sub     = {
  mul_div ~ f_add ~ add_sub
  | mul_div ~ f_sub ~ add_sub
  | mul_div
}

mul_div     = {
  power ~ f_mul ~ mul_div
  | power ~ f_div ~ mul_div
  | power ~ f_mod ~ mul_div
  | power
}

power       = {
  factrial ~ f_power ~ power
  | factrial
}

factrial    = {
  (number | ident) ~ f_factrial
  | number
  | ident
}

pre_spread  = {
  f_spread ~ (dictionary | list | ident)
}

get         = {
  (dictionary | list | ident) ~ f_get ~ (string | ident | number | or_xor)
}

coproduct   = {
  compose_L
  | concat
}

compose_L   = {
  (lambda | ident) ~ (" " ~ compose_L)+ 
  | point_free ~ compose_L+
}

concat      = {
  cat_list
  | cat_string
}

cat_list    = {
  (product | ident) ~ (" " ~ (product | ident))+
}

cat_string  = {
  charactor+ ~ (" " ~ ident | cat_string+)*
  | string+ ~ cat_string*
}

literal     = @{
  number
  | charactor
  | string
  | list
  | dictionary
  | ident
}

number      = @{
  natural
  | integer
  | real
  | hex
}

natural     = @{ ASCII_DIGIT+ }

integer     = @{ ("-" | "+") ~ ASCII_DIGIT+ }

real        = @{ "-"? ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

hex         = @{ "0x"~ ASCII_HEX_DIGIT+ }

charactor   = @{ "`" ~ ANY }

string      = { "\"" ~ !("\t" | NEWLINE) ~ "\"" ~ ("\t" | NEWLINE) }

list        = { product | cat_list }

dictionary  = { indent ~ key ~ f_assign ~ (dictionary | expression+) }

ident       = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

key         = { (ASCII_ALPHANUMERIC | "_")+ | string }

import      = { f_import ~ (ident | string)}
